// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct DemoClientProgram;
impl sails_rs::client::Program for DemoClientProgram {}
pub trait DemoClient {
    type Env: sails_rs::client::GearEnv;
    fn ping_pong(&self) -> sails_rs::client::Service<ping_pong::PingPongImpl, Self::Env>;
    fn counter(&self) -> sails_rs::client::Service<counter::CounterImpl, Self::Env>;
    fn dog(&self) -> sails_rs::client::Service<dog::DogImpl, Self::Env>;
    fn references(&self) -> sails_rs::client::Service<references::ReferencesImpl, Self::Env>;
    fn this_that(&self) -> sails_rs::client::Service<this_that::ThisThatImpl, Self::Env>;
    fn value_fee(&self) -> sails_rs::client::Service<value_fee::ValueFeeImpl, Self::Env>;
    fn chaos(&self) -> sails_rs::client::Service<chaos::ChaosImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> DemoClient for sails_rs::client::Actor<DemoClientProgram, E> {
    type Env = E;
    fn ping_pong(&self) -> sails_rs::client::Service<ping_pong::PingPongImpl, Self::Env> {
        self.service(stringify!(PingPong))
    }
    fn counter(&self) -> sails_rs::client::Service<counter::CounterImpl, Self::Env> {
        self.service(stringify!(Counter))
    }
    fn dog(&self) -> sails_rs::client::Service<dog::DogImpl, Self::Env> {
        self.service(stringify!(Dog))
    }
    fn references(&self) -> sails_rs::client::Service<references::ReferencesImpl, Self::Env> {
        self.service(stringify!(References))
    }
    fn this_that(&self) -> sails_rs::client::Service<this_that::ThisThatImpl, Self::Env> {
        self.service(stringify!(ThisThat))
    }
    fn value_fee(&self) -> sails_rs::client::Service<value_fee::ValueFeeImpl, Self::Env> {
        self.service(stringify!(ValueFee))
    }
    fn chaos(&self) -> sails_rs::client::Service<chaos::ChaosImpl, Self::Env> {
        self.service(stringify!(Chaos))
    }
}
pub trait DemoClientCtors {
    type Env: sails_rs::client::GearEnv;
    /// Program constructor (called once at the very beginning of the program lifetime)
    fn default(self) -> sails_rs::client::PendingCtor<DemoClientProgram, io::Default, Self::Env>;
    /// Another program constructor (called once at the very beginning of the program lifetime)
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(
        self,
        counter: Option<u32>,
        dog_position: Option<(i32, i32)>,
    ) -> sails_rs::client::PendingCtor<DemoClientProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> DemoClientCtors
    for sails_rs::client::Deployment<DemoClientProgram, E>
{
    type Env = E;
    fn default(self) -> sails_rs::client::PendingCtor<DemoClientProgram, io::Default, Self::Env> {
        self.pending_ctor(())
    }
    fn new(
        self,
        counter: Option<u32>,
        dog_position: Option<(i32, i32)>,
    ) -> sails_rs::client::PendingCtor<DemoClientProgram, io::New, Self::Env> {
        self.pending_ctor((counter, dog_position))
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(Default () -> ());
    sails_rs::io_struct_impl!(New (counter: Option<u32>, dog_position: Option<(i32,i32,)>) -> ());
}

pub mod ping_pong {
    use super::*;
    pub trait PingPong {
        type Env: sails_rs::client::GearEnv;
        fn ping(&mut self, input: String) -> sails_rs::client::PendingCall<io::Ping, Self::Env>;
    }
    pub struct PingPongImpl;
    impl<E: sails_rs::client::GearEnv> PingPong for sails_rs::client::Service<PingPongImpl, E> {
        type Env = E;
        fn ping(&mut self, input: String) -> sails_rs::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call((input,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Ping (input: String) -> Result<String, String>);
    }
}

pub mod counter {
    use super::*;
    pub trait Counter {
        type Env: sails_rs::client::GearEnv;
        /// Add a value to the counter
        fn add(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env>;
        /// Substract a value from the counter
        fn sub(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Sub, Self::Env>;
        /// Get the current value
        fn value(&self) -> sails_rs::client::PendingCall<io::Value, Self::Env>;
    }
    pub struct CounterImpl;
    impl<E: sails_rs::client::GearEnv> Counter for sails_rs::client::Service<CounterImpl, E> {
        type Env = E;
        fn add(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((value,))
        }
        fn sub(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Sub, Self::Env> {
            self.pending_call((value,))
        }
        fn value(&self) -> sails_rs::client::PendingCall<io::Value, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Add (value: u32) -> u32);
        sails_rs::io_struct_impl!(Sub (value: u32) -> u32);
        sails_rs::io_struct_impl!(Value () -> u32);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum CounterEvents {
            /// Emitted when a new value is added to the counter
            Added(u32),
            /// Emitted when a value is subtracted from the counter
            Subtracted(u32),
        }
        impl sails_rs::client::Event for CounterEvents {
            const EVENT_NAMES: &'static [Route] = &["Added", "Subtracted"];
        }
        impl sails_rs::client::ServiceWithEvents for CounterImpl {
            type Event = CounterEvents;
        }
    }
}

pub mod dog {
    use super::*;
    pub trait Dog {
        type Env: sails_rs::client::GearEnv;
        fn make_sound(&mut self) -> sails_rs::client::PendingCall<io::MakeSound, Self::Env>;
        fn walk(&mut self, dx: i32, dy: i32) -> sails_rs::client::PendingCall<io::Walk, Self::Env>;
        fn avg_weight(&self) -> sails_rs::client::PendingCall<io::AvgWeight, Self::Env>;
        fn position(&self) -> sails_rs::client::PendingCall<io::Position, Self::Env>;
    }
    pub struct DogImpl;
    impl<E: sails_rs::client::GearEnv> Dog for sails_rs::client::Service<DogImpl, E> {
        type Env = E;
        fn make_sound(&mut self) -> sails_rs::client::PendingCall<io::MakeSound, Self::Env> {
            self.pending_call(())
        }
        fn walk(&mut self, dx: i32, dy: i32) -> sails_rs::client::PendingCall<io::Walk, Self::Env> {
            self.pending_call((dx, dy))
        }
        fn avg_weight(&self) -> sails_rs::client::PendingCall<io::AvgWeight, Self::Env> {
            self.pending_call(())
        }
        fn position(&self) -> sails_rs::client::PendingCall<io::Position, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(MakeSound () -> String);
        sails_rs::io_struct_impl!(Walk (dx: i32, dy: i32) -> ());
        sails_rs::io_struct_impl!(AvgWeight () -> u32);
        sails_rs::io_struct_impl!(Position () -> (i32,i32,));
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum DogEvents {
            Barked,
            Walked { from: (i32, i32), to: (i32, i32) },
        }
        impl sails_rs::client::Event for DogEvents {
            const EVENT_NAMES: &'static [Route] = &["Barked", "Walked"];
        }
        impl sails_rs::client::ServiceWithEvents for DogImpl {
            type Event = DogEvents;
        }
    }
}

pub mod references {
    use super::*;
    pub trait References {
        type Env: sails_rs::client::GearEnv;
        fn add(&mut self, v: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env>;
        fn add_byte(&mut self, byte: u8) -> sails_rs::client::PendingCall<io::AddByte, Self::Env>;
        fn guess_num(
            &mut self,
            number: u8,
        ) -> sails_rs::client::PendingCall<io::GuessNum, Self::Env>;
        fn incr(&mut self) -> sails_rs::client::PendingCall<io::Incr, Self::Env>;
        fn set_num(&mut self, number: u8) -> sails_rs::client::PendingCall<io::SetNum, Self::Env>;
        fn baked(&self) -> sails_rs::client::PendingCall<io::Baked, Self::Env>;
        fn last_byte(&self) -> sails_rs::client::PendingCall<io::LastByte, Self::Env>;
        fn message(&self) -> sails_rs::client::PendingCall<io::Message, Self::Env>;
    }
    pub struct ReferencesImpl;
    impl<E: sails_rs::client::GearEnv> References for sails_rs::client::Service<ReferencesImpl, E> {
        type Env = E;
        fn add(&mut self, v: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((v,))
        }
        fn add_byte(&mut self, byte: u8) -> sails_rs::client::PendingCall<io::AddByte, Self::Env> {
            self.pending_call((byte,))
        }
        fn guess_num(
            &mut self,
            number: u8,
        ) -> sails_rs::client::PendingCall<io::GuessNum, Self::Env> {
            self.pending_call((number,))
        }
        fn incr(&mut self) -> sails_rs::client::PendingCall<io::Incr, Self::Env> {
            self.pending_call(())
        }
        fn set_num(&mut self, number: u8) -> sails_rs::client::PendingCall<io::SetNum, Self::Env> {
            self.pending_call((number,))
        }
        fn baked(&self) -> sails_rs::client::PendingCall<io::Baked, Self::Env> {
            self.pending_call(())
        }
        fn last_byte(&self) -> sails_rs::client::PendingCall<io::LastByte, Self::Env> {
            self.pending_call(())
        }
        fn message(&self) -> sails_rs::client::PendingCall<io::Message, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Add (v: u32) -> u32);
        sails_rs::io_struct_impl!(AddByte (byte: u8) -> Vec<u8>);
        sails_rs::io_struct_impl!(GuessNum (number: u8) -> Result<String, String>);
        sails_rs::io_struct_impl!(Incr () -> super::ReferenceCount);
        sails_rs::io_struct_impl!(SetNum (number: u8) -> Result<(), String>);
        sails_rs::io_struct_impl!(Baked () -> String);
        sails_rs::io_struct_impl!(LastByte () -> Option<u8>);
        sails_rs::io_struct_impl!(Message () -> Option<String>);
    }
}

pub mod this_that {
    use super::*;
    pub trait ThisThat {
        type Env: sails_rs::client::GearEnv;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> sails_rs::client::PendingCall<io::DoThat, Self::Env>;
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, NonZeroU8),
            p4: TupleStruct,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env>;
        fn noop(&mut self) -> sails_rs::client::PendingCall<io::Noop, Self::Env>;
        fn that(&self) -> sails_rs::client::PendingCall<io::That, Self::Env>;
        fn this(&self) -> sails_rs::client::PendingCall<io::This, Self::Env>;
    }
    pub struct ThisThatImpl;
    impl<E: sails_rs::client::GearEnv> ThisThat for sails_rs::client::Service<ThisThatImpl, E> {
        type Env = E;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> sails_rs::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((param,))
        }
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, NonZeroU8),
            p4: TupleStruct,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2, p3, p4))
        }
        fn noop(&mut self) -> sails_rs::client::PendingCall<io::Noop, Self::Env> {
            self.pending_call(())
        }
        fn that(&self) -> sails_rs::client::PendingCall<io::That, Self::Env> {
            self.pending_call(())
        }
        fn this(&self) -> sails_rs::client::PendingCall<io::This, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoThat (param: super::DoThatParam) -> Result<(ActorId,NonZeroU32,super::ManyVariantsReply,), (String,)>);
        sails_rs::io_struct_impl!(DoThis (p1: u32, p2: String, p3: (Option<H160>,NonZeroU8,), p4: super::TupleStruct) -> (String,u32,));
        sails_rs::io_struct_impl!(Noop () -> ());
        sails_rs::io_struct_impl!(That () -> Result<String, String>);
        sails_rs::io_struct_impl!(This () -> u32);
    }
}

pub mod value_fee {
    use super::*;
    pub trait ValueFee {
        type Env: sails_rs::client::GearEnv;
        /// Return flag if fee taken and remain value,
        /// using special type `CommandReply<T>`
        fn do_something_and_take_fee(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env>;
    }
    pub struct ValueFeeImpl;
    impl<E: sails_rs::client::GearEnv> ValueFee for sails_rs::client::Service<ValueFeeImpl, E> {
        type Env = E;
        fn do_something_and_take_fee(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoSomethingAndTakeFee () -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum ValueFeeEvents {
            Withheld(u128),
        }
        impl sails_rs::client::Event for ValueFeeEvents {
            const EVENT_NAMES: &'static [Route] = &["Withheld"];
        }
        impl sails_rs::client::ServiceWithEvents for ValueFeeImpl {
            type Event = ValueFeeEvents;
        }
    }
}

pub mod chaos {
    use super::*;
    pub trait Chaos {
        type Env: sails_rs::client::GearEnv;
        fn noop(&self) -> sails_rs::client::PendingCall<io::Noop, Self::Env>;
        fn panic_after_wait(&self) -> sails_rs::client::PendingCall<io::PanicAfterWait, Self::Env>;
        fn reply_hook_counter(
            &self,
        ) -> sails_rs::client::PendingCall<io::ReplyHookCounter, Self::Env>;
        fn timeout_wait(&self) -> sails_rs::client::PendingCall<io::TimeoutWait, Self::Env>;
    }
    pub struct ChaosImpl;
    impl<E: sails_rs::client::GearEnv> Chaos for sails_rs::client::Service<ChaosImpl, E> {
        type Env = E;
        fn noop(&self) -> sails_rs::client::PendingCall<io::Noop, Self::Env> {
            self.pending_call(())
        }
        fn panic_after_wait(&self) -> sails_rs::client::PendingCall<io::PanicAfterWait, Self::Env> {
            self.pending_call(())
        }
        fn reply_hook_counter(
            &self,
        ) -> sails_rs::client::PendingCall<io::ReplyHookCounter, Self::Env> {
            self.pending_call(())
        }
        fn timeout_wait(&self) -> sails_rs::client::PendingCall<io::TimeoutWait, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Noop () -> ());
        sails_rs::io_struct_impl!(PanicAfterWait () -> ());
        sails_rs::io_struct_impl!(ReplyHookCounter () -> u32);
        sails_rs::io_struct_impl!(TimeoutWait () -> ());
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ReferenceCount(pub u32);
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct DoThatParam {
    pub p1: NonZeroU32,
    pub p2: ActorId,
    pub p3: ManyVariants,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ManyVariants {
    One,
    Two(u32),
    Three(Option<U256>),
    Four { a: u32, b: Option<u16> },
    Five((String, H256)),
    Six((u32,)),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ManyVariantsReply {
    One,
    Two,
    Three,
    Four,
    Five,
    Six,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct TupleStruct(pub bool);

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub PingPong {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl ping_pong::PingPong for PingPong { type Env = sails_rs::client::GstdEnv; fn ping (&mut self, input: String) -> sails_rs::client::PendingCall<ping_pong::io::Ping, sails_rs::client::GstdEnv>; } }
    mock! { pub Counter {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl counter::Counter for Counter { type Env = sails_rs::client::GstdEnv; fn add (&mut self, value: u32) -> sails_rs::client::PendingCall<counter::io::Add, sails_rs::client::GstdEnv>;fn sub (&mut self, value: u32) -> sails_rs::client::PendingCall<counter::io::Sub, sails_rs::client::GstdEnv>;fn value (& self, ) -> sails_rs::client::PendingCall<counter::io::Value, sails_rs::client::GstdEnv>; } }
    mock! { pub Dog {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl dog::Dog for Dog { type Env = sails_rs::client::GstdEnv; fn make_sound (&mut self, ) -> sails_rs::client::PendingCall<dog::io::MakeSound, sails_rs::client::GstdEnv>;fn walk (&mut self, dx: i32, dy: i32) -> sails_rs::client::PendingCall<dog::io::Walk, sails_rs::client::GstdEnv>;fn avg_weight (& self, ) -> sails_rs::client::PendingCall<dog::io::AvgWeight, sails_rs::client::GstdEnv>;fn position (& self, ) -> sails_rs::client::PendingCall<dog::io::Position, sails_rs::client::GstdEnv>; } }
    mock! { pub References {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl references::References for References { type Env = sails_rs::client::GstdEnv; fn add (&mut self, v: u32) -> sails_rs::client::PendingCall<references::io::Add, sails_rs::client::GstdEnv>;fn add_byte (&mut self, byte: u8) -> sails_rs::client::PendingCall<references::io::AddByte, sails_rs::client::GstdEnv>;fn guess_num (&mut self, number: u8) -> sails_rs::client::PendingCall<references::io::GuessNum, sails_rs::client::GstdEnv>;fn incr (&mut self, ) -> sails_rs::client::PendingCall<references::io::Incr, sails_rs::client::GstdEnv>;fn set_num (&mut self, number: u8) -> sails_rs::client::PendingCall<references::io::SetNum, sails_rs::client::GstdEnv>;fn baked (& self, ) -> sails_rs::client::PendingCall<references::io::Baked, sails_rs::client::GstdEnv>;fn last_byte (& self, ) -> sails_rs::client::PendingCall<references::io::LastByte, sails_rs::client::GstdEnv>;fn message (& self, ) -> sails_rs::client::PendingCall<references::io::Message, sails_rs::client::GstdEnv>; } }
    mock! { pub ThisThat {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl this_that::ThisThat for ThisThat { type Env = sails_rs::client::GstdEnv; fn do_that (&mut self, param: DoThatParam) -> sails_rs::client::PendingCall<this_that::io::DoThat, sails_rs::client::GstdEnv>;fn do_this (&mut self, p1: u32, p2: String, p3: (Option<H160>,NonZeroU8,), p4: TupleStruct) -> sails_rs::client::PendingCall<this_that::io::DoThis, sails_rs::client::GstdEnv>;fn noop (&mut self, ) -> sails_rs::client::PendingCall<this_that::io::Noop, sails_rs::client::GstdEnv>;fn that (& self, ) -> sails_rs::client::PendingCall<this_that::io::That, sails_rs::client::GstdEnv>;fn this (& self, ) -> sails_rs::client::PendingCall<this_that::io::This, sails_rs::client::GstdEnv>; } }
    mock! { pub ValueFee {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl value_fee::ValueFee for ValueFee { type Env = sails_rs::client::GstdEnv; fn do_something_and_take_fee (&mut self, ) -> sails_rs::client::PendingCall<value_fee::io::DoSomethingAndTakeFee, sails_rs::client::GstdEnv>; } }
    mock! { pub Chaos {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl chaos::Chaos for Chaos { type Env = sails_rs::client::GstdEnv; fn noop (& self, ) -> sails_rs::client::PendingCall<chaos::io::Noop, sails_rs::client::GstdEnv>;fn panic_after_wait (& self, ) -> sails_rs::client::PendingCall<chaos::io::PanicAfterWait, sails_rs::client::GstdEnv>;fn reply_hook_counter (& self, ) -> sails_rs::client::PendingCall<chaos::io::ReplyHookCounter, sails_rs::client::GstdEnv>;fn timeout_wait (& self, ) -> sails_rs::client::PendingCall<chaos::io::TimeoutWait, sails_rs::client::GstdEnv>; } }
}
