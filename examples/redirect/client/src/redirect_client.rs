// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct RedirectClientProgram;
impl RedirectClientProgram {
    pub const REDIRECT_ROUTE_ID: u8 = 1;
}
impl sails_rs::client::Program for RedirectClientProgram {}
pub trait RedirectClient {
    type Env: sails_rs::client::GearEnv;
    fn redirect(&self) -> sails_rs::client::Service<redirect::RedirectImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RedirectClient
    for sails_rs::client::Actor<RedirectClientProgram, E>
{
    type Env = E;
    fn redirect(&self) -> sails_rs::client::Service<redirect::RedirectImpl, Self::Env> {
        self.service(RedirectClientProgram::REDIRECT_ROUTE_ID)
    }
}
pub trait RedirectClientCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> sails_rs::client::PendingCtor<RedirectClientProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RedirectClientCtors
    for sails_rs::client::Deployment<RedirectClientProgram, E>
{
    type Env = E;
    fn new(self) -> sails_rs::client::PendingCtor<RedirectClientProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> (), 0, sails_rs::meta::InterfaceId::zero());
}

pub mod redirect {
    use super::*;
    pub trait Redirect {
        type Env: sails_rs::client::GearEnv;
        /// Exit from program with inheritor ID
        fn exit(
            &mut self,
            inheritor_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env>;
        /// Returns program ID of the current program
        fn get_program_id(&self) -> sails_rs::client::PendingCall<io::GetProgramId, Self::Env>;
    }
    pub struct RedirectImpl;
    impl sails_rs::client::Identifiable for RedirectImpl {
        const INTERFACE_ID: sails_rs::InterfaceId =
            sails_rs::InterfaceId::from_bytes_8([186, 88, 222, 225, 203, 117, 81, 30]);
    }
    impl<E: sails_rs::client::GearEnv> Redirect for sails_rs::client::Service<RedirectImpl, E> {
        type Env = E;
        fn exit(
            &mut self,
            inheritor_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env> {
            self.pending_call((inheritor_id,))
        }
        fn get_program_id(&self) -> sails_rs::client::PendingCall<io::GetProgramId, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Exit (inheritor_id: ActorId) -> (), 0, <super::RedirectImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
        sails_rs::io_struct_impl!(GetProgramId () -> ActorId, 1, <super::RedirectImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
    }
}
