// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct RmrkResourceProgram;
impl RmrkResourceProgram {
    pub const RMRK_RESOURCE_ROUTE_ID: u8 = 1;
}
impl sails_rs::client::Program for RmrkResourceProgram {}
pub trait RmrkResource {
    type Env: sails_rs::client::GearEnv;
    fn rmrk_resource(
        &self,
    ) -> sails_rs::client::Service<rmrk_resource::RmrkResourceImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RmrkResource
    for sails_rs::client::Actor<RmrkResourceProgram, E>
{
    type Env = E;
    fn rmrk_resource(
        &self,
    ) -> sails_rs::client::Service<rmrk_resource::RmrkResourceImpl, Self::Env> {
        self.service_at(RmrkResourceProgram::RMRK_RESOURCE_ROUTE_ID)
    }
}
pub trait RmrkResourceCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> sails_rs::client::PendingCtor<RmrkResourceProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RmrkResourceCtors
    for sails_rs::client::Deployment<RmrkResourceProgram, E>
{
    type Env = E;
    fn new(self) -> sails_rs::client::PendingCtor<RmrkResourceProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> (), 0);
}

pub mod rmrk_resource {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub enum Error {
        NotAuthorized,
        ZeroResourceId,
        ResourceAlreadyExists,
        ResourceNotFound,
        WrongResourceType,
        PartNotFound,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub enum Resource {
        Basic(BasicResource),
        Slot(SlotResource),
        Composed(ComposedResource),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub struct BasicResource {
        /// URI like IPFS hash
        pub src: String,
        /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
        /// resource.
        pub thumb: Option<String>,
        /// Reference to IPFS location of metadata
        pub metadata_uri: String,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub struct SlotResource {
        /// URI like ipfs hash
        pub src: String,
        /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
        /// resource.
        pub thumb: String,
        /// Reference to IPFS location of metadata
        pub metadata_uri: String,
        pub base: ActorId,
        /// If the resource has the slot property, it was designed to fit into a specific Base's slot.
        pub slot: u32,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub struct ComposedResource {
        /// URI like ipfs hash
        pub src: String,
        /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
        /// resource.
        pub thumb: String,
        /// Reference to IPFS location of metadata
        pub metadata_uri: String,
        pub base: ActorId,
        pub parts: Vec<u32>,
    }
    pub trait RmrkResource {
        type Env: sails_rs::client::GearEnv;
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::AddPartToResource, Self::Env>;
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> sails_rs::client::PendingCall<io::AddResourceEntry, Self::Env>;
        fn resource(
            &self,
            resource_id: u8,
        ) -> sails_rs::client::PendingCall<io::Resource, Self::Env>;
    }
    pub struct RmrkResourceImpl;
    impl sails_rs::client::Identifiable for RmrkResourceImpl {
        const INTERFACE_ID: sails_rs::InterfaceId =
            sails_rs::InterfaceId::from_bytes_8([215, 56, 96, 51, 70, 205, 63, 27]);
    }
    impl<E: sails_rs::client::GearEnv> RmrkResource for sails_rs::client::Service<RmrkResourceImpl, E> {
        type Env = E;
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::AddPartToResource, Self::Env> {
            self.pending_call((resource_id, part_id))
        }
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> sails_rs::client::PendingCall<io::AddResourceEntry, Self::Env> {
            self.pending_call((resource_id, resource))
        }
        fn resource(
            &self,
            resource_id: u8,
        ) -> sails_rs::client::PendingCall<io::Resource, Self::Env> {
            self.pending_call((resource_id,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AddPartToResource (resource_id: u8, part_id: u32) -> super::Result<u32, super::Error, >, 0 , <super::RmrkResourceImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
        sails_rs::io_struct_impl!(AddResourceEntry (resource_id: u8, resource: super::Resource) -> super::Result<(u8, super::Resource, ), super::Error, >, 1 , <super::RmrkResourceImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
        sails_rs::io_struct_impl!(Resource (resource_id: u8) -> super::Result<super::Resource, super::Error, >, 2 , <super::RmrkResourceImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = sails_rs::scale_codec)]
        #[reflect_hash(crate = sails_rs)]
        pub enum RmrkResourceEvents {
            #[codec(index = 0)]
            PartAdded { resource_id: u8, part_id: u32 },
            #[codec(index = 1)]
            ResourceAdded { resource_id: u8 },
        }
        impl sails_rs::client::Event for RmrkResourceEvents {}
        impl sails_rs::client::Identifiable for RmrkResourceEvents {
            const INTERFACE_ID: sails_rs::InterfaceId =
                <RmrkResourceImpl as sails_rs::client::Identifiable>::INTERFACE_ID;
        }
        impl sails_rs::client::ServiceWithEvents for RmrkResourceImpl {
            type Event = RmrkResourceEvents;
        }
    }
}
