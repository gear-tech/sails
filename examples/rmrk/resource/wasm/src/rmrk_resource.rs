// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct RmrkResourceProgram;
impl sails_rs::client::Program for RmrkResourceProgram {}
pub trait RmrkResource {
    type Env: sails_rs::client::GearEnv;
    fn rmrk_resource(
        &self,
    ) -> sails_rs::client::Service<rmrk_resource::RmrkResourceImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RmrkResource
    for sails_rs::client::Actor<RmrkResourceProgram, E>
{
    type Env = E;
    fn rmrk_resource(
        &self,
    ) -> sails_rs::client::Service<rmrk_resource::RmrkResourceImpl, Self::Env> {
        self.service(stringify!(RmrkResource))
    }
}
pub trait RmrkResourceCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> sails_rs::client::PendingCtor<RmrkResourceProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RmrkResourceCtors
    for sails_rs::client::Deployment<RmrkResourceProgram, E>
{
    type Env = E;
    fn new(self) -> sails_rs::client::PendingCtor<RmrkResourceProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod rmrk_resource {
    use super::*;
    pub trait RmrkResource {
        type Env: sails_rs::client::GearEnv;
        /// !@interface_id = 0x9730cce8a925be37
        /// !@entry_id = 0x0001
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::AddPartToResource, Self::Env>;
        /// !@entry_id = 0x0002
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> sails_rs::client::PendingCall<io::AddResourceEntry, Self::Env>;
        /// !@entry_id = 0x0003
        fn resource(
            &self,
            resource_id: u8,
        ) -> sails_rs::client::PendingCall<io::Resource, Self::Env>;
    }
    pub struct RmrkResourceImpl;
    impl<E: sails_rs::client::GearEnv> RmrkResource for sails_rs::client::Service<RmrkResourceImpl, E> {
        type Env = E;
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::AddPartToResource, Self::Env> {
            self.pending_call((resource_id, part_id))
        }
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> sails_rs::client::PendingCall<io::AddResourceEntry, Self::Env> {
            self.pending_call((resource_id, resource))
        }
        fn resource(
            &self,
            resource_id: u8,
        ) -> sails_rs::client::PendingCall<io::Resource, Self::Env> {
            self.pending_call((resource_id,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AddPartToResource (resource_id: u8, part_id: u32) -> Result<u32, super::Error>);
        sails_rs::io_struct_impl!(AddResourceEntry (resource_id: u8, resource: super::Resource) -> Result<(u8,super::Resource,), super::Error>);
        sails_rs::io_struct_impl!(Resource (resource_id: u8) -> Result<super::Resource, super::Error>);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum RmrkResourceEvents {
            /// !@entry_id = 0x0002
            ResourceAdded { resource_id: u8 },
            /// !@entry_id = 0x0001
            PartAdded { resource_id: u8, part_id: u32 },
        }
        impl sails_rs::client::Event for RmrkResourceEvents {
            const EVENT_NAMES: &'static [Route] = &["ResourceAdded", "PartAdded"];
        }
        impl sails_rs::client::ServiceWithEvents for RmrkResourceImpl {
            type Event = RmrkResourceEvents;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Error {
    NotAuthorized,
    ZeroResourceId,
    ResourceAlreadyExists,
    ResourceNotFound,
    WrongResourceType,
    PartNotFound,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Resource {
    Basic(BasicResource),
    Slot(SlotResource),
    Composed(ComposedResource),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct BasicResource {
    /// URI like IPFS hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: Option<String>,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SlotResource {
    /// URI like ipfs hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: String,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
    pub base: ActorId,
    /// If the resource has the slot property, it was designed to fit into a specific Base's slot.
    pub slot: u32,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ComposedResource {
    /// URI like ipfs hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: String,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
    pub base: ActorId,
    pub parts: Vec<u32>,
}
