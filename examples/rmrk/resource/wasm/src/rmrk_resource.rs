// Code generated by sails-client-gen. DO NOT EDIT.
use sails_rs::{client::*, prelude::*};
pub struct RmrkResourceProgram;
impl Program for RmrkResourceProgram {}
pub trait RmrkResource {
    type Env: GearEnv;
    fn rmrk_resource(&self) -> Service<Self::Env, rmrk_resource::RmrkResourceImpl>;
}
impl<E: GearEnv> RmrkResource for Actor<E, RmrkResourceProgram> {
    type Env = E;
    fn rmrk_resource(&self) -> Service<Self::Env, rmrk_resource::RmrkResourceImpl> {
        self.service(stringify!(RmrkResource))
    }
}
pub trait RmrkResourceCtors {
    type Env: GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> PendingCtor<Self::Env, RmrkResourceProgram, io::New>;
}
impl<E: GearEnv> RmrkResourceCtors for Deployment<E, RmrkResourceProgram> {
    type Env = E;
    fn new(self) -> PendingCtor<Self::Env, RmrkResourceProgram, io::New> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod rmrk_resource {
    use super::*;
    pub trait RmrkResource {
        type Env: GearEnv;
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> PendingCall<Self::Env, io::AddPartToResource>;
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> PendingCall<Self::Env, io::AddResourceEntry>;
        fn resource(&self, resource_id: u8) -> PendingCall<Self::Env, io::Resource>;
    }
    pub struct RmrkResourceImpl;
    impl<E: GearEnv> RmrkResource for Service<E, RmrkResourceImpl> {
        type Env = E;
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> PendingCall<Self::Env, io::AddPartToResource> {
            self.pending_call((resource_id, part_id))
        }
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> PendingCall<Self::Env, io::AddResourceEntry> {
            self.pending_call((resource_id, resource))
        }
        fn resource(&self, resource_id: u8) -> PendingCall<Self::Env, io::Resource> {
            self.pending_call((resource_id,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AddPartToResource (resource_id: u8, part_id: u32) -> Result<u32, super::Error>);
        sails_rs::io_struct_impl!(AddResourceEntry (resource_id: u8, resource: super::Resource) -> Result<(u8,super::Resource,), super::Error>);
        sails_rs::io_struct_impl!(Resource (resource_id: u8) -> Result<super::Resource, super::Error>);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum RmrkResourceEvents {
            ResourceAdded { resource_id: u8 },
            PartAdded { resource_id: u8, part_id: u32 },
        }
        impl EventDecode for RmrkResourceEvents {
            const EVENT_NAMES: &'static [Route] = &["ResourceAdded", "PartAdded"];
        }
        impl ServiceEvent for RmrkResourceImpl {
            type Event = RmrkResourceEvents;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Error {
    NotAuthorized,
    ZeroResourceId,
    ResourceAlreadyExists,
    ResourceNotFound,
    WrongResourceType,
    PartNotFound,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Resource {
    Basic(BasicResource),
    Slot(SlotResource),
    Composed(ComposedResource),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct BasicResource {
    /// URI like IPFS hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: Option<String>,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SlotResource {
    /// URI like ipfs hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: String,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
    pub base: ActorId,
    /// If the resource has the slot property, it was designed to fit into a specific Base's slot.
    pub slot: u32,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ComposedResource {
    /// URI like ipfs hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: String,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
    pub base: ActorId,
    pub parts: Vec<u32>,
}
