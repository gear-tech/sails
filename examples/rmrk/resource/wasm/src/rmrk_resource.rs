// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    String,
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
};
pub struct RmrkResourceFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> RmrkResourceFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::RmrkResourceFactory for RmrkResourceFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, rmrk_resource_factory::io::New>::new(self.remoting.clone(), ())
    }
}

pub mod rmrk_resource_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const IS_ACTIVATION: bool = true;
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
    }
}
pub struct RmrkResource<R> {
    remoting: R,
}
impl<R> RmrkResource<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::RmrkResource for RmrkResource<R> {
    type Args = R::Args;
    fn add_part_to_resource(
        &mut self,
        resource_id: u8,
        part_id: u32,
    ) -> impl Call<Output = Result<u32, Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_resource::io::AddPartToResource>::new(
            self.remoting.clone(),
            (resource_id, part_id),
        )
    }
    fn add_resource_entry(
        &mut self,
        resource_id: u8,
        resource: Resource,
    ) -> impl Call<Output = Result<(u8, Resource), Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_resource::io::AddResourceEntry>::new(
            self.remoting.clone(),
            (resource_id, resource),
        )
    }
    fn resource(
        &self,
        resource_id: u8,
    ) -> impl Query<Output = Result<Resource, Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_resource::io::Resource>::new(self.remoting.clone(), resource_id)
    }
}

pub mod rmrk_resource {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddPartToResource(());
        impl AddPartToResource {
            #[allow(dead_code)]
            pub fn encode_call(resource_id: u8, part_id: u32) -> Vec<u8> {
                <AddPartToResource as ActionIo>::encode_call(&(resource_id, part_id))
            }
        }
        impl ActionIo for AddPartToResource {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                48, 82, 109, 114, 107, 82, 101, 115, 111, 117, 114, 99, 101, 68, 65, 100, 100, 80,
                97, 114, 116, 84, 111, 82, 101, 115, 111, 117, 114, 99, 101,
            ];
            type Params = (u8, u32);
            type Reply = Result<u32, super::Error>;
        }
        pub struct AddResourceEntry(());
        impl AddResourceEntry {
            #[allow(dead_code)]
            pub fn encode_call(resource_id: u8, resource: super::Resource) -> Vec<u8> {
                <AddResourceEntry as ActionIo>::encode_call(&(resource_id, resource))
            }
        }
        impl ActionIo for AddResourceEntry {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                48, 82, 109, 114, 107, 82, 101, 115, 111, 117, 114, 99, 101, 64, 65, 100, 100, 82,
                101, 115, 111, 117, 114, 99, 101, 69, 110, 116, 114, 121,
            ];
            type Params = (u8, super::Resource);
            type Reply = Result<(u8, super::Resource), super::Error>;
        }
        pub struct Resource(());
        impl Resource {
            #[allow(dead_code)]
            pub fn encode_call(resource_id: u8) -> Vec<u8> {
                <Resource as ActionIo>::encode_call(&resource_id)
            }
        }
        impl ActionIo for Resource {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                48, 82, 109, 114, 107, 82, 101, 115, 111, 117, 114, 99, 101, 32, 82, 101, 115, 111,
                117, 114, 99, 101,
            ];
            type Params = u8;
            type Reply = Result<super::Resource, super::Error>;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum RmrkResourceEvents {
            ResourceAdded { resource_id: u8 },
            PartAdded { resource_id: u8, part_id: u32 },
        }
        impl EventIo for RmrkResourceEvents {
            const ROUTE: &'static [u8] =
                &[48, 82, 109, 114, 107, 82, 101, 115, 111, 117, 114, 99, 101];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[
                    52, 82, 101, 115, 111, 117, 114, 99, 101, 65, 100, 100, 101, 100,
                ],
                &[36, 80, 97, 114, 116, 65, 100, 100, 101, 100],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<RmrkResourceEvents> {
            RemotingListener::<_, RmrkResourceEvents>::new(remoting)
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Error {
    NotAuthorized,
    ZeroResourceId,
    ResourceAlreadyExists,
    ResourceNotFound,
    WrongResourceType,
    PartNotFound,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Resource {
    Basic(BasicResource),
    Slot(SlotResource),
    Composed(ComposedResource),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct BasicResource {
    /// URI like IPFS hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: Option<String>,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SlotResource {
    /// URI like ipfs hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: String,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
    pub base: ActorId,
    /// If the resource has the slot property, it was designed to fit into a specific Base's slot.
    pub slot: u32,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ComposedResource {
    /// URI like ipfs hash
    pub src: String,
    /// If the resource has the thumb property, this will be a URI to a thumbnail of the given
    /// resource.
    pub thumb: String,
    /// Reference to IPFS location of metadata
    pub metadata_uri: String,
    pub base: ActorId,
    pub parts: Vec<u32>,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait RmrkResourceFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait RmrkResource {
        type Args;
        fn add_part_to_resource(
            &mut self,
            resource_id: u8,
            part_id: u32,
        ) -> impl Call<Output = Result<u32, Error>, Args = Self::Args>;
        fn add_resource_entry(
            &mut self,
            resource_id: u8,
            resource: Resource,
        ) -> impl Call<Output = Result<(u8, Resource), Error>, Args = Self::Args>;
        fn resource(
            &self,
            resource_id: u8,
        ) -> impl Query<Output = Result<Resource, Error>, Args = Self::Args>;
    }
}
