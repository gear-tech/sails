type Error = enum {
  PartIdCantBeZero,
  BadConfig,
  PartAlreadyExists,
  ZeroLengthPassed,
  PartDoesNotExist,
  WrongPartFormat,
  NotAllowedToCall,
};

type Part = enum {
  Fixed: FixedPart,
  Slot: SlotPart,
};

type FixedPart = struct {
  /// An optional zIndex of base part layer.
  /// specifies the stack order of an element.
  /// An element with greater stack order is always in front of an element with a lower stack order.
  z: opt u32,
  /// The metadata URI of the part.
  metadata_uri: str,
};

type SlotPart = struct {
  /// Array of whitelisted collections that can be equipped in the given slot. Used with slot parts only.
  equippable: vec actor_id,
  /// An optional zIndex of base part layer.
  /// specifies the stack order of an element.
  /// An element with greater stack order is always in front of an element with a lower stack order.
  z: opt u32,
  /// The metadata URI of the part.
  metadata_uri: str,
};

constructor {
  New : ();
};

service RmrkCatalog {
  /// !@interface_id = 0x1b048b460a99a72f
  /// !@entry_id = 0x0001
  AddEquippables : (part_id: u32, collection_ids: vec actor_id) -> result (struct { u32, vec actor_id }, Error);
  /// !@entry_id = 0x0002
  AddParts : (parts: map (u32, Part)) -> result (map (u32, Part), Error);
  /// !@entry_id = 0x0005
  RemoveEquippable : (part_id: u32, collection_id: actor_id) -> result (struct { u32, actor_id }, Error);
  /// !@entry_id = 0x0006
  RemoveParts : (part_ids: vec u32) -> result (vec u32, Error);
  /// !@entry_id = 0x0007
  ResetEquippables : (part_id: u32) -> result (null, Error);
  /// !@entry_id = 0x0008
  SetEquippablesToAll : (part_id: u32) -> result (null, Error);
  /// !@entry_id = 0x0003
  query Equippable : (part_id: u32, collection_id: actor_id) -> result (bool, Error);
  /// !@entry_id = 0x0004
  query Part : (part_id: u32) -> opt Part;
};

