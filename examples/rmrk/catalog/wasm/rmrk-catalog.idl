type Error = enum {
  PartIdCantBeZero,
  BadConfig,
  PartAlreadyExists,
  ZeroLengthPassed,
  PartDoesNotExist,
  WrongPartFormat,
  NotAllowedToCall,
};

type Part = enum {
  Fixed: FixedPart,
  Slot: SlotPart,
};

type FixedPart = struct {
  /// An optional zIndex of base part layer.
  /// specifies the stack order of an element.
  /// An element with greater stack order is always in front of an element with a lower stack order.
  z: Option<u32>,
  /// The metadata URI of the part.
  metadata_uri: String,
};

type SlotPart = struct {
  /// Array of whitelisted collections that can be equipped in the given slot. Used with slot parts only.
  equippable: [ActorId],
  /// An optional zIndex of base part layer.
  /// specifies the stack order of an element.
  /// An element with greater stack order is always in front of an element with a lower stack order.
  z: Option<u32>,
  /// The metadata URI of the part.
  metadata_uri: String,
};

constructor {
  New : ();
};

service RmrkCatalog {
  AddEquippables : (part_id: u32, collection_ids: [ActorId]) -> Result<(u32, [ActorId]), Error>;
  AddParts : (parts: [(u32, Part)]) -> Result<[(u32, Part)], Error>;
  RemoveEquippable : (part_id: u32, collection_id: ActorId) -> Result<(u32, ActorId), Error>;
  RemoveParts : (part_ids: [u32]) -> Result<[u32], Error>;
  ResetEquippables : (part_id: u32) -> Result<(), Error>;
  SetEquippablesToAll : (part_id: u32) -> Result<(), Error>;
  query Equippable : (part_id: u32, collection_id: ActorId) -> Result<bool, Error>;
  query Part : (part_id: u32) -> Option<Part>;
};

