#![no_std]

use gstd::{future, msg, vec, Box};
use sails_service::{CompositeService, Service as ServiceTrait};
use this_that_app::{commands::handlers as c_handlers, queries::handlers as q_handlers, Service};

static SERVICE: Service = Service::new(
    |command| Box::pin(future::ready(c_handlers::handle_commands(command))),
    q_handlers::handle_queries,
);

fn _composite_service() -> &'static CompositeService {
    static mut COMPOSITE_SERVICE: Option<CompositeService> = None;
    unsafe {
        COMPOSITE_SERVICE.get_or_insert_with(|| {
            CompositeService::new(vec![(
                "this-that",
                Box::new(Service::new(
                    |command| Box::pin(future::ready(c_handlers::handle_commands(command))),
                    q_handlers::handle_queries,
                )) as Box<dyn ServiceTrait + Sync>,
            )])
        })
    }
}

// TODO: This function might be generated by some macro like `gprogram`
#[gstd::async_main]
async fn main() {
    let input = msg::load_bytes().expect("This needs to be handled in some way: read error");
    let (output, is_error) = SERVICE.process_command(&input).await;
    if is_error {
        unsafe {
            gsys::gr_panic(output.as_ptr(), output.len() as u32);
        }
    }
    msg::reply(output, 0).expect("This needs to be handled in a consistent way: reply error");
}

// TODO: This function might be generated by some macro like `gprogram`
#[no_mangle]
extern "C" fn state() {
    let output = msg::with_read_on_stack(|input| {
        SERVICE.process_query(input.expect("This needs to be handled in some way: read error"))
    });
    msg::reply(output, 0).expect("This needs to be handled in a consistent way: reply error");
}
