#![no_std]

use gstd::msg;
use sails_service::Service as ServiceTrait;
use this_that_app::{commands::handlers as c_handlers, queries::handlers as q_handlers, Service};

static SERVICE: Service = Service::new(c_handlers::handle_commands, q_handlers::handle_queries);

// TODO: This function might be generated by some macro like `gprogram`
#[gstd::async_main]
async fn main() {
    let input = msg::load_bytes().expect("This needs to be handled in some way: read error");
    let (output, is_error) = SERVICE.process_command(&input).await;
    if is_error {
        unsafe {
            gsys::gr_panic(output.as_ptr(), output.len() as u32);
        }
    }
    msg::reply(output, 0).expect("This needs to be handled in a consistent way: reply error");
}

// TODO: This function might be generated by some macro like `gprogram`
#[no_mangle]
extern "C" fn state() {
    let output = msg::with_read_on_stack(|input| {
        SERVICE.process_query(input.expect("This needs to be handled in some way: read error"))
    });
    msg::reply(output, 0).expect("This needs to be handled in a consistent way: reply error");
}
