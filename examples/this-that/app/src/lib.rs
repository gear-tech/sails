#![no_std]

use gmeta::{InOut, Metadata};
#[allow(unused_imports)]
use gstd::debug;
use gstd::prelude::*;
use sails_macros::{command_handlers, query_handlers};
use sails_service::SimpleService;

pub struct ProgramMetadata;

// TODO: This might be generated by some macro like `gprogram`
impl Metadata for ProgramMetadata {
    type Init = ();
    type Handle = InOut<commands::Commands, commands::CommandResponses>; // Uses generated types
    type Others = ();
    type Reply = ();
    type Signal = ();
    type State = InOut<queries::Queries, queries::QueryResponses>; // Uses generated types
}

// TODO: The 2 below structs and their impls could be generated by the `commmand_handlers!`/`query_handlers!` macros
pub struct CommandProcessorMeta;

impl sails_service::RequestProcessorMeta for CommandProcessorMeta {
    type Request = commands::Commands;
    type Response = commands::CommandResponses;
    type ProcessFn = fn(Self::Request) -> (Self::Response, bool);
    // For async processing
    //type Handle = fn(Self::Requests) -> BoxedFuture<Self::Responses>;
}

pub struct QueryProcessorMeta;

impl sails_service::RequestProcessorMeta for QueryProcessorMeta {
    type Request = queries::Queries;
    type Response = queries::QueryResponses;
    type ProcessFn = fn(Self::Request) -> (Self::Response, bool);
    //type Handle = fn(Self::Requests) -> BoxedFuture<Self::Responses>;
}

pub type Service = SimpleService<CommandProcessorMeta, QueryProcessorMeta>;

#[derive(Debug, Encode, Decode, TypeInfo)]
pub struct DoThatParam {
    pub p1: u32,
    pub p2: String,
    pub p3: ManyVariants,
}

#[derive(Debug, Encode, Decode, TypeInfo)]
pub struct TupleStruct(bool);

#[derive(Debug, Encode, Decode, TypeInfo)]
pub enum ManyVariants {
    One,
    Two(u32),
    Three(Option<u32>),
    Four { a: u32, b: Option<u16> },
    Five(String, u32),
    Six((u32,)), // IDEA can't handle meta with single element tuple
}

#[command_handlers]
pub mod commands {
    use super::*;

    // This
    fn do_this(
        p1: u32,
        p2: String,
        p3: (Option<String>, u8),
        p4: TupleStruct,
    ) -> Result<(String, u32), String> {
        debug!("Handling 'do_this': {}, {}, {:?}, {:?}", p1, p2, p3, p4);
        Ok((p2, p1))
    }

    // That
    fn do_that(
        param: DoThatParam,
    ) -> Result<(String, u32), (String,) /* IDEA can't handle meta with single element tuple */>
    {
        debug!("Handling 'do_that': {:?}", param);
        Ok((param.p2, param.p1))
    }

    // Fail
    fn fail(message: String) -> Result<(), String> {
        debug!("Handling 'fail': {}", message);
        Err(message)
    }
}

#[query_handlers]
pub mod queries {
    use super::*;

    // This
    fn this() -> Result<u32, String> {
        debug!("Handling 'this'");
        Ok(42)
    }

    // That
    fn that() -> Result<String, String> {
        debug!("Handling 'that'");
        Ok("Forty two".into())
    }

    // Fail
    fn fail() -> Result<(), String> {
        debug!("Handling 'fail'");
        Err("Failed".into())
    }
}
