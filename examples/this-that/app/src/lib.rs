use gmeta::{InOut, Metadata};
#[allow(unused_imports)]
use gstd::debug;
use gstd::prelude::*;
use sails_macros::{command_handlers, query_handlers};
use sails_service::{BoxedFuture, SimpleService};

pub struct ProgramMetadata;

// TODO: This might be generated by some macro like `gprogram`
impl Metadata for ProgramMetadata {
    type Init = ();
    type Handle = InOut<commands::Commands, commands::CommandResponses>; // Uses generated types
    type Others = ();
    type Reply = ();
    type Signal = ();
    type State = InOut<queries::Queries, queries::QueryResponses>; // Uses generated types
}

// TODO: The 2 below structs and their impls could be generated by the `commmand_handlers!`/`query_handlers!` macros
pub struct CommandProcessorMeta;

impl sails_service::CommandProcessorMeta for CommandProcessorMeta {
    type Request = commands::Commands;
    type Response = commands::CommandResponses;
    type ProcessFn = fn(Self::Request) -> BoxedFuture<(Self::Response, bool)>;
}

pub struct QueryProcessorMeta;

impl sails_service::QueryProcessorMeta for QueryProcessorMeta {
    type Request = queries::Queries;
    type Response = queries::QueryResponses;
    type ProcessFn = fn(Self::Request) -> (Self::Response, bool);
}

pub type Service = SimpleService<CommandProcessorMeta, QueryProcessorMeta>;

#[derive(Debug, Encode, Decode, TypeInfo)]
pub struct DoThatParam {
    pub p1: u32,
    pub p2: String,
    pub p3: ManyVariants,
}

#[derive(Debug, Encode, Decode, TypeInfo)]
pub struct TupleStruct(pub bool);

#[derive(Debug, Encode, Decode, TypeInfo)]
pub enum ManyVariants {
    One,
    Two(u32),
    Three(Option<Vec<u8>>),
    Four { a: u32, b: Option<u16> },
    Five(String, u32),
    Six((u32,)), // IDEA can't handle meta with single element tuple
}

#[command_handlers]
pub mod commands {
    use super::*;

    // This
    async fn do_this(
        p1: u32,
        p2: String,
        p3: (Option<String>, u8),
        p4: TupleStruct,
    ) -> Result<(String, u32), String> {
        debug!("Handling 'do_this': {}, {}, {:?}, {:?}", p1, p2, p3, p4);
        Ok((p2, p1))
    }

    // That
    fn do_that(
        param: DoThatParam,
    ) -> Result<(String, u32), (String,) /* IDEA can't handle meta with single element tuple */>
    {
        debug!("Handling 'do_that': {:?}", param);
        Ok((param.p2, param.p1))
    }

    // Fail
    fn fail(message: String) -> Result<(), String> {
        debug!("Handling 'fail': {}", message);
        Err(message)
    }
}

#[query_handlers]
pub mod queries {
    use super::*;

    // This
    fn this() -> Result<u32, String> {
        debug!("Handling 'this'");
        Ok(42)
    }

    // That
    fn that() -> Result<String, String> {
        debug!("Handling 'that'");
        Ok("Forty two".into())
    }

    // Fail
    fn fail() -> Result<(), String> {
        debug!("Handling 'fail'");
        Err("Failed".into())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use commands::handlers::client::Client;
    use gstd::panic;
    use gtest::*;
    use sails_client::{GTestSender, SendError};

    #[tokio::test]
    async fn test_program() {
        let system = System::new();
        system.init_verbose_logger();

        let program = Program::from_file(
            &system,
            "../../../target/wasm32-unknown-unknown/debug/this_that.wasm",
        );

        let sender_id = [1; 32];
        let mut transport = GTestSender::new(&program);
        let client = Client::new();

        // init
        program.send(sender_id, [0; 0]);

        let resp = client
            .do_that(DoThatParam {
                p1: 0xFFFF,
                p2: "AAAA".to_owned(),
                p3: ManyVariants::One,
            })
            .send(&mut transport)
            .await
            .expect("call failed");

        assert_eq!(resp.unwrap(), ("AAAA".to_string(), 0xFFFF));

        // fail
        let err = client
            .fail("123".to_owned())
            .send(&mut transport)
            .await
            .unwrap_err();

        match err {
            SendError::Sender(run_result) => {
                use gstd::errors::{
                    ErrorReplyReason::Execution, ReplyCode::Error,
                    SimpleExecutionError::UserspacePanic,
                };
                let code = run_result.log()[0].reply_code().unwrap();
                assert_eq!(code, Error(Execution(UserspacePanic)));
            }
            _ => panic!("unexpected error kind: {err:?}"),
        }
    }

    #[test]
    fn test_into_bytes() {
        let client = Client::new();

        // to bytes
        let payload = client
            .do_that(DoThatParam {
                p1: 0xFFFF,
                p2: "AAAA".to_owned(),
                p3: ManyVariants::One,
            })
            .into_bytes();

        assert_eq!(payload, [1, 255, 255, 0, 0, 16, 65, 65, 65, 65, 0]);
    }
}
