---
source: client-gen/tests/generator.rs
expression: "gen(idl, \"RmrkCatalog\")"
---
// Code generated by sails-client-gen. DO NOT EDIT.
use core::marker::PhantomData;
#[allow(unused_imports)]
use sails_rtl::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rtl::{
    calls::{Activation, Call, Remoting, RemotingAction},
    prelude::*,
    String,
};
#[derive(Default)]
pub struct RmrkCatalogFactory(());
impl RmrkCatalogFactory {
    #[allow(unused)]
    pub fn new() -> Self {
        Self(())
    }
}
impl<A: Default> traits::RmrkCatalogFactory<A> for RmrkCatalogFactory {
    fn new(remoting: impl Remoting<A>) -> impl Activation<A> {
        RemotingAction::new(remoting, &[12, 78, 101, 119], ())
    }
}

#[derive(Clone)]
pub struct RmrkCatalog<R, A>
where
    R: Remoting<A>,
    A: Default,
{
    remoting: R,
    _phantom: PhantomData<A>,
}

impl<A: Default, R: Remoting<A>> RmrkCatalog<R, A> {
    pub fn new(remoting: R) -> Self {
        Self {
            remoting,
            _phantom: PhantomData,
        }
    }
}

impl<R, A> traits::RmrkCatalog<R, A> for RmrkCatalog<R, A>
where
    R: Remoting<A> + Clone,
    A: Default,
{
    fn add_equippables(
        &mut self,
        part_id: u32,
        collection_ids: Vec<ActorId>,
    ) -> impl Call<A, Result<(u32, Vec<ActorId>), Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 56, 65, 100, 100, 69, 113,
                117, 105, 112, 112, 97, 98, 108, 101, 115,
            ],
            (part_id, collection_ids),
        )
    }
    fn add_parts(
        &mut self,
        parts: BTreeMap<u32, Part>,
    ) -> impl Call<A, Result<BTreeMap<u32, Part>, Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 32, 65, 100, 100, 80, 97,
                114, 116, 115,
            ],
            parts,
        )
    }
    fn remove_equippable(
        &mut self,
        part_id: u32,
        collection_id: ActorId,
    ) -> impl Call<A, Result<(u32, ActorId), Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 64, 82, 101, 109, 111, 118,
                101, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101,
            ],
            (part_id, collection_id),
        )
    }
    fn remove_parts(&mut self, part_ids: Vec<u32>) -> impl Call<A, Result<Vec<u32>, Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 44, 82, 101, 109, 111, 118,
                101, 80, 97, 114, 116, 115,
            ],
            part_ids,
        )
    }
    fn reset_equippables(&mut self, part_id: u32) -> impl Call<A, Result<(), Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 64, 82, 101, 115, 101, 116,
                69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ],
            part_id,
        )
    }
    fn set_equippables_to_all(&mut self, part_id: u32) -> impl Call<A, Result<(), Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 76, 83, 101, 116, 69, 113,
                117, 105, 112, 112, 97, 98, 108, 101, 115, 84, 111, 65, 108, 108,
            ],
            part_id,
        )
    }
    fn equippable(
        &self,
        part_id: u32,
        collection_id: ActorId,
    ) -> impl Call<A, Result<bool, Error>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 40, 69, 113, 117, 105, 112,
                112, 97, 98, 108, 101,
            ],
            (part_id, collection_id),
        )
    }
    fn part(&self, part_id: u32) -> impl Call<A, Option<Part>> {
        RemotingAction::new(
            self.remoting.clone(),
            &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 16, 80, 97, 114, 116,
            ],
            part_id,
        )
    }
}

pub mod rmrk_catalog_calls {
    use super::*;

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct AddEquippablesCall(pub u32, pub Vec<ActorId>);
    impl AddEquippablesCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(27 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[
                56, 65, 100, 100, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[
                56, 65, 100, 100, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[15..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<(u32, Vec<ActorId>), Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct AddPartsCall(pub BTreeMap<u32, Part>);
    impl AddPartsCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(21 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[32, 65, 100, 100, 80, 97, 114, 116, 115]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[32, 65, 100, 100, 80, 97, 114, 116, 115]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[9..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<BTreeMap<u32, Part>, Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct RemoveEquippableCall(pub u32, pub ActorId);
    impl RemoveEquippableCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(29 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[
                64, 82, 101, 109, 111, 118, 101, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101,
            ]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[
                64, 82, 101, 109, 111, 118, 101, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101,
            ]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[17..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<(u32, ActorId), Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct RemovePartsCall(pub Vec<u32>);
    impl RemovePartsCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(24 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[44, 82, 101, 109, 111, 118, 101, 80, 97, 114, 116, 115]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[44, 82, 101, 109, 111, 118, 101, 80, 97, 114, 116, 115]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[12..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<Vec<u32>, Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct ResetEquippablesCall(pub u32);
    impl ResetEquippablesCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(29 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[
                64, 82, 101, 115, 101, 116, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[
                64, 82, 101, 115, 101, 116, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[17..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<(), Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct SetEquippablesToAllCall(pub u32);
    impl SetEquippablesToAllCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(32 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[
                76, 83, 101, 116, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115, 84, 111, 65,
                108, 108,
            ]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[
                76, 83, 101, 116, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115, 84, 111, 65,
                108, 108,
            ]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[20..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<(), Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct EquippableCall(pub u32, pub ActorId);
    impl EquippableCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(23 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[40, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[40, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[11..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(
            reply: Vec<u8>,
        ) -> Result<Result<bool, Error>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }

    #[derive(Debug, Encode, Decode)]
    #[codec(crate = sails_rtl::scale_codec)]
    pub struct PartCall(pub u32);
    impl PartCall {
        #[allow(unused)]
        pub fn encode(&self) -> Vec<u8> {
            let mut result = Vec::with_capacity(17 + self.encoded_size());
            result.extend_from_slice(&[44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103]);
            result.extend_from_slice(&[16, 80, 97, 114, 116]);
            self.encode_to(&mut result);
            result
        }
        #[allow(unused)]
        pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            bytes = &bytes[12..];
            if !bytes.starts_with(&[16, 80, 97, 114, 116]) {
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }
            bytes = &bytes[5..];
            let call = Decode::decode(&mut bytes)?;
            Ok(call)
        }

        #[allow(unused)]
        pub fn decode_reply(reply: Vec<u8>) -> Result<Option<Part>, parity_scale_codec::Error> {
            let mut reply = reply.as_slice();
            let result = Decode::decode(&mut reply)?;
            Ok(result)
        }
    }
}
#[derive(PartialEq, Debug, Encode, Decode)]
#[codec(crate = sails_rtl::scale_codec)]
pub enum Error {
    PartIdCantBeZero,
    BadConfig,
    PartAlreadyExists,
    ZeroLengthPassed,
    PartDoesNotExist,
    WrongPartFormat,
    NotAllowedToCall,
}
#[derive(PartialEq, Debug, Encode, Decode)]
#[codec(crate = sails_rtl::scale_codec)]
pub enum Part {
    Fixed(FixedPart),
    Slot(SlotPart),
}
#[derive(PartialEq, Debug, Encode, Decode)]
#[codec(crate = sails_rtl::scale_codec)]
pub struct FixedPart {
    pub z: Option<u32>,
    pub metadata_uri: String,
}
#[derive(PartialEq, Debug, Encode, Decode)]
#[codec(crate = sails_rtl::scale_codec)]
pub struct SlotPart {
    pub equippable: Vec<ActorId>,
    pub z: Option<u32>,
    pub metadata_uri: String,
}
pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait RmrkCatalogFactory<A: Default> {
        #[allow(clippy::new_ret_no_self)]
        fn new(remoting: impl Remoting<A>) -> impl Activation<A>;
    }
    pub trait RmrkCatalog<R, TCallArgs> {
        #[allow(clippy::type_complexity)]
        fn add_equippables(
            &mut self,
            part_id: u32,
            collection_ids: Vec<ActorId>,
        ) -> impl Call<TCallArgs, Result<(u32, Vec<ActorId>), Error>>;
        #[allow(clippy::type_complexity)]
        fn add_parts(
            &mut self,
            parts: BTreeMap<u32, Part>,
        ) -> impl Call<TCallArgs, Result<BTreeMap<u32, Part>, Error>>;
        #[allow(clippy::type_complexity)]
        fn remove_equippable(
            &mut self,
            part_id: u32,
            collection_id: ActorId,
        ) -> impl Call<TCallArgs, Result<(u32, ActorId), Error>>;
        #[allow(clippy::type_complexity)]
        fn remove_parts(
            &mut self,
            part_ids: Vec<u32>,
        ) -> impl Call<TCallArgs, Result<Vec<u32>, Error>>;
        #[allow(clippy::type_complexity)]
        fn reset_equippables(&mut self, part_id: u32) -> impl Call<TCallArgs, Result<(), Error>>;
        #[allow(clippy::type_complexity)]
        fn set_equippables_to_all(
            &mut self,
            part_id: u32,
        ) -> impl Call<TCallArgs, Result<(), Error>>;
        #[allow(clippy::type_complexity)]
        fn equippable(
            &self,
            part_id: u32,
            collection_id: ActorId,
        ) -> impl Call<TCallArgs, Result<bool, Error>>;
        #[allow(clippy::type_complexity)]
        fn part(&self, part_id: u32) -> impl Call<TCallArgs, Option<Part>>;
    }
}
