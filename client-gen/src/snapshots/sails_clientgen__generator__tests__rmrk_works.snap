---
source: client-gen/src/generator.rs
expression: generate(program).unwrap()
---
// Code generated by sails-client-gen. DO NOT EDIT.
use parity_scale_codec::{Decode, Encode};
#[allow(unused_imports)]
use sails_rtl::collections::BTreeMap;
use sails_rtl::{
    calls::RemotingAction, gstd::calls::Args, gstd::calls::Remoting, prelude::*, String,
};
pub trait Service {
    #[allow(clippy::type_complexity)]
    fn add_equippables(
        &mut self,
        part_id: u32,
        collection_ids: Vec<ActorId>,
    ) -> RemotingAction<Remoting, Args, Result<(u32, Vec<ActorId>), Error>>;
    #[allow(clippy::type_complexity)]
    fn add_parts(
        &mut self,
        parts: BTreeMap<u32, Part>,
    ) -> RemotingAction<Remoting, Args, Result<BTreeMap<u32, Part>, Error>>;
    #[allow(clippy::type_complexity)]
    fn remove_equippable(
        &mut self,
        part_id: u32,
        collection_id: ActorId,
    ) -> RemotingAction<Remoting, Args, Result<(u32, ActorId), Error>>;
    #[allow(clippy::type_complexity)]
    fn remove_parts(
        &mut self,
        part_ids: Vec<u32>,
    ) -> RemotingAction<Remoting, Args, Result<Vec<u32>, Error>>;
    #[allow(clippy::type_complexity)]
    fn reset_equippables(
        &mut self,
        part_id: u32,
    ) -> RemotingAction<Remoting, Args, Result<(), Error>>;
    #[allow(clippy::type_complexity)]
    fn set_equippables_to_all(
        &mut self,
        part_id: u32,
    ) -> RemotingAction<Remoting, Args, Result<(), Error>>;
    #[allow(clippy::type_complexity)]
    fn equippable(
        &self,
        part_id: u32,
        collection_id: ActorId,
    ) -> RemotingAction<Remoting, Args, Result<bool, Error>>;
    #[allow(clippy::type_complexity)]
    fn part(&self, part_id: u32) -> RemotingAction<Remoting, Args, Option<Part>>;
}

#[derive(Clone)]
pub struct Client {
    sender: Remoting,
}

impl Client {
    pub fn new(sender: Remoting) -> Self {
        Self { sender }
    }
}

impl Service for Client {
    fn add_equippables(
        &mut self,
        part_id: u32,
        collection_ids: Vec<ActorId>,
    ) -> RemotingAction<Remoting, Args, Result<(u32, Vec<ActorId>), Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[
                56, 65, 100, 100, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ],
            (part_id, collection_ids),
        )
    }
    fn add_parts(
        &mut self,
        parts: BTreeMap<u32, Part>,
    ) -> RemotingAction<Remoting, Args, Result<BTreeMap<u32, Part>, Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[32, 65, 100, 100, 80, 97, 114, 116, 115],
            parts,
        )
    }
    fn remove_equippable(
        &mut self,
        part_id: u32,
        collection_id: ActorId,
    ) -> RemotingAction<Remoting, Args, Result<(u32, ActorId), Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[
                64, 82, 101, 109, 111, 118, 101, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101,
            ],
            (part_id, collection_id),
        )
    }
    fn remove_parts(
        &mut self,
        part_ids: Vec<u32>,
    ) -> RemotingAction<Remoting, Args, Result<Vec<u32>, Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[44, 82, 101, 109, 111, 118, 101, 80, 97, 114, 116, 115],
            part_ids,
        )
    }
    fn reset_equippables(
        &mut self,
        part_id: u32,
    ) -> RemotingAction<Remoting, Args, Result<(), Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[
                64, 82, 101, 115, 101, 116, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ],
            part_id,
        )
    }
    fn set_equippables_to_all(
        &mut self,
        part_id: u32,
    ) -> RemotingAction<Remoting, Args, Result<(), Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[
                76, 83, 101, 116, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115, 84, 111, 65,
                108, 108,
            ],
            part_id,
        )
    }
    fn equippable(
        &self,
        part_id: u32,
        collection_id: ActorId,
    ) -> RemotingAction<Remoting, Args, Result<bool, Error>> {
        RemotingAction::new(
            self.sender.clone(),
            &[40, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101],
            (part_id, collection_id),
        )
    }
    fn part(&self, part_id: u32) -> RemotingAction<Remoting, Args, Option<Part>> {
        RemotingAction::new(self.sender.clone(), &[16, 80, 97, 114, 116], part_id)
    }
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub enum Error {
    PartIdCantBeZero,
    BadConfig,
    PartAlreadyExists,
    ZeroLengthPassed,
    PartDoesNotExist,
    WrongPartFormat,
    NotAllowedToCall,
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub enum Part {
    Fixed(FixedPart),
    Slot(SlotPart),
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub struct FixedPart {
    z: Option<u32>,
    metadata_uri: String,
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub struct SlotPart {
    equippable: Vec<ActorId>,
    z: Option<u32>,
    metadata_uri: String,
}

