---
source: client-gen/src/generator.rs
expression: generate(program).unwrap()
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use gstd::collections::BTreeMap;
use gstd::prelude::*;
use parity_scale_codec::{Decode, Encode};
use sails_sender::{Call, GStdSender};
pub trait Service {
    fn add_parts(
        &mut self,
        parts: BTreeMap<u32, RmrkCatalogAppPartsPart>,
    ) -> Call<Result<BTreeMap<u32, RmrkCatalogAppPartsPart>, RmrkCatalogAppErrorsError>>;
    fn remove_parts(
        &mut self,
        part_ids: Vec<u32>,
    ) -> Call<Result<Vec<u32>, RmrkCatalogAppErrorsError>>;
    fn add_equippables(
        &mut self,
        part_id: u32,
        collection_ids: Vec<GstdCommonPrimitivesActorId>,
    ) -> Call<Result<(u32, Vec<GstdCommonPrimitivesActorId>), RmrkCatalogAppErrorsError>>;
    fn remove_equippable(
        &mut self,
        part_id: u32,
        collection_id: GstdCommonPrimitivesActorId,
    ) -> Call<Result<(u32, GstdCommonPrimitivesActorId), RmrkCatalogAppErrorsError>>;
    fn reset_equippables(&mut self, part_id: u32) -> Call<Result<(), RmrkCatalogAppErrorsError>>;
    fn set_equippables_to_all(
        &mut self,
        part_id: u32,
    ) -> Call<Result<(), RmrkCatalogAppErrorsError>>;
    fn part(&self, part_id: u32) -> Call<Option<RmrkCatalogAppPartsPart>>;
    fn equippable(
        &self,
        part_id: u32,
        collection_id: GstdCommonPrimitivesActorId,
    ) -> Call<Result<bool, RmrkCatalogAppErrorsError>>;
}

#[derive(Clone)]
pub struct Client<'a> {
    sender: &'a GStdSender,
}

impl<'a> Client<'a> {
    pub fn new(sender: &'a GStdSender) -> Self {
        Self { sender }
    }
}

impl<'a> Service for Client<'a> {
    fn add_parts(
        &mut self,
        parts: BTreeMap<u32, RmrkCatalogAppPartsPart>,
    ) -> Call<Result<BTreeMap<u32, RmrkCatalogAppPartsPart>, RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "AddParts", parts)
    }
    fn remove_parts(
        &mut self,
        part_ids: Vec<u32>,
    ) -> Call<Result<Vec<u32>, RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "RemoveParts", part_ids)
    }
    fn add_equippables(
        &mut self,
        part_id: u32,
        collection_ids: Vec<GstdCommonPrimitivesActorId>,
    ) -> Call<Result<(u32, Vec<GstdCommonPrimitivesActorId>), RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "AddEquippables", (part_id, collection_ids))
    }
    fn remove_equippable(
        &mut self,
        part_id: u32,
        collection_id: GstdCommonPrimitivesActorId,
    ) -> Call<Result<(u32, GstdCommonPrimitivesActorId), RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "RemoveEquippable", (part_id, collection_id))
    }
    fn reset_equippables(&mut self, part_id: u32) -> Call<Result<(), RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "ResetEquippables", part_id)
    }
    fn set_equippables_to_all(
        &mut self,
        part_id: u32,
    ) -> Call<Result<(), RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "SetEquippablesToAll", part_id)
    }
    fn part(&self, part_id: u32) -> Call<Option<RmrkCatalogAppPartsPart>> {
        Call::new(self.sender, "Part", part_id)
    }
    fn equippable(
        &self,
        part_id: u32,
        collection_id: GstdCommonPrimitivesActorId,
    ) -> Call<Result<bool, RmrkCatalogAppErrorsError>> {
        Call::new(self.sender, "Equippable", (part_id, collection_id))
    }
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub enum RmrkCatalogAppPartsPart {
    Fixed(RmrkCatalogAppPartsFixedPart),
    Slot(RmrkCatalogAppPartsSlotPart),
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub struct RmrkCatalogAppPartsFixedPart {
    z: Option<u32>,
    metadata_uri: String,
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub struct RmrkCatalogAppPartsSlotPart {
    equippable: Vec<GstdCommonPrimitivesActorId>,
    z: Option<u32>,
    metadata_uri: String,
}
#[derive(PartialEq, Debug, Encode, Decode)]
pub struct GstdCommonPrimitivesActorId([u8; 32]);
#[derive(PartialEq, Debug, Encode, Decode)]
pub enum RmrkCatalogAppErrorsError {
    PartIdCantBeZero,
    BadConfig,
    PartAlreadyExists,
    ZeroLengthPassed,
    PartDoesNotExist,
    WrongPartFormat,
    NotAllowedToCall,
}

