use anyhow::Result;
use convert_case::{Case, Casing};
use parity_scale_codec::Encode;
use sails_idl_parser::{ast::visitor, ast::visitor::Visitor, ast::*};
use std::io::Write;

pub fn generate(program: Program, default_service_name: &str) -> Result<String> {
    let mut generator = RootGenerator::new(default_service_name);
    visitor::accept_program(&program, &mut generator);

    let code = generator.finalize();

    // Check for parsing errors
    let code = pretty_with_rustfmt(&code);

    Ok(code)
}

// not using prettyplease since it's bad at reporting syntax errors and also removes comments
// TODO(holykol): Fallback if rustfmt is not in PATH would be nice
fn pretty_with_rustfmt(code: &str) -> String {
    use std::process::Command;
    let mut child = Command::new("rustfmt")
        .arg("--config")
        .arg("format_strings=false")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .spawn()
        .expect("Failed to spawn rustfmt");

    let child_stdin = child.stdin.as_mut().expect("Failed to open stdin");
    child_stdin
        .write_all(code.as_bytes())
        .expect("Failed to write to rustfmt");

    let output = child
        .wait_with_output()
        .expect("Failed to wait for rustfmt");

    if !output.status.success() {
        panic!(
            "rustfmt failed with status: {}\n{}",
            output.status,
            String::from_utf8(output.stderr).expect("Failed to read rustfmt stderr")
        );
    }

    String::from_utf8(output.stdout).expect("Failed to read rustfmt output")
}

struct RootGenerator<'a> {
    code: String,
    traits_code: String,
    default_service_name: &'a str,
}

impl<'a> RootGenerator<'a> {
    fn new(default_service_name: &'a str) -> Self {
        let mut code = String::new();

        code.push_str("// Code generated by sails-client-gen. DO NOT EDIT.\n");
        code.push_str("#[allow(unused_imports)]\n");
        code.push_str(
            "use sails_rtl::{prelude::*, String, calls::{Call, Activation, Remoting, RemotingAction}};\n",
        );
        code.push_str("#[allow(unused_imports)]\n");
        code.push_str("use sails_rtl::collections::BTreeMap;\n");
        code.push_str("use core::marker::PhantomData;\n");

        Self {
            default_service_name,
            traits_code: String::new(),
            code,
        }
    }

    fn finalize(mut self) -> String {
        self.code.push_str("pub mod traits {\n");
        self.code.push_str("use super::*;\n");
        self.code.push_str(&self.traits_code);
        self.code.push_str("}\n");

        self.code
    }
}

impl<'a, 'ast> Visitor<'ast> for RootGenerator<'a> {
    fn visit_ctor(&mut self, ctor: &'ast Ctor) {
        let mut ctor_gen = CtorTraitGenerator::new(self.default_service_name.to_owned());
        ctor_gen.visit_ctor(ctor);

        self.traits_code.push_str(&ctor_gen.code);

        let mut ctor_gen = CtorFactoryGenerator::new(self.default_service_name.to_owned());
        ctor_gen.visit_ctor(ctor);
        self.code.push_str(&ctor_gen.code);
    }

    fn visit_service(&mut self, service: &'ast Service) {
        let service_name = if service.name().is_empty() {
            self.default_service_name
        } else {
            service.name()
        };

        let path = service.name();

        let mut service_gen = ServiceGenerator::new(service_name.to_owned());
        service_gen.visit_service(service);

        self.traits_code.push_str(&service_gen.code);

        let mut client_gen = ClientGenerator::new(service_name.to_owned(), path.to_owned());
        client_gen.visit_service(service);
        self.code.push_str(&client_gen.code);

        let mut client_gen = CallBuilderGenerator::new(service_name.to_owned(), path.to_owned());

        client_gen.visit_service(service);
        self.code.push_str(&client_gen.code);
    }

    fn visit_type(&mut self, t: &'ast Type) {
        let mut type_gen = TypeGenerator::new(t.name());
        type_gen.visit_type(t);
        self.code.push_str(&type_gen.code);
    }
}

struct CtorTraitGenerator {
    service_name: String,
    code: String,
}

impl CtorTraitGenerator {
    fn new(service_name: String) -> Self {
        Self {
            service_name,
            code: String::new(),
        }
    }
}

impl<'ast> Visitor<'ast> for CtorTraitGenerator {
    fn visit_ctor(&mut self, ctor: &'ast Ctor) {
        self.code.push_str("#[allow(dead_code)]\n");
        self.code.push_str(&format!(
            "pub trait {}Factory<A: Default> {{\n",
            self.service_name
        ));
        visitor::accept_ctor(ctor, self);
        self.code.push_str("}\n");
    }

    fn visit_ctor_func(&mut self, func: &'ast CtorFunc) {
        let fn_name = func.name().to_case(Case::Snake);

        if fn_name == "new" {
            // https://rust-lang.github.io/rust-clippy/master/index.html#/new_ret_no_self
            self.code.push_str("#[allow(clippy::new_ret_no_self)]\n");
        }
        self.code
            .push_str(&format!("fn {fn_name}(remoting: impl Remoting<A>,"));

        visitor::accept_ctor_func(func, self);

        self.code.push_str(")-> impl Activation<A>;\n");
    }

    fn visit_func_param(&mut self, func_param: &'ast FuncParam) {
        let type_decl_code = generate_type_decl_code(func_param.type_decl());
        self.code
            .push_str(&format!("{}: {},", func_param.name(), type_decl_code));
    }
}

struct CtorFactoryGenerator {
    service_name: String,
    code: String,
}

impl CtorFactoryGenerator {
    fn new(service_name: String) -> Self {
        Self {
            service_name,
            code: String::new(),
        }
    }
}

impl<'ast> Visitor<'ast> for CtorFactoryGenerator {
    fn visit_ctor(&mut self, ctor: &'ast Ctor) {
        self.code.push_str("#[derive(Default)]");
        self.code
            .push_str(&format!("pub struct {}Factory(());\n", self.service_name));
        self.code
            .push_str(&format!("impl {}Factory {{\n", self.service_name));
        self.code.push_str(
            "
            #[allow(unused)]
            pub fn new() -> Self {
                Self(())
            }
        ",
        );
        self.code.push_str("}\n");

        self.code.push_str(&format!(
            "impl<A: Default> traits::{}Factory<A> for {}Factory {{\n",
            self.service_name, self.service_name,
        ));
        visitor::accept_ctor(ctor, self);
        self.code.push_str("}\n");
    }

    fn visit_ctor_func(&mut self, func: &'ast CtorFunc) {
        let fn_name = func.name();
        let fn_name_snake = fn_name.to_case(Case::Snake);

        self.code
            .push_str(&format!("fn {fn_name_snake}(remoting: impl Remoting<A>,",));

        visitor::accept_ctor_func(func, self);

        self.code.push_str(")-> impl Activation<A> {\n");
        let args = encoded_args(func.params());

        let route_bytes = fn_name
            .encode()
            .into_iter()
            .map(|x| x.to_string())
            .collect::<Vec<_>>()
            .join(",");

        self.code.push_str(&format!(
            r#"RemotingAction::new(remoting, &[{route_bytes}], {args})"#
        ));

        self.code.push_str("}\n");
    }

    fn visit_func_param(&mut self, func_param: &'ast FuncParam) {
        let type_decl_code = generate_type_decl_code(func_param.type_decl());
        self.code
            .push_str(&format!("{}: {},", func_param.name(), type_decl_code));
    }
}

struct ServiceGenerator {
    service_name: String,
    code: String,
}

impl ServiceGenerator {
    fn new(service_name: String) -> Self {
        Self {
            service_name,
            code: String::new(),
        }
    }
}

impl<'ast> Visitor<'ast> for ServiceGenerator {
    fn visit_service(&mut self, service: &'ast Service) {
        self.code.push_str(&format!(
            "pub trait {}<R, TCallArgs> {{\n",
            self.service_name
        ));
        visitor::accept_service(service, self);
        self.code.push_str("}\n");
    }

    fn visit_service_func(&mut self, func: &'ast ServiceFunc) {
        let mutability = if func.is_query() { "" } else { "mut" };
        let name = func.name().to_case(Case::Snake);

        self.code.push_str("#[allow(clippy::type_complexity)]\n");
        self.code
            .push_str(&format!("fn {}(&{} self,", name, mutability));
        visitor::accept_service_func(func, self);
        self.code.push_str(";\n");
    }

    fn visit_func_param(&mut self, func_param: &'ast FuncParam) {
        let type_decl_code = generate_type_decl_code(func_param.type_decl());
        self.code
            .push_str(&format!("{}: {},", func_param.name(), type_decl_code));
    }

    fn visit_func_output(&mut self, func_output: &'ast TypeDecl) {
        let type_decl_code = generate_type_decl_code(func_output);
        self.code
            .push_str(&format!(") -> impl Call<TCallArgs, {}>", type_decl_code));
    }
}

struct ClientGenerator {
    service_name: String,
    path: String,
    code: String,
}

impl ClientGenerator {
    fn new(service_name: String, path: String) -> Self {
        Self {
            service_name,
            path,
            code: String::new(),
        }
    }
}

impl<'ast> Visitor<'ast> for ClientGenerator {
    fn visit_service(&mut self, service: &'ast Service) {
        let name = &self.service_name;

        self.code.push_str(&format!(
            r#"
            #[derive(Clone)]
            pub struct {name}<R, A> where
                R: Remoting<A>,
                A: Default,
            {{
                remoting: R,
                _phantom: PhantomData<A>,
            }}

            impl<A: Default, R: Remoting<A>> {name}<R, A> {{
                pub fn new(remoting: R) -> Self {{
                    Self {{ remoting, _phantom: PhantomData }}
                }}
            }}

            impl<R, A> traits::{name}<R, A> for {name}<R, A>
            where
                R: Remoting<A> + Clone,
                A: Default,
            {{
        "#
        ));

        visitor::accept_service(service, self);
        self.code.push_str("}\n");
    }

    fn visit_service_func(&mut self, func: &'ast ServiceFunc) {
        let mutability = if func.is_query() { "" } else { "mut" };
        let fn_name = func.name();

        self.code.push_str(&format!(
            "fn {}(&{} self,",
            fn_name.to_case(Case::Snake),
            mutability
        ));

        visitor::accept_service_func(func, self);

        self.code.push_str("{\n");

        let args = encoded_args(func.params());

        let (mut service_path_bytes, _service_path_encoded_length) = path_bytes(&self.path);
        if !service_path_bytes.is_empty() {
            service_path_bytes.push(',')
        }
        let (route_bytes, _route_encoded_length) = method_bytes(fn_name);

        self.code.push_str(&format!(
            "RemotingAction::new(self.remoting.clone(), &[{service_path_bytes} {route_bytes}], {args})"
        ));

        self.code.push_str("}\n");
    }

    fn visit_func_param(&mut self, func_param: &'ast FuncParam) {
        let type_decl_code = generate_type_decl_code(func_param.type_decl());
        self.code
            .push_str(&format!("{}: {},", func_param.name(), type_decl_code));
    }

    fn visit_func_output(&mut self, func_output: &'ast TypeDecl) {
        let type_decl_code = generate_type_decl_code(func_output);
        self.code
            .push_str(&format!(") -> impl Call<A, {}>", type_decl_code));
    }
}

fn encoded_args(params: &[FuncParam]) -> String {
    if params.len() == 1 {
        return params[0].name().to_owned();
    }

    let arg_names = params
        .iter()
        .map(|a| a.name())
        .collect::<Vec<_>>()
        .join(", ");

    format!("({arg_names})")
}

struct TypeGenerator<'a> {
    type_name: &'a str,
    code: String,
}

impl<'a> TypeGenerator<'a> {
    fn new(type_name: &'a str) -> Self {
        Self {
            type_name,
            code: String::new(),
        }
    }
}

impl<'a, 'ast> Visitor<'ast> for TypeGenerator<'a> {
    fn visit_struct_def(&mut self, struct_def: &'ast StructDef) {
        let mut struct_def_generator = StructDefGenerator::new(true);
        struct_def_generator.visit_struct_def(struct_def);

        let semi = if struct_def.fields().iter().all(|f| f.name().is_none()) {
            ";"
        } else {
            ""
        };

        self.code
            .push_str("#[derive(PartialEq, Debug, Encode, Decode)]");
        self.code
            .push_str("#[codec(crate = sails_rtl::scale_codec)]");
        self.code.push_str(&format!(
            "pub struct {} {} {}",
            self.type_name, struct_def_generator.code, semi
        ));
    }

    fn visit_enum_def(&mut self, enum_def: &'ast EnumDef) {
        let mut enum_def_generator = EnumDefGenerator::default();
        enum_def_generator.visit_enum_def(enum_def);

        self.code
            .push_str("#[derive(PartialEq, Debug, Encode, Decode)]");
        self.code
            .push_str("#[codec(crate = sails_rtl::scale_codec)]");
        self.code.push_str(&format!(
            "pub enum {} {}",
            self.type_name, &enum_def_generator.code
        ));
    }
}

#[derive(Default)]
struct StructDefGenerator {
    code: String,
    is_pub: bool,
}

impl StructDefGenerator {
    fn new(is_pub: bool) -> Self {
        Self {
            code: String::new(),
            is_pub,
        }
    }
}

impl<'ast> Visitor<'ast> for StructDefGenerator {
    fn visit_struct_def(&mut self, struct_def: &'ast StructDef) {
        let is_regular_struct = struct_def.fields().iter().all(|f| f.name().is_some());
        let is_tuple_struct = struct_def.fields().iter().all(|f| f.name().is_none());
        if !is_regular_struct && !is_tuple_struct {
            panic!("Struct must be either regular or tuple");
        }
        if is_regular_struct {
            self.code.push('{');
        } else {
            self.code.push('(');
        }
        visitor::accept_struct_def(struct_def, self);
        if is_regular_struct {
            self.code.push('}');
        } else {
            self.code.push(')');
        }
    }

    fn visit_struct_field(&mut self, struct_field: &'ast StructField) {
        let type_decl_code = generate_type_decl_code(struct_field.type_decl());

        let vis = self.is_pub.then_some("pub ").unwrap_or_default();

        if let Some(field_name) = struct_field.name() {
            self.code
                .push_str(&format!("{vis}{field_name}: {type_decl_code},"));
        } else {
            self.code.push_str(&format!("{vis}{type_decl_code},"));
        }
    }
}

#[derive(Default)]
struct EnumDefGenerator {
    code: String,
}

impl<'ast> Visitor<'ast> for EnumDefGenerator {
    fn visit_enum_def(&mut self, enum_def: &'ast EnumDef) {
        self.code.push('{');
        visitor::accept_enum_def(enum_def, self);
        self.code.push('}');
    }

    fn visit_enum_variant(&mut self, enum_variant: &'ast EnumVariant) {
        if let Some(type_decl) = enum_variant.type_decl().as_ref() {
            let type_decl_code = generate_type_decl_code(type_decl);
            if type_decl_code.starts_with('{') {
                self.code
                    .push_str(&format!("{} {},", enum_variant.name(), type_decl_code));
            } else {
                self.code
                    .push_str(&format!("{}({}),", enum_variant.name(), type_decl_code));
            }
        } else {
            self.code.push_str(&format!("{},", enum_variant.name()));
        }
    }
}

fn generate_type_decl_code(type_decl: &TypeDecl) -> String {
    let mut type_decl_generator = TypeDeclGenerator::default();
    visitor::accept_type_decl(type_decl, &mut type_decl_generator);
    type_decl_generator.code
}

#[derive(Default)]
struct TypeDeclGenerator {
    code: String,
}

impl<'ast> Visitor<'ast> for TypeDeclGenerator {
    fn visit_optional_type_decl(&mut self, optional_type_decl: &'ast TypeDecl) {
        self.code.push_str("Option<");
        visitor::accept_type_decl(optional_type_decl, self);
        self.code.push('>');
    }

    fn visit_result_type_decl(
        &mut self,
        ok_type_decl: &'ast TypeDecl,
        err_type_decl: &'ast TypeDecl,
    ) {
        self.code.push_str("Result<");
        visitor::accept_type_decl(ok_type_decl, self);
        self.code.push_str(", ");
        visitor::accept_type_decl(err_type_decl, self);
        self.code.push('>');
    }

    fn visit_vector_type_decl(&mut self, vector_type_decl: &'ast TypeDecl) {
        self.code.push_str("Vec<");
        visitor::accept_type_decl(vector_type_decl, self);
        self.code.push('>');
    }

    fn visit_struct_def(&mut self, struct_def: &'ast StructDef) {
        let mut struct_def_generator = StructDefGenerator::default();
        struct_def_generator.visit_struct_def(struct_def);
        self.code.push_str(&struct_def_generator.code);
    }

    fn visit_primitive_type_id(&mut self, primitive_type_id: PrimitiveType) {
        self.code.push_str(match primitive_type_id {
            PrimitiveType::U8 => "u8",
            PrimitiveType::U16 => "u16",
            PrimitiveType::U32 => "u32",
            PrimitiveType::U64 => "u64",
            PrimitiveType::U128 => "u128",
            PrimitiveType::I8 => "i8",
            PrimitiveType::I16 => "i16",
            PrimitiveType::I32 => "i32",
            PrimitiveType::I64 => "i64",
            PrimitiveType::I128 => "i128",
            PrimitiveType::Bool => "bool",
            PrimitiveType::Str => "String",
            PrimitiveType::Char => "char",
            PrimitiveType::Null => "()",
            PrimitiveType::ActorId => "ActorId",
            PrimitiveType::CodeId => "CodeId",
            PrimitiveType::MessageId => "MessageId",
            PrimitiveType::H256 => "H256",
            PrimitiveType::U256 => "U256",
        });
    }

    fn visit_user_defined_type_id(&mut self, user_defined_type_id: &'ast str) {
        self.code.push_str(user_defined_type_id);
    }

    fn visit_map_type_decl(
        &mut self,
        key_type_decl: &'ast TypeDecl,
        value_type_decl: &'ast TypeDecl,
    ) {
        self.code.push_str("BTreeMap<");
        visitor::accept_type_decl(key_type_decl, self);
        self.code.push_str(", ");
        visitor::accept_type_decl(value_type_decl, self);
        self.code.push('>');
    }

    fn visit_array_type_decl(&mut self, item_type_decl: &'ast TypeDecl, len: u32) {
        self.code.push('[');
        visitor::accept_type_decl(item_type_decl, self);
        self.code.push_str(&format!("; {len}]"));
    }
}

struct CallBuilderGenerator {
    service_name: String,
    path: String,
    code: String,
}

impl CallBuilderGenerator {
    fn new(service_name: String, path: String) -> Self {
        Self {
            service_name,
            path,
            code: String::new(),
        }
    }
}

impl<'ast> Visitor<'ast> for CallBuilderGenerator {
    fn visit_service(&mut self, service: &'ast Service) {
        let name = self.service_name.to_case(Case::Snake);

        self.code.push_str(&format!(
            r#"
            pub mod {name}_calls {{
                use super::*;
        "#
        ));

        visitor::accept_service(service, self);

        self.code.push_str("}\n");
    }

    fn visit_service_func(&mut self, func: &'ast ServiceFunc) {
        let fn_name = func.name();

        self.code.push_str(&format!(
            "
            #[derive(Debug, Encode, Decode)]
            #[codec(crate = sails_rtl::scale_codec)]
            pub struct {}Call(\n
            ",
            fn_name
        ));

        visitor::accept_service_func(func, self);

        self.code.push_str(");\n");

        self.code.push_str(&format!(
            "impl {}Call {{
                #[allow(unused)]
                pub fn encode(&self) -> Vec<u8> {{",
            fn_name
        ));

        let (service_path_bytes, service_path_encoded_length) = path_bytes(&self.path);
        let (route_bytes, route_encoded_length) = method_bytes(fn_name);

        let path_len = service_path_encoded_length + route_encoded_length;

        self.code.push_str(&format!(
            "let mut result = Vec::with_capacity({path_len} + self.encoded_size());",
        ));

        self.code.push_str(&format!(
            "result.extend_from_slice(&[{service_path_bytes}]);"
        ));
        self.code
            .push_str(&format!("result.extend_from_slice(&[{route_bytes}]);"));

        self.code.push_str("self.encode_to(&mut result);");
        self.code.push_str("result \n}");

        self.code.push_str(
            "
            #[allow(unused)]
            pub fn from_bytes(mut bytes: &[u8]) -> Result<Self, sails_rtl::errors::Error> {
            ",
        );

        self.code.push_str(&format!(
            "bytes = &bytes[{service_path_encoded_length}..];\n"
        ));

        self.code.push_str(&format!(
            "if !bytes.starts_with(&[{route_bytes}]) {{
                return Err(sails_rtl::errors::RtlError::ReplyPrefixMismatches.into());
            }}\n",
        ));

        self.code
            .push_str(&format!("bytes = &bytes[{route_encoded_length}..];\n"));

        self.code
            .push_str(&format!("let call = Decode::decode(&mut bytes)?;\n"));

        self.code.push_str(&format!("Ok(call)\n"));

        self.code.push_str("}\n\n");

        let mut decode_reply_gen = DecodeReplyGenerator::new();
        decode_reply_gen.visit_service_func(func);

        self.code.push_str(&decode_reply_gen.code);

        self.code.push_str("}\n");
    }

    fn visit_func_param(&mut self, func_param: &'ast FuncParam) {
        let type_decl_code = generate_type_decl_code(func_param.type_decl());

        self.code.push_str(&format!("pub {},", type_decl_code));
    }
}

pub struct DecodeReplyGenerator {
    code: String,
}

impl DecodeReplyGenerator {
    pub fn new() -> Self {
        Self {
            code: String::new(),
        }
    }
}

impl<'ast> Visitor<'ast> for DecodeReplyGenerator {
    fn visit_service(&mut self, service: &'ast Service) {
        visitor::accept_service(service, self);
    }

    fn visit_service_func(&mut self, func: &'ast ServiceFunc) {
        self.code.push_str(&format!(
            "
            #[allow(unused)]
            pub fn decode_reply(mut reply: &[u8]) -> Result<
            ",
        ));

        visitor::accept_service_func(func, self);

        self.code.push_str(", sails_rtl::errors::Error> {\n");

        self.code.push_str(&format!(
            "let result = Decode::decode(&mut reply).map_err(|e| sails_rtl::errors::Error::Codec(e))?;\n"
        ));

        self.code.push_str("Ok(result)\n");

        self.code.push_str("}\n\n");
    }

    fn visit_func_output(&mut self, func_output: &'ast TypeDecl) {
        let type_decl_code = generate_type_decl_code(func_output);

        self.code.push_str(&type_decl_code);
    }
}

fn path_bytes(path: &str) -> (String, usize) {
    if path.is_empty() {
        (String::new(), 0)
    } else {
        let service_path_bytes = path.encode();
        let service_path_encoded_length = service_path_bytes.len();
        let service_path_bytes = service_path_bytes
            .into_iter()
            .map(|x| x.to_string())
            .collect::<Vec<_>>()
            .join(",");

        (service_path_bytes, service_path_encoded_length)
    }
}

fn method_bytes(fn_name: &str) -> (String, usize) {
    let route_bytes = fn_name.encode();
    let route_encoded_length = route_bytes.len();
    let route_bytes = route_bytes
        .into_iter()
        .map(|x| x.to_string())
        .collect::<Vec<_>>()
        .join(",");

    (route_bytes, route_encoded_length)
}
