use anyhow::Result;
use convert_case::{Case, Casing};
use sails_idlparser::ast::*;
use std::{fmt::Write, path::PathBuf};

pub struct IdlGenerator {
    path: PathBuf,
    w: String,
    pub_fields: bool, // one time modifier before calling
}

impl IdlGenerator {
    pub fn new(path: PathBuf) -> Self {
        Self {
            path,
            w: String::new(),
            pub_fields: false,
        }
    }

    pub fn generate(mut self, idl: Program) -> Result<String> {
        self.write_header()?;

        for t in idl.types() {
            self.write_base_type(t)?;
        }

        self.write_service(idl.service())?;

        Ok(self.result_string())
    }

    fn result_string(self) -> String {
        self.w
    }

    fn write_header(&mut self) -> Result<()> {
        writeln!(
            self.w,
            "// Code generated by sails-client-gen from {}. DO NOT EDIT.",
            self.path.file_name().unwrap().to_string_lossy()
        )?;
        writeln!(self.w, "#![automatically_derived]")?;
        writeln!(self.w, "#![allow(unused)]")?;

        writeln!(self.w, "use parity_scale_codec::{{Encode, Decode}};")?;
        writeln!(self.w, "use sails_client::{{Sender, Call}};")?;
        writeln!(self.w, "use gstd::prelude::*;")?;

        Ok(())
    }

    fn type_def_to_decl(t: &TypeDef) -> TypeDecl {
        match t {
            TypeDef::Struct(def) => TypeDecl::Def(TypeDef::Struct(def.clone())),
            TypeDef::Enum(def) => TypeDecl::Def(TypeDef::Enum(def.clone())),
        }
    }

    fn write_base_type(&mut self, t: &Type) -> Result<()> {
        self.pub_fields = true;
        let formatted = self.format_inner_type(&Self::type_def_to_decl(t.def()))?;

        let type_keyword = match t.def() {
            // TypeDef::TypeName { .. } => "type",
            // TypeDef::Option { .. } => "type",
            // TypeDef::Result { .. } => "type",
            // TypeDef::Vec { .. } => "type",
            // TypeDef::Tuple { .. } => "struct",
            TypeDef::Struct { .. } => "struct",
            TypeDef::Enum { .. } => "enum",
        };

        let semi = match t.def() {
            TypeDef::Struct(def) if struct_has_named_fields(def) => "",
            TypeDef::Enum(_) => "",
            _ => ";",
        };

        let eq = match t.def() {
            TypeDef::Struct { .. } | TypeDef::Enum { .. } => "",
        };

        if matches!(t.def(), TypeDef::Struct { .. } | TypeDef::Enum { .. }) {
            writeln!(self.w, "#[derive(PartialEq, Debug, Encode, Decode)]")?;
        }

        writeln!(
            self.w,
            "pub {} {} {} {} {}",
            type_keyword,
            t.name(),
            eq,
            formatted,
            semi,
        )?;
        Ok(())
    }

    fn write_service(&mut self, s: &Service) -> Result<()> {
        writeln!(
            self.w,
            r#"
                pub trait Service {{
            "#
        )?;

        for m in s.funcs() {
            let signature = self.format_service_method_signature(m)?;
            writeln!(self.w, "{};", signature)?;
        }

        writeln!(self.w, "}}")?;

        for m in s.funcs() {
            writeln!(
                self.w,
                r#"
                #[doc(hidden)]
            "#
            )?;
            let args = args_struct(m);
            self.write_base_type(&args)?;
        }

        writeln!(
            self.w,
            r#"

    #[derive(Default, Clone)]
    pub struct Client {{
        program_id: [u8; 32],
    }}

    impl Client {{
        pub fn new() -> Self {{
            Self::default()
        }}

        pub fn with_program_id(mut self, program_id: impl Into<[u8; 32]>) -> Self {{
            self.program_id = program_id.into();
            self
        }}
    }}


    impl Service for Client {{

    "#
        )?;

        for f in s.funcs() {
            self.format_service_method(f)?;
        }

        writeln!(self.w, "}}")?;

        Ok(())
    }

    fn format_service_method(&mut self, f: &Func) -> Result<()> {
        let signature = self.format_service_method_signature(f)?;

        let arg_names = f
            .params()
            .iter()
            .map(|a| a.name())
            .collect::<Vec<_>>()
            .join(", ");

        let name = f.name();

        writeln!(
            self.w,
            r#"{signature} {{
            let mut payload = Vec::from("{name}/");
            {name}RequestArgs {{ {arg_names} }}.encode_to(&mut payload);

            Call::new(payload)
                .with_program_id(self.program_id)
        }}"#
        )?;

        Ok(())
    }

    fn format_service_method_signature(&mut self, f: &Func) -> Result<String> {
        let args = f
            .params()
            .iter()
            .map(|p| {
                format!(
                    "{}: {}",
                    p.name(),
                    self.format_inner_type(p.type_decl()).unwrap()
                )
            })
            .collect::<Vec<_>>()
            .join(", ");

        let output = self.format_inner_type(f.output()).unwrap();

        let name_snake = f.name().to_case(Case::Snake);

        let signature = format!("fn {name_snake}(&self, {args}) -> Call<{output}>");

        Ok(signature)
    }

    fn format_inner_type(&mut self, t: &TypeDecl) -> Result<String> {
        Ok(match t {
            TypeDecl::Id(TypeId::Primitive(t)) => match t {
                PrimitiveType::Null => "()".to_string(),
                PrimitiveType::Bool => "bool".to_string(),
                PrimitiveType::Char => "char".to_string(),
                PrimitiveType::Str => "String".to_string(),
                PrimitiveType::U8 => "u8".to_string(),
                PrimitiveType::U16 => "u16".to_string(),
                PrimitiveType::U32 => "u32".to_string(),
                PrimitiveType::U64 => "u64".to_string(),
                PrimitiveType::U128 => "u128".to_string(),
                PrimitiveType::I8 => "i8".to_string(),
                PrimitiveType::I16 => "i16".to_string(),
                PrimitiveType::I32 => "i32".to_string(),
                PrimitiveType::I64 => "i64".to_string(),
                PrimitiveType::I128 => "i128".to_string(),
            },
            TypeDecl::Id(TypeId::UserDefined(id)) => id.to_owned(),
            TypeDecl::Optional(inner) => format!("Option<{}>", self.format_inner_type(inner)?),
            TypeDecl::Result { ok, err } => format!(
                "Result<{}, {}>",
                self.format_inner_type(ok)?,
                self.format_inner_type(err)?
            ),
            TypeDecl::Vector(inner) => format!("Vec<{}>", self.format_inner_type(inner)?),
            TypeDecl::Def(TypeDef::Struct(def)) => {
                // named fields
                let mut w = String::new();

                let (open, close) = if struct_has_named_fields(def) {
                    // named fields
                    ("{", "}")
                } else {
                    // tuple fields
                    ("(", ")")
                };

                writeln!(w, "{open}")?;

                let mut vis = "";
                if self.pub_fields {
                    self.pub_fields = false;
                    vis = "pub";
                }

                // for struct with named fields:
                for field in def.fields() {
                    if let TypeDecl::Def(TypeDef::Enum(def)) = field.type_decl() {
                        // enums can't be nested, so write to top level buffer and replace definition with alias
                        let enum_name =
                            format!("{}Variant", field.name().unwrap().to_case(Case::Pascal));

                        let t = Type::new(enum_name.clone(), TypeDef::Enum(def.clone()));

                        self.write_base_type(&t)?;

                        match field.name() {
                            Some(name) => writeln!(w, "{} {}: {},", vis, name, enum_name)?,
                            None => writeln!(w, "{} {},", vis, enum_name)?,
                        }

                        continue;
                    }

                    match field.name() {
                        Some(name) => writeln!(
                            w,
                            "{} {}: {},",
                            vis,
                            name,
                            self.format_inner_type(field.type_decl())?
                        )?,
                        None => {
                            writeln!(w, "{} {},", vis, self.format_inner_type(field.type_decl())?)?
                        }
                    }
                }

                write!(w, "{close}")?;

                w
            }
            TypeDecl::Def(TypeDef::Enum(def)) => {
                let mut w = String::new();
                self.pub_fields = false; // fields can't be public in enums

                writeln!(w, "{{")?;

                for variant in def.variants() {
                    match variant.type_decl() {
                        Some(TypeDecl::Def(TypeDef::Enum(def))) => {
                            // enums can't be nested, so write to top level buffer and replace definition with SimpleTypeDecl
                            let name = format!("{}Variant", variant.name().to_case(Case::Pascal));

                            let t = Type::new(name.clone(), TypeDef::Enum(def.clone()));

                            self.write_base_type(&t)?;

                            writeln!(w, "{}({}),", variant.name(), name)?
                        }
                        Some(TypeDecl::Def(TypeDef::Struct(def))) => writeln!(
                            w,
                            "{}{},",
                            variant.name(),
                            self.format_inner_type(&TypeDecl::Def(TypeDef::Struct(def.clone())))?
                        )?,
                        Some(tt) => {
                            writeln!(w, "{}({}),", variant.name(), self.format_inner_type(tt)?)?
                        }
                        None => writeln!(w, "{},", variant.name())?,
                    }
                }

                write!(w, "}}")?;

                w
            }
        })
    }
}

// todo: move this to a method inside idlparser?
fn struct_has_named_fields(def: &StructDef) -> bool {
    def.fields()
        .first()
        .map(|f| f.name().is_some())
        .unwrap_or(true)
}

/// constructs a struct with named fields for the arguments of a function
fn args_struct(f: &Func) -> Type {
    let name = format!("{}RequestArgs", f.name().to_case(Case::Pascal));

    let fields = f
        .params()
        .iter()
        .map(|arg| {
            return StructField::new(Some(arg.name().to_owned()), arg.type_decl().clone());
        })
        .collect::<Vec<_>>();

    Type::new(name, TypeDef::Struct(StructDef::new(fields)))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nested_enum() {
        let idl = r#"
        type ThisThatAppManyVariants = enum {
            One,
            Two: enum {
                Three,
                Four,
            },
        };

        service {}
        "#;

        let program = sails_idlparser::ast::parse_idl(idl).expect("parse IDL");
        let generator = IdlGenerator::new(PathBuf::from("test"));

        insta::assert_snapshot!(generator.generate(program).unwrap());
    }

    #[test]
    fn nested_enum_in_struct() {
        let idl = r#"
        type ThisThatAppDoThatParam = struct {
            p2: str,
            p3: enum {
                One,
                Two,
            },
        };

        service {}
        "#;

        let program = sails_idlparser::ast::parse_idl(idl).expect("parse IDL");
        let generator = IdlGenerator::new(PathBuf::from("test"));

        insta::assert_snapshot!(generator.generate(program).unwrap());
    }
}
