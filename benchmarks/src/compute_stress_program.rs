// Code generated by sails-client-gen. DO NOT EDIT.
use sails_rs::{client::*, prelude::*};
pub struct ComputeStressProgramProgram;
impl Program for ComputeStressProgramProgram {}
pub trait ComputeStressProgram {
    type Env: GearEnv;
    fn compute_stress(&self) -> Service<Self::Env, compute_stress::ComputeStressImpl>;
}
impl<E: GearEnv> ComputeStressProgram for Actor<E, ComputeStressProgramProgram> {
    type Env = E;
    fn compute_stress(&self) -> Service<Self::Env, compute_stress::ComputeStressImpl> {
        self.service(stringify!(ComputeStress))
    }
}
pub trait ComputeStressProgramCtors {
    type Env: GearEnv;
    fn new_for_bench(self) -> PendingCtor<Self::Env, ComputeStressProgramProgram, io::NewForBench>;
}
impl<E: GearEnv> ComputeStressProgramCtors for Deployment<E, ComputeStressProgramProgram> {
    type Env = E;
    fn new_for_bench(self) -> PendingCtor<Self::Env, ComputeStressProgramProgram, io::NewForBench> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(NewForBench () -> ());
}

pub mod compute_stress {
    use super::*;
    pub trait ComputeStress {
        type Env: GearEnv;
        fn compute_stress(&mut self, n: u32) -> PendingCall<Self::Env, io::ComputeStress>;
    }
    pub struct ComputeStressImpl;
    impl<E: GearEnv> ComputeStress for Service<E, ComputeStressImpl> {
        type Env = E;
        fn compute_stress(&mut self, n: u32) -> PendingCall<Self::Env, io::ComputeStress> {
            self.pending_call((n,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(ComputeStress (n: u32) -> ComputeStressResult);
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ComputeStressResult {
    pub res: u32,
}
