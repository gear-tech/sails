//! Build-time helpers for generating canonical interface constants.
//!
//! The main entry point is [`emit_interface_consts`], which build scripts can
//! call to capture the canonical interface metadata for a given service. The
//! helper spawns a host-only `cargo run --bin sails_meta_dump` process (which
//! must exist in the target crate), parses the emitted JSON, and writes
//! `sails_interface_consts.rs` into `OUT_DIR`. That file is intended to be
//! `include!`-d by the `#[service]` macro when the `sails-canonical` feature is
//! enabled.

use std::{
    env, fs,
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{Context, Result, bail};
use serde::Deserialize;
use serde_bytes::ByteBuf;

const CONSTS_FILENAME: &str = "sails_interface_consts.rs";
const DUMP_ENV_GUARD: &str = "SAILS_CANONICAL_DUMP";

/// Emit canonical interface constants for the provided service using the
/// default Sails crate path (`sails_rs`).
pub fn emit_interface_consts(service_path: &str, out_dir: impl AsRef<Path>) -> Result<()> {
    emit_interface_consts_with_sails_path(service_path, "sails_rs", out_dir)
}

/// Same as [`emit_interface_consts`], but allows callers to override the path
/// used to reference the `sails-rs` crate (for crates that pass a custom
/// `crate = ...` argument to the `#[service]` macro).
pub fn emit_interface_consts_with_sails_path(
    service_path: &str,
    sails_crate_path: &str,
    out_dir: impl AsRef<Path>,
) -> Result<()> {
    if env::var_os(DUMP_ENV_GUARD).is_some() {
        // The meta-dump binary builds the service crate as well; make sure we
        // do not recursively invoke ourselves in that scenario.
        return Ok(());
    }

    let manifest_dir = PathBuf::from(
        env::var("CARGO_MANIFEST_DIR")
            .context("CARGO_MANIFEST_DIR is not set in the environment")?,
    );
    let artifacts = run_meta_dump(service_path, &manifest_dir)?;
    let rendered = render_consts(&artifacts, sails_crate_path);
    write_if_changed(out_dir.as_ref(), CONSTS_FILENAME, rendered.as_bytes())
}

fn run_meta_dump(service_path: &str, manifest_dir: &Path) -> Result<MetaDumpArtifacts> {
    let cargo = env::var("CARGO").unwrap_or_else(|_| "cargo".to_string());
    let mut cmd = Command::new(cargo);
    cmd.current_dir(manifest_dir);
    cmd.arg("run");
    if let Ok(host_target) = env::var("HOST") {
        if !host_target.is_empty() {
            cmd.arg("--target").arg(host_target);
        }
    }
    cmd.args([
        "--bin",
        "sails_meta_dump",
        "--quiet",
        "--",
        "--service",
        service_path,
    ]);
    cmd.env(DUMP_ENV_GUARD, "1");

    let output = cmd
        .output()
        .context("failed to execute sails_meta_dump helper")?;
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("sails_meta_dump failed: {stderr}");
    }

    serde_json::from_slice(&output.stdout).context("failed to parse sails_meta_dump output")
}

fn render_consts(artifacts: &MetaDumpArtifacts, sails_crate_path: &str) -> String {
    let mut buf = String::new();
    buf.push_str("// @generated by sails-build. DO NOT EDIT.\n");
    buf.push_str(&format!(
        "use {path}::meta::{{EntryKind, EntryMeta}};\n\n",
        path = sails_crate_path
    ));
    buf.push_str(&format!(
        "pub const INTERFACE_ID: u64 = {interface_id:#018x};\n\n",
        interface_id = artifacts.interface_id,
    ));
    buf.push_str("pub const ENTRY_META: &[EntryMeta<'static>] = &[\n");
    for entry in &artifacts.entry_meta {
        buf.push_str("    EntryMeta::borrowed(");
        buf.push_str(&format!(
            "{name:?}, {entry_id}u16, EntryKind::{kind}, {is_async}),\n",
            name = entry.name,
            entry_id = entry.entry_id,
            kind = entry.kind.as_variant(),
            is_async = entry.is_async,
        ));
    }
    buf.push_str("];\n\n");
    buf.push_str("pub const CANONICAL_INTERFACE_JSON: &[u8] = &[\n");
    buf.push_str(&format_byte_array(artifacts.canonical_json.as_ref()));
    buf.push_str("];\n");
    buf
}

fn format_byte_array(bytes: &[u8]) -> String {
    if bytes.is_empty() {
        return String::new();
    }

    const PER_LINE: usize = 12;
    let mut buf = String::new();
    for (idx, byte) in bytes.iter().enumerate() {
        if idx % PER_LINE == 0 {
            buf.push_str("    ");
        }
        buf.push_str(&format!("0x{byte:02X}, "));
        if idx % PER_LINE == PER_LINE - 1 {
            buf.push('\n');
        }
    }
    if bytes.len() % PER_LINE != 0 {
        buf.push('\n');
    }
    buf
}

fn write_if_changed(dir: &Path, filename: &str, contents: &[u8]) -> Result<()> {
    fs::create_dir_all(dir).with_context(|| format!("failed to create {dir:?}"))?;
    let path = dir.join(filename);
    let should_write = match fs::read(&path) {
        Ok(existing) => existing != contents,
        Err(_) => true,
    };
    if should_write {
        fs::write(&path, contents)
            .with_context(|| format!("failed to write generated constants to {path:?}"))?;
    }
    Ok(())
}

#[derive(Debug, Deserialize)]
struct MetaDumpArtifacts {
    interface_id: u64,
    #[serde(with = "serde_bytes")]
    canonical_json: ByteBuf,
    entry_meta: Vec<MetaDumpEntry>,
}

#[derive(Debug, Deserialize)]
struct MetaDumpEntry {
    name: String,
    entry_id: u16,
    kind: DumpEntryKind,
    is_async: bool,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum DumpEntryKind {
    Command,
    Query,
    Event,
}

impl DumpEntryKind {
    fn as_variant(&self) -> &'static str {
        match self {
            DumpEntryKind::Command => "Command",
            DumpEntryKind::Query => "Query",
            DumpEntryKind::Event => "Event",
        }
    }
}
