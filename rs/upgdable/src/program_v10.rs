#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(unused_macros)]

use super::*;
use sails_rs::collections::BTreeMap;

//#[service_state]
struct Service1State {
    a: u32,
    b: SomeStruct,
    c: Vec<u16>,
    d: BTreeMap<u32, String>,
}

// Generated for `Service1State`
impl<TMigration> Migratable<TMigration> for Service1State
where
    TMigration: Migration<u32>,
    TMigration: Migration<SomeStruct>,
    TMigration: Migration<Vec<u16>>,
    TMigration: Migration<BTreeMap<u32, String>>,
{
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration) {
        <u32 as Migratable<TMigration>>::migrate(source, &format!("{}/a", name), migration);
        <SomeStruct as Migratable<TMigration>>::migrate(source, &format!("{}/b", name), migration);
        <Vec<u16> as Migratable<TMigration>>::migrate(source, &format!("{}/c", name), migration);
        <BTreeMap<u32, String> as Migratable<TMigration>>::migrate(
            source,
            &format!("{}/d", name),
            migration,
        );
    }
}

//#[derive(Migratable)]
#[derive(Decode)]
#[codec(crate = sails_rs::scale_codec)]
struct SomeStruct {
    f1: u32,
    f2: Vec<String>,
}

struct MigrationImpl;

impl Migration<u32> for MigrationImpl {
    fn adopt(&mut self, name: &str, document: &u32) {}
}

impl Migration<SomeStruct> for MigrationImpl {
    fn adopt(&mut self, name: &str, document: &SomeStruct) {}
}

impl Migration<Vec<u16>> for MigrationImpl {
    fn adopt(&mut self, name: &str, document: &Vec<u16>) {}
}

impl Migration<BTreeMap<u32, String>> for MigrationImpl {
    fn adopt(&mut self, name: &str, document: &BTreeMap<u32, String>) {}
}

impl Migration<Vec<String>> for MigrationImpl {
    fn adopt(&mut self, name: &str, document: &Vec<String>) {}
}

//#[program_state(MigrationImpl)]
struct ProgrmaState {
    svc1_state: Service1State,
    svc2_state: u32,
    svc3_state: Vec<String>,
    svc4_state: SomeStruct,
}

// Generate by `program_state(MigrationImpl)` attribute
fn do_migration(source: ActorId) {
    let mut migration = MigrationImpl;
    <Service1State as Migratable<_>>::migrate(source, "svc1_state", &mut migration);
    <u32 as Migratable<_>>::migrate(source, "svc2_state", &mut migration);
    <Vec<String> as Migratable<_>>::migrate(source, "svc3_state", &mut migration);
    <SomeStruct as Migratable<_>>::migrate(source, "svc4_state", &mut migration);
}

// Generated by the `derive(Migratable)` attribute
impl<TMigration> Migratable<TMigration> for SomeStruct
where
    TMigration: Migration<SomeStruct>,
{
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration) {
        let document = read_document::<SomeStruct>(source, name);
        migration.adopt(name, &document);
    }
}

////////////////////////////////////////////////////////////////////////
trait Migratable<TMigration> {
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration);
}

impl<TMigration> Migratable<TMigration> for u32
where
    TMigration: Migration<u32>,
{
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration) {
        let document = read_document::<u32>(source, name);
        migration.adopt(name, &document);
    }
}

impl<TMigration, T> Migratable<TMigration> for Vec<T>
where
    T: Decode,
    TMigration: Migration<Vec<T>>,
{
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration) {
        let documents = read_document::<Vec<T>>(source, name);
        // while
        //
        //
        migration.adopt(name, &documents);
    }
}

impl<TMigration, K, V> Migratable<TMigration> for BTreeMap<K, V>
where
    K: Decode + Ord,
    V: Decode,
    TMigration: Migration<BTreeMap<K, V>>,
{
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration) {
        let documents = read_document::<BTreeMap<K, V>>(source, name);
        // while
        //   read by chunks
        //   migration.adopt(name, &chunk);
        //
        migration.adopt(name, &documents);
    }
}

fn read_document<T>(actor_id: ActorId, _name: &str) -> T
where
    T: Decode,
{
    let document_bytes: Vec<u8> = vec![]; // read bytes from another contract
    T::decode(&mut &document_bytes[..]).unwrap()
}

trait Migration<T> {
    fn adopt(&mut self, name: &str, document: &T);
}
