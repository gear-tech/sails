#![allow(dead_code)]
#![allow(unused_variables)]
use super::*;

#[derive(Default)]
struct MyMigration(());

impl DocumentMigration<SomeItem> for MyMigration {
    fn extend(&mut self, name: &str, document: &SomeItem) {
        panic!("Unknown field name");
    }
}

impl DocumentMigration<u32> for MyMigration {
    fn extend(&mut self, name: &str, document: &u32) {
        panic!("Unknown field name");
    }
}

impl DocumentMigration<Service2State> for MyMigration {
    fn extend(&mut self, name: &str, document: &Service2State) {
        panic!("Unknown field name");
    }
}

//#[state(full)]
#[derive(Decode)]
#[codec(crate = sails_rs::scale_codec)]
struct SomeItem {
    a: u32,
    b: String,
}

// Generated by the `state(full)` attribute
// `full` means that we read the entire state at once
impl<TMigration> SomeTrait<TMigration> for SomeItem
where
    TMigration: DocumentMigration<SomeItem>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        let doc = read_document::<SomeItem>(source_actor_id, name);
        <TMigration as DocumentMigration<SomeItem>>::extend(migration, name, &doc);
    }
}

//#[state]
struct Service1State {
    f1: u32,
    f2: SomeItem,
    f3: Vec<SomeItem>,
    f4: Vec<SomeItem>,
}

// Generated by the `state(parts)` attribute
// `parts` means that we read the state in parts
impl<TMigration> SomeTrait<TMigration> for Service1State
where
    TMigration: DocumentMigration<u32>,
    TMigration: DocumentMigration<SomeItem>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        <u32 as SomeTrait<TMigration>>::migrate(
            source_actor_id,
            &format!("{}/f1", name),
            migration,
        );
        <SomeItem as SomeTrait<TMigration>>::migrate(
            source_actor_id,
            &format!("{}/f2", name),
            migration,
        );
    }
}

//#[state(full)]
#[derive(Decode)]
#[codec(crate = sails_rs::scale_codec)]
struct Service2State {
    v: String,
}

// Generated by the `state(full)` attribute
impl<TMigration> SomeTrait<TMigration> for Service2State
where
    TMigration: DocumentMigration<Service2State>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        let doc = read_document::<Service2State>(source_actor_id, name);
        <TMigration as DocumentMigration<Service2State>>::extend(migration, name, &doc);
    }
}

//#[state(MyMigration)]
struct MyProgramState {
    //#[nested]
    service1: Service1State,
    //#[nested]
    service2: Service2State,
}

// Generated by the `state(MyMigration)` attribute
impl SomeTrait<MyMigration> for MyProgramState {
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut MyMigration) {
        <Service1State as SomeTrait<MyMigration>>::migrate(
            source_actor_id,
            &format!("{}/service1", name),
            migration,
        );
        <Service2State as SomeTrait<MyMigration>>::migrate(
            source_actor_id,
            &format!("{}/service2", name),
            migration,
        );
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//#[state]
pub struct Svc1State {
    doc1: String,
    items: Vec<u16>,
}

//#[state]
pub struct Svc2State {
    item: Item,
}

//#[state]
#[derive(Decode)]
#[codec(crate = sails_rs::scale_codec)]
pub struct Item {
    id: u16,
    name: String,
}

//#[state(MigrationImpl)]
pub struct ProgramState {
    //#[nested]
    svc1: Svc1State,
    //#[nested]
    svc2: Svc2State,
}

#[derive(Default)]
pub struct MigrationImpl(());

impl DocumentMigration<String> for MigrationImpl {
    fn extend(&mut self, name: &str, document: &String) {
        if name != "svc1/doc1" {
            panic!("Unknown field name");
        }
    }
}

impl DocumentMigration<Vec<u16>> for MigrationImpl {
    fn extend(&mut self, name: &str, document: &Vec<u16>) {
        if name != "svc1/items" {
            panic!("Unknown field name");
        }
    }
}

// svc1 -> doc1
// svc1 -> items -> [0]

pub fn migrate() {
    let mut migration = MigrationImpl::default();
    let source_actor_id = ActorId::zero();
    <Svc1State as SomeTrait<MigrationImpl>>::migrate(source_actor_id, "svc1", &mut migration);
    <Svc2State as SomeTrait<MigrationImpl>>::migrate(source_actor_id, "svc2", &mut migration);
}

trait SomeTrait<TMigration> {
    fn migrate(source: ActorId, name: &str, migration: &mut TMigration);
}

impl<TMigration> SomeTrait<TMigration> for Svc1State
where
    TMigration: DocumentMigration<String>,
    TMigration: DocumentMigration<Vec<u16>>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        <String as SomeTrait<TMigration>>::migrate(
            source_actor_id,
            &format!("{}/doc1", name),
            migration,
        );
        <Vec<u16> as SomeTrait<TMigration>>::migrate(
            source_actor_id,
            &format!("{}/items", name),
            migration,
        );
    }
}

impl<TMigration> SomeTrait<TMigration> for Svc2State
// where
//     TMigration: DocumentMigration<Item>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        <Item as SomeTrait<TMigration>>::migrate(
            source_actor_id,
            &format!("{}/item", name),
            migration,
        );
    }
}

impl<TMigration> SomeTrait<TMigration> for String
where
    TMigration: DocumentMigration<String>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        let doc = read_document::<String>(source_actor_id, name);
        <TMigration as DocumentMigration<String>>::extend(migration, name, &doc);
    }
}

impl<TMigration, TItem> SomeTrait<TMigration> for Vec<TItem>
where
    TItem: Decode,
    TMigration: DocumentMigration<Vec<TItem>>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        let doc = read_document::<Vec<TItem>>(source_actor_id, name);
        <TMigration as DocumentMigration<Vec<TItem>>>::extend(migration, name, &doc);
    }
}

impl<TMigration> SomeTrait<TMigration> for Item {
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        let doc = read_document::<Item>(source_actor_id, name);
        //<TMigration as DocumentMigration<Item>>::extend(migration, name, &doc);
    }
}

fn read_document<T>(actor_id: ActorId, _name: &str) -> T
where
    T: Decode,
{
    let document_bytes: Vec<u8> = vec![]; // read bytes from another contract
    T::decode(&mut &document_bytes[..]).unwrap()
}

trait DocumentMigration<T> {
    fn extend(&mut self, name: &str, document: &T);
}

impl<TMigration> SomeTrait<TMigration> for u32
where
    TMigration: DocumentMigration<u32>,
{
    fn migrate(source_actor_id: ActorId, name: &str, migration: &mut TMigration) {
        let doc = read_document::<u32>(source_actor_id, name);
        <TMigration as DocumentMigration<u32>>::extend(migration, name, &doc);
    }
}
