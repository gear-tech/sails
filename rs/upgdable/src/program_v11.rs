#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_imports)]
#![allow(unused_macros)]

use super::*;
use sails_rs::collections::BTreeMap;
extern crate std;
use std::println;

// Dead-end situation to avoid:
// - marked up the original code in hope the new code will cope with it
// - the new code is not able to cope with the original code, data is too big and requires further chunking

//#[composite_state]
#[derive(Default)] // for testing purposes
#[derive(Decode)]
#[codec(crate = sails_rs::scale_codec)]
struct SomeStruct {
    f1: u32,
    //#[chunked_state]
    f2: Vec<String>, // It can be chunnked when referenced from `svc4_state/f2`, but it can't be chunked when referenced from `svc1_state/b/f2`. Can we diagnose this? Can we use path depth for this? In Runtime only :-(
}

// Generated by #[chunked_state] (or can be implemented manually, but it will require manual implementation in the source program as well)
impl<TMigration> Migratable<TMigration> for SomeStruct
where
    TMigration: Migration<u32>, // all fields of a struct marked with a `chunked_state` attribute contribute to such constraints
    TMigration: Migration<Vec<String>>, // all fields of a struct marked with a `chunked_state` attribute contribute to such constraints
{
    fn migrate(source: ActorId, path: &str, migration: &mut TMigration) {
        // We use simple `Decode` trait because `f1` is not marked with #[chunked_state]
        {
            let path = format!("{}/f1", path);
            let f1 = read_document::<u32>(source, &path);
            migration.adopt(&path, &f1);
        }

        // We use simple `Decode` trait because `f2` is not marked with #[chunked_state]
        {
            let path = format!("{}/f2", path);
            let f2 = read_document::<Vec<String>>(source, &path);
            migration.adopt(&path, &f2);
        }
    }
}

//#[composite_state]
struct Service1State {
    a: u32,
    //#[composite_state(types = [u32, Vec<String>])]
    b: SomeStruct, // #[chunked_state[u32, Vec<String>]]??, i.e. list all types of fields from `SomeStruct` which are not marked with `#[chunked_state]`.
    //#[chunked_state]
    c: Vec<u16>,
    //#[chunked_state]
    d: BTreeMap<u32, String>,
}

// Generated by #[chunked_state] (or can be implemented manually, but it will require manual implementation in the source program as well)
impl<TMigration> Migratable<TMigration> for Service1State
where
    TMigration: Migration<u32>, // all fields of a struct marked with a `chunked_state` attribute contribute to such constraints
    //TMigration: Migration<SomeStruct>, // all fields of a struct marked with a `chunked_state` attribute contribute to such constraints
    TMigration: Migration<u32>, // marked as chunked_state and a list of types comprising the actual leaves to be migrated
    TMigration: Migration<Vec<String>>, // marked as chunked_state and a list of types comprising the actual leaves to be migrated
    TMigration: Migration<Vec<u16>>, // all fields of a struct marked with a `chunked_state` attribute contribute to such constraints
    TMigration: Migration<BTreeMap<u32, String>>, // all fields of a struct marked with a `chunked_state` attribute contribute to such constraints
{
    fn migrate(source: ActorId, path: &str, migration: &mut TMigration) {
        // We use simple `Decode` trait because `a` is not marked with #[chunked_state]
        {
            let path = format!("{}/a", path);
            let a = read_document::<u32>(source, &path);
            migration.adopt(&path, &a);
        }

        // // We use simple `Decode` trait because `b` is not marked with #[chunked_state]
        // {
        //     let path = format!("{}/b", path);
        //     let b = read_document::<SomeStruct>(source, &path);
        //     migration.adopt(&path, &b);
        // }
        // We use the Migratable trait because `b` is marked with #[chunked_state]
        {
            let path = format!("{}/b", path);
            <SomeStruct as Migratable<TMigration>>::migrate(source, &path, migration);
        }

        // We use the Migratable trait because `c` is marked with #[chunked_state]
        {
            let path = format!("{}/c", path);
            <Vec<u16> as Migratable<TMigration>>::migrate(source, &path, migration);
        }

        // We use the Migratable trait because `d` is marked with #[chunked_state]
        {
            let path = format!("{}/d", path);
            <BTreeMap<u32, String> as Migratable<TMigration>>::migrate(source, &path, migration);
        }
    }
}

//#[source_program_state(MigrationImpl)]
struct ProgramState {
    //#[composite_state]
    svc1_state: Service1State,
    svc2_state: u32,
    svc3_state: Vec<String>,
    //#[composite_state]
    svc4_state: SomeStruct,
    //#[chunked_state(chunk_size = 10)]  Do we want to have different attribute for collections so we can specify chunk size in a non-confusing way?
    // Like #[collection_state(chunk_size = 10)]. Otherwise specifying something like #[chunked_state(chunk_size = 10)] svc1_state: Service1State might be confusing
    svc5_state: Vec<SomeStruct>,
}

// Generated by #[source_program_state(MigrationImpl)]
pub(crate) fn migrate(source: ActorId, migration: &mut MigrationImpl) {
    // We use the Migratable trait because `svc1_state` is marked with #[chunked_state]
    let path = "svc1_state";
    <Service1State as Migratable<MigrationImpl>>::migrate(source, path, migration);

    // We use simple `Decode` trait because `svc2_state` is not marked with #[chunked_state]
    let path = "svc2_state";
    let svc2_state = read_document::<u32>(source, path);
    <MigrationImpl as Migration<u32>>::adopt(migration, path, &svc2_state);

    // We use simple `Decode` trait because `svc3_state` is not marked with #[chunked_state]
    let path = "svc3_state";
    let svc3_state = read_document::<Vec<String>>(source, path);
    <MigrationImpl as Migration<Vec<String>>>::adopt(migration, path, &svc3_state);

    // We use the Migratable trait because `svc4_state` is marked with #[chunked_state]
    let path = "svc4_state";
    <SomeStruct as Migratable<MigrationImpl>>::migrate(source, path, migration);

    // We use the Migratable trait because `svc5_state` is marked with #[chunked_state]
    let path = "svc5_state";
    <Vec<SomeStruct> as Migratable<MigrationImpl>>::migrate(source, path, migration);

    // finalize

    // assume_init
}

pub struct MigrationImpl;

impl Migration<u32> for MigrationImpl {
    fn adopt(&mut self, path: &str, document: &u32) {
        if path == "svc2_state" {
            println!("ADOPT: u32 at path: {}", path);
        } else if path == "svc1_state/a" {
            println!("ADOPT: u32 at path: {}", path);
        } else if path == "svc4_state/f1" {
            println!("ADOPT: u32 at path: {}", path);
        } else {
            panic!("Unexpected path '{}' while adopting u32", path);
        }
    }
}

impl Migration<Vec<String>> for MigrationImpl {
    fn adopt(&mut self, path: &str, document: &Vec<String>) {
        if path == "svc3_state" {
            println!("ADOPT: Vec<String> at path: {}", path);
        } else if path == "svc4_state/f2" {
            println!("ADOPT: Vec<String> at path: {}", path);
        } else {
            panic!("Unexpected path '{}' while adopting Vec<String>", path);
        }
    }
}

impl Migration<SomeStruct> for MigrationImpl {
    fn adopt(&mut self, path: &str, document: &SomeStruct) {
        if path == "svc4_state" {
            println!("ADOPT: SomeStruct at path: {}", path);
        }
        if path == "svc1_state/b" {
            println!("ADOPT: SomeStruct at path: {}", path);
        } else {
            panic!("Unexpected path '{}' while adopting SomeStruct", path);
        }
    }
}

impl Migration<Vec<u16>> for MigrationImpl {
    fn adopt(&mut self, path: &str, document: &Vec<u16>) {
        if path == "svc1_state/c" {
            println!("ADOPT: Vec<u16> at path: {}", path);
        } else {
            panic!("Unexpected path '{}' while adopting Vec<u16>", path);
        }
    }
}

impl Migration<BTreeMap<u32, String>> for MigrationImpl {
    fn adopt(&mut self, path: &str, document: &BTreeMap<u32, String>) {
        if path == "svc1_state/d" {
            println!("ADOPT: BTreeMap<u32, String> at path: {}", path);
        } else {
            panic!(
                "Unexpected path '{}' while adopting BTreeMap<u32, String>",
                path
            );
        }
    }
}

impl Migratable<MigrationImpl> for Vec<SomeStruct> {
    // What if Vec<SomeStruct> is used somewhere else (different path) and be migrated using default impl? Differentiate by path?
    // Such custom implementation will require custom implementaion in the source program
    fn migrate(source: ActorId, path: &str, migration: &mut MigrationImpl) {
        read_document::<u32>(source, &format!("{path}/0/f1"));
        read_document::<u32>(source, &format!("{path}/0/f2"));
        println!(
            "Custom impl of Migratable<Vec<SomeStruct>> for path: {}",
            path
        );
    }
}

////////////////////////////////////////////////////////////////////////
trait Migratable<TMigration> {
    fn migrate(source: ActorId, path: &str, migration: &mut TMigration);
}

impl<TMigration, T> Migratable<TMigration> for Vec<T>
where
    T: Decode,
    TMigration: Migration<Vec<T>>,
{
    fn migrate(source: ActorId, path: &str, migration: &mut TMigration) {
        let documents = read_document::<Vec<T>>(source, path);
        // while
        //
        //
        migration.adopt(path, &documents);
        migration.adopt(path, &documents);
        migration.adopt(path, &documents);
    }
}

impl<TMigration, K, V> Migratable<TMigration> for BTreeMap<K, V>
where
    K: Decode + Ord,
    V: Decode,
    TMigration: Migration<BTreeMap<K, V>>,
{
    fn migrate(source: ActorId, path: &str, migration: &mut TMigration) {
        let documents = read_document::<Vec<(K, V)>>(source, path);
        // while
        //   read by chunks. How to propagate chunk size from attribute?
        //   let chunk = read_document::<BTreeMap<K, V>>(source, name, chunk_offset, chunk_size);
        //   migration.adopt(name, &chunk);
        //
        let documents = documents.into_iter().collect::<BTreeMap<K, V>>();
        migration.adopt(path, &documents);
        migration.adopt(path, &documents);
    }
}

trait Migration<T> {
    // Will we get more allocations if we pass &[str] instead of concatenating &str?
    fn adopt(&mut self, path: &str, document: &T);
}

fn read_document<T>(actor_id: ActorId, path: &str) -> T
where
    T: Decode,
    T: Default, // for testing purposes, can be removed if read_document is implemented via trait
{
    // let document_bytes: Vec<u8> = vec![]; // read bytes from another contract
    // T::decode(&mut &document_bytes[..]).unwrap()
    T::default()
}
