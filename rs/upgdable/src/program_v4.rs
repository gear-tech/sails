use super::*;
use cell::{Ref, RefCell, RefMut};
use ops::Deref;
use sails_rs::gstd::{ExecContext, GStdExecContext};

#[derive(Encode, Decode)]
#[codec(crate = sails_rs::scale_codec)]
struct ProgramStateV3 {
    pub data_lo: u16,
    pub data_hi: u16,
}

#[derive(Encode, Decode)]
#[codec(crate = sails_rs::scale_codec)]
struct ProgramStateV4 {
    pub data: u32,
}

struct UpgradableProgramV4(());

//#[program(State = ProgramStateV4, Upgrade = ProgramStateV3)]
//#[program(Upgrade = ProgramStateV3)] This declares the program implements the UpgradableProgram trait
impl UpgradableProgramV4 {
    // In theory we can find out state type from the ctor signature:
    // - method doesn't take &self, maybe not needed
    // - method returns tuple from 2 items, first is Self
    // Another option is specify state type explicitly in the attribute
    pub fn new(p1: u32) -> (Self, ProgramStateV4) {
        (Self(()), ProgramStateV4 { data: p1 })
    }

    pub fn service(this: &<Self as ProgramSelf>::Type) -> UpgradableService {
        let _storage = this.state();
        this.service_ctor()
    }

    fn service_ctor(&self) -> UpgradableService {
        UpgradableService::new()
    }
}

impl UpgradableProgram for UpgradableProgramV4 {
    type PrevStateType = ProgramStateV3;
    type StateType = ProgramStateV4;

    fn upgrade_from(prev_state: ProgramStateV3) -> (Self, ProgramStateV4) {
        (
            Self(()),
            ProgramStateV4 {
                data: (prev_state.data_lo as u32) << 16 | prev_state.data_hi as u32,
            },
        )
    }
}

// Write pseudo code for init/handle taking account of the storage and possible upgrade
pub async fn init() {
    let payload = vec![];
    let mut payload_ptr: &[u8] = &payload[..];

    let prev_program_id: Option<ActorId> = Option::<ActorId>::decode(&mut payload_ptr).unwrap();
    let (program, state) = if let Some(prev_program_id) = prev_program_id {
        pause_program(prev_program_id).await; // How to unpause if upgrade fails? Just handle errors during the process?
        let prev_state_bytes = read_program_state_bytes(prev_program_id).await;
        let prev_state = ProgramStateV3::decode(&mut &prev_state_bytes[..]).unwrap();
        <UpgradableProgramV4 as UpgradableProgram>::upgrade_from(prev_state)
    } else {
        let p1 = u32::decode(&mut payload_ptr).unwrap();
        UpgradableProgramV4::new(p1)
    };

    let wrapper = UpgradableProgramV4Wrapper {
        proxy: sails_rs::gstd::msg::source(),
        program,
        state: RefCell::new(state),
        is_paused: false,
    };
    unsafe {
        __PROGRAM = Some(wrapper);
    }
}

pub fn handle() {
    let payload = vec![];
    let mut payload_ptr: &[u8] = &payload[..];

    let program = unsafe { __PROGRAM.as_ref().unwrap() };

    if program.is_paused {
        panic!("Program is out of service");
    }

    // Distinguish between internal (pause, read_state_bytes) and public calls

    let mut service = UpgradableProgramV4::service(program);
    service.do_something();
}

// Generated by macros
impl ProgramSelf for UpgradableProgramV4 {
    type Type = UpgradableProgramV4Wrapper;
}

// Generated by macros
static mut __PROGRAM: Option<UpgradableProgramV4Wrapper> = None;

// Generated by macros
struct UpgradableProgramV4Wrapper {
    proxy: ActorId, // Used for authorizing all incoming calls
    program: UpgradableProgramV4,
    state: RefCell<ProgramStateV4>,
    is_paused: bool, // Used for upgrade
}

// Generated by macros (could be some trait implementation)
impl UpgradableProgramV4Wrapper {
    pub fn state(&self) -> Ref<'_, ProgramStateV4> {
        self.state.borrow()
    }

    pub fn state_mut(&self) -> RefMut<'_, ProgramStateV4> {
        self.state.borrow_mut()
    }

    // Could be part of the Program struct
    pub fn exec_context(&self) -> impl ExecContext {
        GStdExecContext::default()
    }
}

// Generated by macros
impl Deref for UpgradableProgramV4Wrapper {
    type Target = UpgradableProgramV4;

    fn deref(&self) -> &Self::Target {
        &self.program
    }
}

// Comes from `sails-rs`
pub trait ProgramSelf {
    type Type: Deref<Target = Self>;
}

// Comes from `sails-rs`
pub trait UpgradableProgram {
    type PrevStateType: Decode;
    type StateType: Encode;

    fn upgrade_from(prev_state: Self::PrevStateType) -> (Self, Self::StateType)
    where
        Self: Sized;
}

// Comes from `sails-rs`
async fn pause_program(_program_id: ActorId) {
    // Sends a message to the program to pause itself
}

// Comes from `sails-rs`
async fn read_program_state_bytes(_program_id: ActorId) -> Vec<u8> {
    // Sends a message to the program to read its state in chunks
    vec![]
}

// Comes from `sails-rs`
#[derive(Encode, Decode)]
#[codec(crate = sails_rs::scale_codec)]
pub enum UpgradableProgramCall {
    // Pause the program and allow specified program to call the `ReadState` method.
    // Only proxy program can call this method.
    Pause(ActorId),
    // Unpause the program. Only proxy program can call this method. Program has to be in the paused state.
    Unpause(),
    // Terminate the program. Only proxy program can call this method. Program has to be in the paused state.
    // It is called in case of successful upgrade and program value is transferred to the new program.
    Terminate(),
    // Read the program state. Only new program (provided via the Pause methos) can call this method.
    // Program has to be in the paused state.
    ReadState(u32, u32),
    // Proxy
}

pub enum UpgradableProgramCallV2 {
    Administrative,
    Interface(ActorId, Vec<u8>), // or Public
}

// What to to with the outgoing and delayed calls? There is a feeling replies should be handled by the proxy
// Or maybe the calls themselves should go via proxy?
// - P1 sent a message to P2 and went into waitlist. P1 got paused. P2 replies. How to handle the reply?
//   P1 can't change the state already.
//   - during pausing, wake up all the calls from the waitlist and fail them. It should work for both
//     async calls (xxx_for_reply, sleeps, locks, etc.) and delayed sends. So called drain process. Use gstd
//     internals for implementing?
//

// Administrative calls:
// - all calls from proxy owner are deemed as administrative
// - dedicated ProxyAdmin contract (side-cat for the proxy, non-upgradable), can have its own authorization
//   logic. Actually, this logic can be provided for the proxy itself. Could it be a part of the logic contract?
//   This will give an option to upgrade this logic as well. There will an extra call for each call to proxy
//   in order to distinguish between administrative and public calls. Combination of AdminProxy and AuthZ in Logic
//   gives upgradable authorization logic + easy detection of administrative calls.
