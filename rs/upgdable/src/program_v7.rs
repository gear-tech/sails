#![allow(dead_code)]
#![allow(unused_variables)]
use super::*;

// Specify only those fields that need to be migrated. Their names should be kept the same.
//#[prev_state(MigrationImpl)]
struct PrevProgramState {
    doc1: u16,
    doc2: u16,
}

// Generated by the `prev_state` attribute
impl MigrationSource for MigrationImpl {
    type StateType = PrevProgramState;
}

// Generated by the `prev_state` attribute
impl MigrationImpl {
    fn func(actor_id: ActorId) -> <Self as MigrationTarget>::StateType {
        let mut migration = MigrationImpl::default();
        let doc1 = read_document::<u16>(actor_id, "doc1");
        <Self as DocumentMigration<u16>>::extend(&mut migration, "doc1", &doc1);
        let doc2 = read_document::<u16>(actor_id, "doc2");
        <Self as DocumentMigration<u16>>::extend(&mut migration, "doc2", &doc2);
        migration.build()
    }
}

// Could be generated by the `state` attribute
#[derive(Default)]
struct MigrationImpl {
    doc1_1: Option<u32>,
    doc2_1: Option<Vec<String>>,
}

impl DocumentMigration<u16> for MigrationImpl {
    fn extend(&mut self, name: &str, document: &u16) {
        if name == "doc1" {
            self.doc1_1 = Some(*document as u32);
        } else if name == "doc2" {
            self.doc2_1 = Some(vec![document.to_string()]);
        } else {
            panic!("Unknown field name");
        }
    }
}

// Can be generated by the `state` attribute
impl MigrationImpl {
    pub fn build(self) -> <Self as MigrationTarget>::StateType {
        ProgramState {
            doc1_1: self.doc1_1.unwrap(),
            doc2_1: self.doc2_1.unwrap(),
        }
    }
}

//#[state(MigrationImpl)]
// This will allow to go through all members and generated fn for
// reading state in chunks (document by document)
#[derive(Default)] // Generated by the `state` attribute
struct ProgramState {
    doc1_1: u32,
    doc2_1: Vec<String>,
}

// Generate by the `state` attribute
impl MigrationTarget for MigrationImpl {
    type StateType = ProgramState;
}

// Generated by the `state` attribute
impl MigratedState for ProgramState {
    type MigrationType = MigrationImpl;
}

// We want to require this for the case when we migrate from the previos state
// as we don't need any initialization to happen. If this is the case, in theory
// we can even generate the program struct definition itself.
#[derive(Default)]
struct Program(());

//#[program(state = ProgramState)]
impl Program {
    pub fn new(p1: u32) -> Self {
        let mut result = Self(());
        result.state_mut().doc1_1 = p1;
        result
    }
}

// All below code is generated by macros
impl Program {
    pub fn state(&self) -> &ProgramState {
        panic!("This method is generated by the `program` attribute");
    }

    pub fn state_mut(&mut self) -> &mut ProgramState {
        panic!("This method is generated by the `program` attribute");
    }
}

// Generated by the `program` attribute
fn init() {
    let state = <ProgramState as MigratedState>::MigrationType::func(ActorId::zero());
}

// All below code comes from `sails-rs`
trait DocumentMigration<T> {
    fn extend(&mut self, name: &str, document: &T);
}

trait DocumentsMigration<T> {
    fn extend(&mut self, name: &str, documents: &[T]);
}

// MigrationImpl
trait MigrationSource {
    type StateType; // PrevProgramState
}

// MigrationImpl
trait MigrationTarget {
    type StateType; // ProgramState
}

// ProgramState
trait MigratedState {
    type MigrationType: Default + MigrationSource + MigrationTarget; // MigrationImpl
}

fn read_document<T>(_actor_id: ActorId, _name: &str) -> T {
    panic!("This method is generated by the `state` attribute");
}
