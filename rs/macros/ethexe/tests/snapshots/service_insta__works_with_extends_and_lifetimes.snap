---
source: rs/macros/ethexe/tests/service_insta.rs
expression: result
---
impl<'a> ExtendedLifetime<'a> {
    pub fn extended_name(&self) -> String {
        "extended-name".to_string()
    }
    pub fn name(&self) -> String {
        "extended".to_string()
    }
}
pub struct ExtendedLifetimeExposure<'a, T> {
    message_id: sails_rs::MessageId,
    route: &'static [u8],
    #[cfg(not(target_arch = "wasm32"))]
    inner: Box<T>,
    #[cfg(not(target_arch = "wasm32"))]
    inner_ptr: *const T,
    #[cfg(target_arch = "wasm32")]
    inner: T,
    base_0: <base::BaseLifetime<'a> as sails_rs::gstd::services::Service>::Exposure,
}
impl<'a> ExtendedLifetimeExposure<'a, ExtendedLifetime<'a>> {
    pub fn extended_name(&self) -> String {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new(self);
        self.inner.extended_name()
    }
    pub fn name(&self) -> String {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new(self);
        self.inner.name()
    }
    pub fn as_base_0(
        &self,
    ) -> &<base::BaseLifetime<'a> as sails_rs::gstd::services::Service>::Exposure {
        &self.base_0
    }
    pub async fn try_handle(&mut self, input: &[u8]) -> Option<(Vec<u8>, u128)> {
        use sails_rs::gstd::InvocationIo;
        if let Ok(request) = extended_lifetime_meta::__ExtendedNameParams::decode_params(
            &input,
        ) {
            let result = self.extended_name();
            let value = 0u128;
            let output = extended_lifetime_meta::__ExtendedNameParams::encode_reply(
                &result,
            );
            return Some((output, value));
        }
        if let Ok(request) = extended_lifetime_meta::__NameParams::decode_params(
            &input,
        ) {
            let result = self.name();
            let value = 0u128;
            let output = extended_lifetime_meta::__NameParams::encode_reply(&result);
            return Some((output, value));
        }
        if let Some((output, value)) = self.base_0.try_handle(input).await {
            return Some((output, value));
        }
        None
    }
    pub async fn try_handle_solidity(
        &mut self,
        method: &[u8],
        input: &[u8],
    ) -> Option<(Vec<u8>, u128)> {
        if method
            == &[
                48u8,
                69u8,
                120u8,
                116u8,
                101u8,
                110u8,
                100u8,
                101u8,
                100u8,
                78u8,
                97u8,
                109u8,
                101u8,
            ]
        {
            let (): () = sails_rs::alloy_sol_types::SolValue::abi_decode_params(
                    input,
                    false,
                )
                .expect("Failed to decode request");
            let result = self.extended_name();
            let value = 0u128;
            return Some((
                sails_rs::alloy_sol_types::SolValue::abi_encode(&result),
                value,
            ));
        }
        if method == &[16u8, 78u8, 97u8, 109u8, 101u8] {
            let (): () = sails_rs::alloy_sol_types::SolValue::abi_decode_params(
                    input,
                    false,
                )
                .expect("Failed to decode request");
            let result = self.name();
            let value = 0u128;
            return Some((
                sails_rs::alloy_sol_types::SolValue::abi_encode(&result),
                value,
            ));
        }
        if let Some((output, value)) = self
            .base_0
            .try_handle_solidity(method, input)
            .await
        {
            return Some((output, value));
        }
        None
    }
}
impl<'a> sails_rs::gstd::services::Exposure
for ExtendedLifetimeExposure<'a, ExtendedLifetime<'a>> {
    fn message_id(&self) -> sails_rs::MessageId {
        self.message_id
    }
    fn route(&self) -> &'static [u8] {
        self.route
    }
}
impl<'a> sails_rs::gstd::services::Service for ExtendedLifetime<'a> {
    type Exposure = ExtendedLifetimeExposure<'a, ExtendedLifetime<'a>>;
    fn expose(
        self,
        message_id: sails_rs::MessageId,
        route: &'static [u8],
    ) -> Self::Exposure {
        #[cfg(not(target_arch = "wasm32"))]
        let inner_box = Box::new(self);
        #[cfg(not(target_arch = "wasm32"))]
        let inner = inner_box.as_ref();
        #[cfg(target_arch = "wasm32")]
        let inner = &self;
        Self::Exposure {
            message_id,
            route,
            base_0: <base::BaseLifetime<
                'a,
            > as Clone>::clone(AsRef::<base::BaseLifetime<'a>>::as_ref(inner))
                .expose(message_id, route),
            #[cfg(not(target_arch = "wasm32"))]
            inner_ptr: inner_box.as_ref() as *const Self,
            #[cfg(not(target_arch = "wasm32"))]
            inner: inner_box,
            #[cfg(target_arch = "wasm32")]
            inner: self,
        }
    }
}
impl<'a> sails_rs::meta::ServiceMeta for ExtendedLifetime<'a> {
    type CommandsMeta = extended_lifetime_meta::CommandsMeta;
    type QueriesMeta = extended_lifetime_meta::QueriesMeta;
    type EventsMeta = extended_lifetime_meta::EventsMeta;
    const BASE_SERVICES: &'static [fn() -> sails_rs::meta::AnyServiceMeta] = &[
        sails_rs::meta::AnyServiceMeta::new::<base::BaseLifetime<'a>>,
    ];
}
mod extended_lifetime_meta {
    use super::*;
    use sails_rs::{Decode, TypeInfo};
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __ExtendedNameParams {}
    impl sails_rs::gstd::InvocationIo for __ExtendedNameParams {
        const ROUTE: &'static [u8] = &[
            48u8,
            69u8,
            120u8,
            116u8,
            101u8,
            110u8,
            100u8,
            101u8,
            100u8,
            78u8,
            97u8,
            109u8,
            101u8,
        ];
        type Params = Self;
    }
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __NameParams {}
    impl sails_rs::gstd::InvocationIo for __NameParams {
        const ROUTE: &'static [u8] = &[16u8, 78u8, 97u8, 109u8, 101u8];
        type Params = Self;
    }
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum CommandsMeta {}
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum QueriesMeta {
        ExtendedName(__ExtendedNameParams, String),
        Name(__NameParams, String),
    }
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum NoEvents {}
    pub type EventsMeta = NoEvents;
}
impl<'a> sails_rs::solidity::ServiceSignature for ExtendedLifetime<'a> {
    const METHODS: &'static [sails_rs::solidity::MethodRoute] = sails_rs::const_concat_slices!(
        < sails_rs::solidity::MethodRoute >, & [(sails_rs::concatcp!("extended_name", <<
        (u128,) as sails_rs::alloy_sol_types::SolValue > ::SolType as
        sails_rs::alloy_sol_types::SolType > ::SOL_NAME,), & [48u8, 69u8, 120u8, 116u8,
        101u8, 110u8, 100u8, 101u8, 100u8, 78u8, 97u8, 109u8, 101u8] as & [u8],),
        (sails_rs::concatcp!("name", << (u128,) as sails_rs::alloy_sol_types::SolValue >
        ::SolType as sails_rs::alloy_sol_types::SolType > ::SOL_NAME,), & [16u8, 78u8,
        97u8, 109u8, 101u8] as & [u8],),], < base::BaseLifetime as
        sails_rs::solidity::ServiceSignature > ::METHODS
    );
}
