---
source: rs/macros/core/tests/gservice.rs
expression: result
---
impl ReferenceService {
    pub fn baked(&self) -> &'static str {
        "Static str!"
    }
    pub fn incr(&mut self) -> &'static ReferenceCount {
        unsafe {
            COUNTER.0 += 1;
            &*ptr::addr_of!(COUNTER)
        }
    }
    pub fn add_byte(&mut self, byte: u8) -> &'static [u8] {
        unsafe {
            BYTES.push(byte);
            &*ptr::addr_of!(BYTES)
        }
    }
    pub async fn first_byte<'a>(&self) -> Option<&'a u8> {
        unsafe { BYTES.first() }
    }
    pub async fn last_byte<'a>(&self) -> Option<&'a u8> {
        unsafe { BYTES.last() }
    }
}
pub trait ReferenceServiceImplTrait {
    fn add_byte(&mut self, byte: u8) -> &'static [u8];
    fn baked(&self) -> &'static str;
    async fn first_byte<'a>(&self) -> Option<&'a u8>;
    fn incr(&mut self) -> &'static ReferenceCount;
    async fn last_byte<'a>(&self) -> Option<&'a u8>;
}
impl ReferenceServiceImplTrait
for sails_rs::gstd::services::ServiceExposure<ReferenceService, ()> {
    fn add_byte(&mut self, byte: u8) -> &'static [u8] {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.add_byte(byte)
    }
    fn baked(&self) -> &'static str {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.baked()
    }
    async fn first_byte<'a>(&self) -> Option<&'a u8> {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.first_byte().await
    }
    fn incr(&mut self) -> &'static ReferenceCount {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.incr()
    }
    async fn last_byte<'a>(&self) -> Option<&'a u8> {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.last_byte().await
    }
}
impl sails_rs::gstd::services::ServiceHandle for ReferenceService {
    async fn try_handle(&mut self, input: &[u8]) -> Option<(Vec<u8>, u128)> {
        let mut __input = input;
        let route: String = sails_rs::Decode::decode(&mut __input).ok()?;
        match route.as_str() {
            "AddByte" => {
                let request: reference_service_meta::__AddByteParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.add_byte(request.byte);
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("AddByte", &result)), value))
            }
            "Baked" => {
                let request: reference_service_meta::__BakedParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.baked();
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("Baked", &result)), value))
            }
            "FirstByte" => {
                let request: reference_service_meta::__FirstByteParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.first_byte().await;
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("FirstByte", &result)), value))
            }
            "Incr" => {
                let request: reference_service_meta::__IncrParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.incr();
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("Incr", &result)), value))
            }
            "LastByte" => {
                let request: reference_service_meta::__LastByteParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.last_byte().await;
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("LastByte", &result)), value))
            }
            _ => None,
        }
    }
}
impl sails_rs::gstd::services::Service for ReferenceService {
    type Exposure = sails_rs::gstd::services::ServiceExposure<ReferenceService, ()>;
    type Extend = ();
    fn expose(
        self,
        message_id: sails_rs::MessageId,
        route: &'static [u8],
    ) -> Self::Exposure {
        let extend = ();
        Self::Exposure::new(message_id, route, self, extend)
    }
}
impl sails_rs::meta::ServiceMeta for ReferenceService {
    fn commands() -> sails_rs::scale_info::MetaType {
        sails_rs::scale_info::MetaType::new::<reference_service_meta::CommandsMeta>()
    }
    fn queries() -> sails_rs::scale_info::MetaType {
        sails_rs::scale_info::MetaType::new::<reference_service_meta::QueriesMeta>()
    }
    fn events() -> sails_rs::scale_info::MetaType {
        sails_rs::scale_info::MetaType::new::<reference_service_meta::EventsMeta>()
    }
    fn base_services() -> impl Iterator<Item = sails_rs::meta::AnyServiceMeta> {
        [].into_iter()
    }
}
mod reference_service_meta {
    use super::*;
    use sails_rs::{Decode, TypeInfo};
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __AddByteParams {
        pub(super) byte: u8,
    }
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __BakedParams {}
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __FirstByteParams {}
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __IncrParams {}
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __LastByteParams {}
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum CommandsMeta {
        AddByte(__AddByteParams, &'static [u8]),
        Incr(__IncrParams, &'static ReferenceCount),
    }
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum QueriesMeta {
        Baked(__BakedParams, &'static str),
        FirstByte(__FirstByteParams, Option<&'static u8>),
        LastByte(__LastByteParams, Option<&'static u8>),
    }
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum NoEvents {}
    pub type EventsMeta = NoEvents;
}
