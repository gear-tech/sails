---
source: rs/macros/core/tests/gservice.rs
expression: result
---
impl<'a> ExtendedLifetime<'a> {
    pub fn extended_name(&self) -> String {
        "extended-name".to_string()
    }
    pub fn name(&self) -> String {
        "extended".to_string()
    }
}
pub trait ExtendedLifetimeImplTrait<'a> {
    fn extended_name(&self) -> String;
    fn name(&self) -> String;
}
impl<'a> ExtendedLifetimeImplTrait<'a>
for sails_rs::gstd::services::ServiceExposure<'a, ExtendedLifetime<'a>, ()> {
    fn extended_name(&self) -> String {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.extended_name()
    }
    fn name(&self) -> String {
        let exposure_scope = sails_rs::gstd::services::ExposureCallScope::new2(self);
        self.inner.name()
    }
}
impl<'a> sails_rs::gstd::services::ServiceHandle for ExtendedLifetime<'a> {
    async fn try_handle(&mut self, input: &[u8]) -> Option<(Vec<u8>, u128)> {
        let mut __input = input;
        let route: String = sails_rs::Decode::decode(&mut __input).ok()?;
        match route.as_str() {
            "ExtendedName" => {
                let request: extended_lifetime_meta::__ExtendedNameParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.extended_name();
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("ExtendedName", &result)), value))
            }
            "Name" => {
                let request: extended_lifetime_meta::__NameParams = sails_rs::Decode::decode(
                        &mut __input,
                    )
                    .expect("Failed to decode request");
                let result = self.name();
                let value = 0u128;
                Some((sails_rs::Encode::encode(&("Name", &result)), value))
            }
            _ => None,
        }
    }
}
impl<'a> sails_rs::gstd::services::Service for ExtendedLifetime<'a> {
    type Exposure = sails_rs::gstd::services::ServiceExposure<
        'a,
        ExtendedLifetime<'a>,
        (),
    >;
    type Extend = ();
    fn expose(
        self,
        message_id: sails_rs::MessageId,
        route: &'static [u8],
    ) -> Self::Exposure {
        let extend = ();
        Self::Exposure::new(message_id, route, self, extend)
    }
}
impl<'a> sails_rs::meta::ServiceMeta for ExtendedLifetime<'a> {
    fn commands() -> sails_rs::scale_info::MetaType {
        sails_rs::scale_info::MetaType::new::<extended_lifetime_meta::CommandsMeta>()
    }
    fn queries() -> sails_rs::scale_info::MetaType {
        sails_rs::scale_info::MetaType::new::<extended_lifetime_meta::QueriesMeta>()
    }
    fn events() -> sails_rs::scale_info::MetaType {
        sails_rs::scale_info::MetaType::new::<extended_lifetime_meta::EventsMeta>()
    }
    fn base_services() -> impl Iterator<Item = sails_rs::meta::AnyServiceMeta> {
        [sails_rs::meta::AnyServiceMeta::new::<base::BaseLifetime<'a>>()].into_iter()
    }
}
mod extended_lifetime_meta {
    use super::*;
    use sails_rs::{Decode, TypeInfo};
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __ExtendedNameParams {}
    #[derive(Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __NameParams {}
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum CommandsMeta {}
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum QueriesMeta {
        ExtendedName(__ExtendedNameParams, String),
        Name(__NameParams, String),
    }
    #[derive(TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum NoEvents {}
    pub type EventsMeta = NoEvents;
}
