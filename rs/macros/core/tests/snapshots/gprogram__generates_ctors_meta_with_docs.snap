---
source: rs/macros/core/tests/gprogram.rs
expression: result
---
impl MyProgram {
    /// This is New ctor
    pub async fn new(p1: u32, p2: String) -> Self {
        Self { p1, p2 }
    }
    /// This is New2 ctor
    /// With second line
    pub fn new2(p2: String, p1: u32) -> Self {
        Self { p1, p2 }
    }
}
impl sails_rs::meta::ProgramMeta for MyProgram {
    type ConstructorsMeta = meta_in_program::ConstructorsMeta;
    const SERVICES: &'static [(&'static str, sails_rs::meta::AnyServiceMetaFn)] = &[];
    const ASYNC: bool = true;
}
mod meta_in_program {
    use super::*;
    #[derive(sails_rs::Decode, sails_rs::TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __NewParams {
        pub(super) p1: u32,
        pub(super) p2: String,
    }
    #[derive(sails_rs::Decode, sails_rs::TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __New2Params {
        pub(super) p2: String,
        pub(super) p1: u32,
    }
    #[derive(sails_rs::TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ConstructorsMeta {
        /// This is New ctor
        New(__NewParams),
        /// This is New2 ctor
        /// With second line
        New2(__New2Params),
    }
}
#[cfg(target_arch = "wasm32")]
pub mod wasm {
    use super::*;
    use sails_rs::{gstd, hex, prelude::*};
    static mut PROGRAM: Option<MyProgram> = None;
    #[unsafe(no_mangle)]
    extern "C" fn init() {
        let mut input: &[u8] = &gstd::msg::load_bytes().expect("Failed to read input");
        if let Ok(header) = <sails_rs::meta::SailsMessageHeader as sails_rs::Decode>::decode(
            &mut input,
        ) {
            if header.interface_id() != sails_rs::meta::InterfaceId::zero() {
                sails_rs::gstd::unknown_input_panic(
                    "Non zero ctor interface_id",
                    header.to_bytes().as_slice(),
                );
            }
            match header.entry_id() {
                0u16 => {
                    let (p1, p2): (u32, String) = sails_rs::Decode::decode(&mut input)
                        .unwrap_or_else(|_| sails_rs::gstd::unknown_input_panic(
                            "Unknown request",
                            input,
                        ));
                    gstd::message_loop(async move {
                        let program = MyProgram::new(p1, p2).await;
                        unsafe {
                            PROGRAM = Some(program);
                        }
                    });
                }
                1u16 => {
                    let (p2, p1): (String, u32) = sails_rs::Decode::decode(&mut input)
                        .unwrap_or_else(|_| sails_rs::gstd::unknown_input_panic(
                            "Unknown request",
                            input,
                        ));
                    let program = MyProgram::new2(p2, p1);
                    unsafe {
                        PROGRAM = Some(program);
                    }
                }
                _ => {
                    sails_rs::gstd::unknown_input_panic(
                        "Unexpected ctor entry_id",
                        input,
                    )
                }
            }
        }
    }
    const SERVICES_COUNT: usize = 0usize;
    const INTERFACE_IDS: &'static [(sails_rs::meta::InterfaceId, u8)] = &sails_rs::meta::interface_ids::<
        SERVICES_COUNT,
    >(&[]);
    #[unsafe(no_mangle)]
    extern "C" fn handle() {
        let mut input = gstd::msg::load_bytes().expect("Failed to read input");
        let program_ref = unsafe { PROGRAM.as_mut() }.expect("Program not initialized");
        if let Ok(header) = <sails_rs::meta::SailsMessageHeader as sails_rs::Decode>::decode(
            &mut input.as_slice(),
        ) {
            let header_len = header.hlen().inner() as usize;
            let (interface_id, route_id, entry_id) = header
                .try_match_interfaces(INTERFACE_IDS)
                .expect("Failed to find matching service")
                .into_inner();
            match route_id {
                _ => gstd::unknown_input_panic("Unknown route_id", &[route_id]),
            }
        }
    }
    #[unsafe(no_mangle)]
    extern "C" fn handle_reply() {
        use sails_rs::meta::ProgramMeta;
        if MyProgram::ASYNC {
            gstd::handle_reply_with_hook();
        }
    }
    #[unsafe(no_mangle)]
    extern "C" fn handle_signal() {
        use sails_rs::meta::ProgramMeta;
        if MyProgram::ASYNC {
            gstd::handle_signal();
        }
    }
}
