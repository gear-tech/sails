use crate::prelude::*;
use alloy_primitives::Selector;

pub type MethodRoute = (&'static str, &'static [u8]);

pub trait ServiceSignature {
    const METHODS: &'static [MethodRoute];
}

pub trait ProgramSignature {
    const CTORS: &'static [MethodRoute];
    const SERVICES: &'static [(&'static str, &'static [u8], &'static [MethodRoute])];
    const METHODS_LEN: usize;
}

pub fn selector(s: impl AsRef<str>) -> Selector {
    alloy_primitives::keccak256(s.as_ref().as_bytes())[..4]
        .try_into()
        .unwrap()
}

pub const fn const_selector(name: &str) -> [u8; 4] {
    let hash: [u8; 32] = keccak_const::Keccak256::new()
        .update(name.as_bytes())
        .finalize();
    let mut output = [0u8; 4];
    let mut i = 0;
    while i < output.len() {
        output[i] = hash[i];
        i += 1;
    }
    output
}

macro_rules! const_selector {
    () => {
        [0u8; 4]
    };
    ($($s: expr),* $(,)?) => {{
        let mut keccak256 = crate::keccak_const::Keccak256::new();
        $(keccak256 = keccak256.update($s.as_bytes());)*
        let hash: [u8; 32] = keccak256.finalize();
        let mut output = [0u8; 4];
        let mut i = 0;
        while i < output.len() {
            output[i] = hash[i];
            i += 1;
        }
        output
    }};
}

#[macro_export]
macro_rules! const_concat_slices {
    (<$T:ty>, $($A:expr),+ $(,)?) => {{
        use core::mem::MaybeUninit;

        const LEN: usize = $( $A.len() + )* 0;
        const fn combined() -> [$T; LEN] {
            let mut output: [MaybeUninit<$T>; LEN] = [const { MaybeUninit::uninit() }; LEN];
            let _offset = 0;
            $(let _offset = copy_slice(&mut output, $A, _offset);)*
            unsafe { core::mem::transmute::<_, [$T; LEN]>(output) }
        }
        const fn copy_slice(output: &mut [MaybeUninit<$T>], input: &[$T], offset: usize) -> usize {
            let mut index = 0;
            while index < input.len() {
                output[offset + index].write(input[index]);
                index += 1;
            }
            offset + index
        }
        const RESULT: &[$T] = &combined();
        RESULT
    }};
}

pub struct ConstProgramMeta<T>(marker::PhantomData<T>);

impl<T> ConstProgramMeta<T>
where
    T: ProgramSignature,
{
    pub const fn ctor_sigs<const N: usize>() -> [[u8; 4]; N] {
        let mut sigs = [[0u8; 4]; N];
        let mut ctor_idx = 0;
        while ctor_idx < <T as ProgramSignature>::CTORS.len() {
            let (name, _) = <T as ProgramSignature>::CTORS[ctor_idx];
            sigs[ctor_idx] = const_selector!(name);
            ctor_idx += 1;
        }
        sigs
    }

    pub const fn method_sigs<const N: usize>() -> [[u8; 4]; N] {
        let mut sigs = [[0u8; 4]; N];
        let mut sigs_idx = 0;
        let mut svc_idx = 0;
        while svc_idx < <T as ProgramSignature>::SERVICES.len() {
            let (svc_name, _, methods) = <T as ProgramSignature>::SERVICES[svc_idx];
            let mut method_idx = 0;
            while method_idx < methods.len() {
                let (name, _) = methods[method_idx];
                sigs[sigs_idx] = const_selector!(svc_name, "_", name);
                method_idx += 1;
                sigs_idx += 1;
            }
            svc_idx += 1;
        }
        sigs
    }

    pub const fn method_routes<const N: usize>() -> [(&'static [u8], &'static [u8]); N] {
        let mut routes: [(&'static [u8], &'static [u8]); N] = [(&[], &[]); N];
        let mut map_idx = 0;
        let mut svc_idx = 0;
        while svc_idx < <T as ProgramSignature>::SERVICES.len() {
            let (_, svc_route, methods) = <T as ProgramSignature>::SERVICES[svc_idx];
            let mut method_idx = 0;
            while method_idx < methods.len() {
                let (_, route) = methods[method_idx];
                routes[map_idx] = (svc_route, route);
                method_idx += 1;
                map_idx += 1;
            }
            svc_idx += 1;
        }
        routes
    }
}

/// Trait for encoding Ethereum events for the EVM.
///
/// This trait provides a uniform interface to convert an event into the topics and data payload
/// that are used to emit logs in the Ethereum Virtual Machine (EVM). The logs generated by the EVM
/// consist of:
///
/// - **Topics:** An array of 32-byte values. The first topic is always the keccak256 hash of the event
///   signature, while the remaining topics correspond to indexed fields. For dynamic types (as determined
///   by `<T as alloy_sol_types::SolType>::IS_DYNAMIC`), the ABI-encoded value is hashed before being stored.
///   For static types, the ABI-encoded value is left-padded with zeros to 32 bytes.
/// - **Data:** A byte array containing the ABI-encoded non-indexed fields of the event, encoded as a tuple.
///
/// This trait is intended to be used with the `#[derive(EvmEvent)]` procedural macro, which automatically
/// implements the trait for your enum-based event definitions.
///
/// # Examples
///
/// Given an event definition:
///
/// ```rust
/// #[derive(EvmEvent)]
/// pub enum Events {
///     MyEvent {
///         #[indexed]
///         sender: uint128,
///         amount: uint128,
///         note: String,
///     },
/// }
/// ```
///
/// Calling the methods:
///
/// ```rust
/// let event = Events::MyEvent {
///     sender: 123,
///     amount: 1000,
///     note: "Hello, Ethereum".to_owned(),
/// };
///
/// let topics = event.topics();
/// let data = event.data();
/// ```
///
/// The first topic will be the hash of the event signature (e.g. `"MyEvent(uint128,uint128,String)"`),
/// and additional topics and the data payload will be computed based on the field attributes.
///
/// # Methods
///
/// - `topics()`: Returns a vector of 32-byte topics (`alloy_primitives::B256`) for the event.
/// - `data()`: Returns the ABI-encoded data payload (a `Vec<u8>`) for the non-indexed fields.
pub trait EvmEvent {
    /// The signature(s) associated with the event.
    ///
    /// The signature is the event name and its parameter types, e.g. `MyEvent(uint128,uint128,string)`.
    /// The signature is used as the first topic in the log.
    const SIGNATURES: &'static [&'static str];

    /// Returns the topics associated with the event.
    ///
    /// The topics vector includes:
    ///
    /// 1. The keccak256 hash of the event signature as the first topic.
    /// 2. For each indexed field, a topic that is generated based on the field's ABI encoding:
    ///    - For dynamic types, the ABI-encoded value is hashed using keccak256.
    ///    - For static types, the ABI-encoded value is left-padded with zeros to 32 bytes.
    ///
    /// # Returns
    ///
    /// A vector of topics (`alloy_primitives::B256`) that represent the event.
    fn topics(&self) -> Vec<alloy_primitives::B256>;

    /// Returns the ABI-encoded data payload of the event.
    ///
    /// The non-indexed fields of the event are ABI-encoded together as a tuple. If there are no non-indexed
    /// fields, an empty vector is returned.
    ///
    /// # Returns
    ///
    /// A `Vec<u8>` containing the ABI-encoded data of the non-indexed fields.
    fn data(&self) -> Vec<u8>;

    /// Returns the topic hash for a given value.
    fn topic_hash<T: alloy_sol_types::SolValue>(value: &T) -> alloy_primitives::B256 {
        if <T::SolType as alloy_sol_types::SolType>::DYNAMIC {
            alloy_primitives::keccak256(alloy_sol_types::SolValue::abi_encode(value))
        } else {
            let encoded = alloy_sol_types::SolValue::abi_encode(value);
            // Assume ABI encoding gives us a byte vector no longer than 32 bytes.
            let mut topic = [0u8; 32];
            // Right-align (pad on the left) if needed.
            topic[(32 - encoded.len())..].copy_from_slice(&encoded);
            topic.into()
        }
    }

    /// Encodes a sequence of values into a single byte vector.
    fn encode_sequence<T: alloy_sol_types::SolValue>(value: &T) -> Vec<u8>
    where
        for<'a> <T::SolType as alloy_sol_types::SolType>::Token<'a>:
            alloy_sol_types::abi::token::TokenSeq<'a>,
    {
        alloy_sol_types::SolValue::abi_encode_sequence(value)
    }

    /// Encodes the event with a header that includes the number of topics and the data type.
    fn encode_with_header(&self) -> Vec<u8> {
        let mut payload = Vec::new();
        let topics = self.topics();
        let data = self.data();
        let mut header = EthFixedHeader::new();
        header.set_header_type(topics.len() as u8);
        header.set_data_type(1);

        payload.extend_from_slice(header.as_bytes());
        for topic in topics {
            payload.extend_from_slice(topic.as_slice());
        }
        payload.extend_from_slice(data.as_slice());

        payload
    }
}
/// Represents a compact message header encoded in 4 bytes.
///
/// The `EthFixedHeader` structure encapsulates header information using exactly 4 bytes:
///
/// - **Bytes 0-1 (2 bytes):** The header version, stored as a big-endian `u16`.
/// - **Byte 2 (1 byte):** The header type.
/// - **Byte 3 (1 byte):** The data type.
///
/// # Version 1 Rules
///
/// For headers with version 1 (0x0001):
///
/// - **Header Type:**  
///   - `0`: Indicates that there is no header.
///   - `1` to `4`: Indicates the number of topics included in the header, where each topic occupies 32 bytes.
///     For example, a header type of `2` represents a header size of `2 * 32 = 64` bytes.
///   - `5`: Indicates that the header contains a 4 byte method signature.
///
/// - **Data Type:**  
///   - `0`: Indicates that there is no data.
///   - `1`: Indicates that the data is encoded in Solidity format.
///
/// # Examples
///
/// Creating a default header:
///
/// ```rust
/// # use your_crate::EthFixedHeader;
/// let header = EthFixedHeader::new();
/// assert_eq!(header.version(), 1);
/// assert_eq!(header.header_type(), 0);
/// assert_eq!(header.data_type(), 0);
/// assert_eq!(header.header_size(), Some(0));
/// ```
///
/// Constructing an `EthFixedHeader` from a slice of bytes:
///
/// ```rust
/// # use your_crate::EthFixedHeader;
/// let bytes = &[0x00, 0x01, 0x02, 0x03];
/// let header = EthFixedHeader::from_bytes(bytes);
/// assert_eq!(header.version(), 1);
/// assert_eq!(header.header_type(), 2);
/// assert_eq!(header.data_type(), 3);
/// assert_eq!(header.header_size(), Some(64)); // 2 topics * 32 bytes each
/// ```
///
/// # Methods
///
/// - `new()`: Creates a new `EthFixedHeader` with default values:
///   - Version is set to 1 (bytes: `[0, 1]`).
///   - Header type is set to 0.
///   - Data type is set to 0.
/// - `from_bytes(bytes: &[u8])`: Constructs an `EthFixedHeader` from a byte slice, copying up to 4 bytes.
/// - `as_bytes()`: Returns a reference to the underlying 4-byte array.
/// - `version()`: Returns the header version as a `u16` (big-endian).
/// - `header_type()`: Returns the header type (third byte).
/// - `data_type()`: Returns the data type (fourth byte).
/// - `set_header_type(header: u8)`: Sets the header type (third byte).
/// - `set_data_type(data: u8)`: Sets the data type (fourth byte).
/// - `header_size()`: For version 1, returns:
///     - `Some(0)` if the header type is `0`.
///     - `Some(n * 32)` if the header type is between 1 and 4 (inclusive), where `n`
///       is the header type value.
///     - `Some(4)` if the header type is `5`.
///     - `None` for unsupported header type values or versions.
///
/// # Default
///
/// The default implementation of `EthFixedHeader` creates a new header using `EthFixedHeader::new()`.
///
pub struct EthFixedHeader([u8; 4]);

impl EthFixedHeader {
    /// Creates a new `EthFixedHeader` with default settings.
    ///
    /// Default header has:
    /// - Version: 1 (encoded as `[0, 1]`)
    /// - Header type: 0 (no header)
    /// - Data type: 0
    pub const fn new() -> Self {
        Self([0u8, 1u8, 0u8, 0u8])
    }

    /// Constructs an `EthFixedHeader` from a byte slice.
    ///
    /// Copies up to 4 bytes from the given slice. If the slice is shorter than 4 bytes,
    /// the remaining bytes will be set to 0.
    pub const fn from_bytes(bytes: &[u8]) -> Self {
        let mut header = [0u8; 4];
        let mut i = 0;
        while i < bytes.len() && i < header.len() {
            header[i] = bytes[i];
            i += 1;
        }
        Self(header)
    }

    /// Returns the header as a byte slice.
    pub const fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    /// Returns the version of the header.
    ///
    /// The version is represented by the first two bytes (big-endian) of the header.
    pub const fn version(&self) -> u16 {
        u16::from_be_bytes([self.0[0], self.0[1]])
    }

    /// Returns the header type.
    ///
    /// For version 1:
    /// - `0` indicates no header.
    /// - `1` to `4` indicate the number of topics (each 32 bytes).
    /// - '5' indicates a 4 byte method signature.
    pub const fn header_type(&self) -> u8 {
        self.0[2]
    }

    /// Returns the data type.
    ///
    /// The data type is stored in the fourth byte of the header.
    pub const fn data_type(&self) -> u8 {
        self.0[3]
    }

    /// Sets the header type.
    pub fn set_header_type(&mut self, header: u8) {
        self.0[2] = header;
    }

    /// Sets the data type.
    pub fn set_data_type(&mut self, data: u8) {
        self.0[3] = data;
    }

    /// Returns the size of the header in bytes.
    ///
    /// For headers with version 1:
    /// - If `header_type` is 0, returns `Some(0)`.
    /// - If `header_type` is between 1 and 4  (inclusive), returns `Some(header_type * 32)`.
    /// - If `header_type` is 5, returns `Some(4)`.
    ///
    /// For other versions or invalid header types, `None` is returned.
    pub fn header_size(&self) -> Option<usize> {
        match self.version() {
            1 => match self.header_type() {
                0 => Some(0),
                1..=4 => Some(self.header_type() as usize * 32),
                5 => Some(4),
                _ => None,
            },
            _ => None,
        }
    }
}

impl Default for EthFixedHeader {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy_sol_types::{SolType, SolValue};

    #[test]
    fn type_names() {
        let s = <() as SolValue>::SolType::SOL_NAME;
        assert_eq!("()", s);

        let s = <(u32,) as SolValue>::SolType::SOL_NAME;
        assert_eq!("(uint32)", s);

        let s = <(u32, String) as SolValue>::SolType::SOL_NAME;
        assert_eq!("(uint32,string)", s);

        // let s = <(u32, String, ActorId) as SolValue>::SolType::SOL_NAME;
        // assert_eq!("(uint32,string,address)", s);
    }

    struct Prg;
    struct Svc;
    struct ExtendedSvc;

    impl ServiceSignature for Svc {
        const METHODS: &[MethodRoute] = &[
            (
                concatcp!(
                    "do_this",
                    <<(u32, String, u128,) as SolValue>::SolType as SolType>::SOL_NAME,
                ),
                &[24u8, 68u8, 111u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
            ),
            (
                concatcp!(
                    "this",
                    <<(bool, u128,) as SolValue>::SolType as SolType>::SOL_NAME
                ),
                &[16u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
            ),
        ];
    }

    impl ServiceSignature for ExtendedSvc {
        const METHODS: &[MethodRoute] = const_concat_slices!(
            <MethodRoute>,
            &[
                (
                    concatcp!(
                        "do_this",
                        <<(u32, String, u128,) as SolValue>::SolType as SolType>::SOL_NAME,
                    ),
                    &[24u8, 68u8, 111u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
                ),
                (
                    concatcp!(
                        "this",
                        <<(bool, u128,) as SolValue>::SolType as SolType>::SOL_NAME
                    ),
                    &[16u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
                ),
            ],
            <Svc as ServiceSignature>::METHODS
        );
    }

    impl ProgramSignature for Prg {
        const METHODS_LEN: usize = <Svc as ServiceSignature>::METHODS.len()
            + <ExtendedSvc as ServiceSignature>::METHODS.len();

        const CTORS: &[MethodRoute] = &[(
            concatcp!(
                "default",
                <<(u128,) as SolValue>::SolType as SolType>::SOL_NAME,
            ),
            &[28u8, 68u8, 101u8, 102u8, 97u8, 117u8, 108u8, 116u8] as &[u8],
        )];

        const SERVICES: &[(&'static str, &'static [u8], &[MethodRoute])] = &[
            (
                "svc1",
                &[16u8, 83u8, 118u8, 99u8, 49u8] as &[u8],
                <Svc as ServiceSignature>::METHODS,
            ),
            (
                "svc2",
                &[16u8, 83u8, 118u8, 99u8, 49u8] as &[u8],
                <ExtendedSvc as ServiceSignature>::METHODS,
            ),
        ];
    }

    #[test]
    fn service_signature_extended() {
        assert_eq!(4, ExtendedSvc::METHODS.len());

        let do_this = (
            "do_this(uint32,string,uint128)",
            &[24u8, 68u8, 111u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
        );
        let this = (
            concatcp!(
                "this",
                <<(bool, u128,) as SolValue>::SolType as SolType>::SOL_NAME
            ),
            &[16u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
        );
        assert_eq!(do_this, ExtendedSvc::METHODS[0]);
        assert_eq!(this, ExtendedSvc::METHODS[1]);
        assert_eq!(do_this, ExtendedSvc::METHODS[2]);
        assert_eq!(this, ExtendedSvc::METHODS[3]);
    }

    #[test]
    fn program_signature() {
        const S1: [u8; 4] = [107, 214, 203, 248];
        const S2: [u8; 4] = [141, 22, 87, 153];
        const SIGS: [[u8; 4]; <Prg as solidity::ProgramSignature>::METHODS_LEN] =
            solidity::ConstProgramMeta::<Prg>::method_sigs();
        assert_eq!(6, SIGS.len());

        let sig1 = selector("svc1_do_this(uint32,string,uint128)");
        assert_eq!(S1, sig1.as_slice());
        assert_eq!(S1, SIGS[0]);

        let sig2 = selector("svc1_this(bool,uint128)");
        assert_eq!(S2, sig2.as_slice());
        assert_eq!(S2, SIGS[1]);

        assert_eq!(Some(0), SIGS.iter().position(|s| s == &S1));
        assert_eq!(Some(1), SIGS.iter().position(|s| s == &S2));

        let sig3 = selector("svc2_do_this(uint32,string,uint128)");
        assert_eq!(Some(2), SIGS.iter().position(|s| s == sig3.as_slice()));

        let sig4 = selector("svc2_this(bool,uint128)");
        assert_eq!(Some(3), SIGS.iter().position(|s| s == sig4.as_slice()));
    }

    #[test]
    fn program_ctor_sigs() {
        const CTOR_SIGS: [[u8; 4]; <Prg as solidity::ProgramSignature>::CTORS.len()] =
            solidity::ConstProgramMeta::<Prg>::ctor_sigs();
        let sig_ctor = selector("default(uint128)");
        assert_eq!(CTOR_SIGS[0], sig_ctor.as_slice());
    }

    #[allow(unused)]
    #[derive(EvmEvent, TypeInfo)]
    #[sails_path(crate = crate)]
    enum Events {
        MyEvent1 {
            #[indexed]
            sender: u128,
            #[indexed]
            amount: u128,
            note: String,
        },
        MyEvent2(#[indexed] u128, u128, String),
        MyEvent3,
    }

    #[test]
    fn evm_event_sig() {
        const SIG_TOPIC: [u8; 32] = [
            148, 157, 201, 65, 144, 217, 114, 52, 67, 86, 206, 75, 197, 220, 61, 74, 138, 251, 52,
            61, 243, 110, 252, 93, 62, 91, 109, 51, 209, 107, 68, 200,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(SIG_TOPIC.as_slice(), ev.topics()[0].as_slice());
    }

    #[test]
    fn evm_event_topic_1() {
        const SENDER_TOPIC: [u8; 32] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(SENDER_TOPIC.as_slice(), ev.topics()[1].as_slice());
    }

    #[test]
    fn evm_event_data() {
        const DATA: &[u8] = &[
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 5, 104, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(DATA, ev.data().as_slice());
    }

    #[test]
    fn eth_header() {
        let h = EthFixedHeader::new();
        assert_eq!(1, h.version());
        assert_eq!(0u8, h.header_type());
        assert_eq!(0u8, h.data_type());
        assert_eq!(Some(0), h.header_size());
    }
}
