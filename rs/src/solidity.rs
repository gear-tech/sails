use crate::prelude::*;
use alloy_primitives::Selector;

pub type MethodRoute = (&'static str, &'static [u8]);

pub trait ServiceSignature {
    const METHODS: &'static [MethodRoute];
}

pub trait ProgramSignature {
    const CTORS: &'static [MethodRoute];
    const SERVICES: &'static [(&'static str, &'static [u8], &'static [MethodRoute])];
    const METHODS_LEN: usize;
}

pub fn selector(s: impl AsRef<str>) -> Selector {
    alloy_primitives::keccak256(s.as_ref().as_bytes())[..4]
        .try_into()
        .unwrap()
}

pub const fn const_selector(name: &str) -> [u8; 4] {
    let hash: [u8; 32] = keccak_const::Keccak256::new()
        .update(name.as_bytes())
        .finalize();
    let mut output = [0u8; 4];
    let mut i = 0;
    while i < output.len() {
        output[i] = hash[i];
        i += 1;
    }
    output
}

macro_rules! const_selector {
    () => {
        [0u8; 4]
    };
    ($($s: expr),* $(,)?) => {{
        let mut keccak256 = crate::keccak_const::Keccak256::new();
        $(keccak256 = keccak256.update($s.as_bytes());)*
        let hash: [u8; 32] = keccak256.finalize();
        let mut output = [0u8; 4];
        let mut i = 0;
        while i < output.len() {
            output[i] = hash[i];
            i += 1;
        }
        output
    }};
}

#[macro_export]
macro_rules! const_concat_slices {
    (<$T:ty>, $($A:expr),+ $(,)?) => {{
        use core::mem::MaybeUninit;

        const LEN: usize = $( $A.len() + )* 0;
        const fn combined() -> [$T; LEN] {
            let mut output: [MaybeUninit<$T>; LEN] = [const { MaybeUninit::uninit() }; LEN];
            let _offset = 0;
            $(let _offset = copy_slice(&mut output, $A, _offset);)*
            unsafe { core::mem::transmute::<_, [$T; LEN]>(output) }
        }
        const fn copy_slice(output: &mut [MaybeUninit<$T>], input: &[$T], offset: usize) -> usize {
            let mut index = 0;
            while index < input.len() {
                output[offset + index].write(input[index]);
                index += 1;
            }
            offset + index
        }
        const RESULT: &[$T] = &combined();
        RESULT
    }};
}

pub struct ConstProgramMeta<T>(marker::PhantomData<T>);

impl<T> ConstProgramMeta<T>
where
    T: ProgramSignature,
{
    pub const fn ctor_sigs<const N: usize>() -> [[u8; 4]; N] {
        let mut sigs = [[0u8; 4]; N];
        let mut ctor_idx = 0;
        while ctor_idx < <T as ProgramSignature>::CTORS.len() {
            let (name, _) = <T as ProgramSignature>::CTORS[ctor_idx];
            sigs[ctor_idx] = const_selector!(name);
            ctor_idx += 1;
        }
        sigs
    }

    pub const fn method_sigs<const N: usize>() -> [[u8; 4]; N] {
        let mut sigs = [[0u8; 4]; N];
        let mut sigs_idx = 0;
        let mut svc_idx = 0;
        while svc_idx < <T as ProgramSignature>::SERVICES.len() {
            let (svc_name, _, methods) = <T as ProgramSignature>::SERVICES[svc_idx];
            let mut method_idx = 0;
            while method_idx < methods.len() {
                let (name, _) = methods[method_idx];
                sigs[sigs_idx] = const_selector!(svc_name, "_", name);
                method_idx += 1;
                sigs_idx += 1;
            }
            svc_idx += 1;
        }
        sigs
    }

    pub const fn method_routes<const N: usize>() -> [(&'static [u8], &'static [u8]); N] {
        let mut routes: [(&'static [u8], &'static [u8]); N] = [(&[], &[]); N];
        let mut map_idx = 0;
        let mut svc_idx = 0;
        while svc_idx < <T as ProgramSignature>::SERVICES.len() {
            let (_, svc_route, methods) = <T as ProgramSignature>::SERVICES[svc_idx];
            let mut method_idx = 0;
            while method_idx < methods.len() {
                let (_, route) = methods[method_idx];
                routes[map_idx] = (svc_route, route);
                method_idx += 1;
                map_idx += 1;
            }
            svc_idx += 1;
        }
        routes
    }
}

/// Trait for encoding Ethereum events for the EVM.
///
/// This trait provides a uniform interface to convert an event into the topics and data payload
/// that are used to emit logs in the Ethereum Virtual Machine (EVM). The logs generated by the EVM
/// consist of:
///
/// - **Topics:** An array of 32-byte values. The first topic is always the keccak256 hash of the event
///   signature, while the remaining topics correspond to indexed fields. For dynamic types (as determined
///   by `<T as alloy_sol_types::SolType>::IS_DYNAMIC`), the ABI-encoded value is hashed before being stored.
///   For static types, the ABI-encoded value is left-padded with zeros to 32 bytes.
/// - **Data:** A byte array containing the ABI-encoded non-indexed fields of the event, encoded as a tuple.
///
/// This trait is intended to be used with the `#[derive(EvmEvent)]` procedural macro, which automatically
/// implements the trait for your enum-based event definitions.
///
/// # Examples
///
/// Given an event definition:
///
/// ```rust
/// #[derive(EvmEvent)]
/// pub enum Events {
///     MyEvent {
///         #[indexed]
///         sender: uint128,
///         amount: uint128,
///         note: String,
///     },
/// }
/// ```
///
/// Calling the methods:
///
/// ```rust
/// let event = Events::MyEvent {
///     sender: 123,
///     amount: 1000,
///     note: "Hello, Ethereum".to_owned(),
/// };
///
/// let topics = event.topics();
/// let data = event.data();
/// ```
///
/// The first topic will be the hash of the event signature (e.g. `"MyEvent(uint128,uint128,String)"`),
/// and additional topics and the data payload will be computed based on the field attributes.
///
/// # Methods
///
/// - `topics()`: Returns a vector of 32-byte topics (`alloy_primitives::B256`) for the event.
/// - `data()`: Returns the ABI-encoded data payload (a `Vec<u8>`) for the non-indexed fields.
pub trait EvmEvent {
    /// The signature(s) associated with the event.
    ///
    /// The signature is the event name and its parameter types, e.g. `MyEvent(uint128,uint128,string)`.
    /// The signature is used as the first topic in the log.
    const SIGNATURES: &'static [&'static str];

    /// Returns the topics associated with the event.
    ///
    /// The topics vector includes:
    ///
    /// 1. The keccak256 hash of the event signature as the first topic.
    /// 2. For each indexed field, a topic that is generated based on the field's ABI encoding:
    ///    - For dynamic types, the ABI-encoded value is hashed using keccak256.
    ///    - For static types, the ABI-encoded value is left-padded with zeros to 32 bytes.
    ///
    /// # Returns
    ///
    /// A vector of topics (`alloy_primitives::B256`) that represent the event.
    fn topics(&self) -> Vec<alloy_primitives::B256>;

    /// Returns the ABI-encoded data payload of the event.
    ///
    /// The non-indexed fields of the event are ABI-encoded together as a tuple. If there are no non-indexed
    /// fields, an empty vector is returned.
    ///
    /// # Returns
    ///
    /// A `Vec<u8>` containing the ABI-encoded data of the non-indexed fields.
    fn data(&self) -> Vec<u8>;

    /// Returns the topic hash for a given value.
    fn topic_hash<T: alloy_sol_types::SolValue>(value: &T) -> alloy_primitives::B256 {
        if <T::SolType as alloy_sol_types::SolType>::DYNAMIC {
            alloy_primitives::keccak256(alloy_sol_types::SolValue::abi_encode(value))
        } else {
            let encoded = alloy_sol_types::SolValue::abi_encode(value);
            // Assume ABI encoding gives us a byte vector no longer than 32 bytes.
            let mut topic = [0u8; 32];
            // Right-align (pad on the left) if needed.
            topic[(32 - encoded.len())..].copy_from_slice(&encoded);
            topic.into()
        }
    }

    /// Encodes a sequence of values into a single byte vector.
    fn encode_sequence<T: alloy_sol_types::SolValue>(value: &T) -> Vec<u8>
    where
        for<'a> <T::SolType as alloy_sol_types::SolType>::Token<'a>:
            alloy_sol_types::abi::token::TokenSeq<'a>,
    {
        alloy_sol_types::SolValue::abi_encode_sequence(value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy_sol_types::{SolType, SolValue};

    #[test]
    fn type_names() {
        let s = <() as SolValue>::SolType::SOL_NAME;
        assert_eq!("()", s);

        let s = <(u32,) as SolValue>::SolType::SOL_NAME;
        assert_eq!("(uint32)", s);

        let s = <(u32, String) as SolValue>::SolType::SOL_NAME;
        assert_eq!("(uint32,string)", s);

        // let s = <(u32, String, ActorId) as SolValue>::SolType::SOL_NAME;
        // assert_eq!("(uint32,string,address)", s);
    }

    struct Prg;
    struct Svc;
    struct ExtendedSvc;

    impl ServiceSignature for Svc {
        const METHODS: &[MethodRoute] = &[
            (
                concatcp!(
                    "do_this",
                    <<(u32, String, u128,) as SolValue>::SolType as SolType>::SOL_NAME,
                ),
                &[24u8, 68u8, 111u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
            ),
            (
                concatcp!(
                    "this",
                    <<(bool, u128,) as SolValue>::SolType as SolType>::SOL_NAME
                ),
                &[16u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
            ),
        ];
    }

    impl ServiceSignature for ExtendedSvc {
        const METHODS: &[MethodRoute] = const_concat_slices!(
            <MethodRoute>,
            &[
                (
                    concatcp!(
                        "do_this",
                        <<(u32, String, u128,) as SolValue>::SolType as SolType>::SOL_NAME,
                    ),
                    &[24u8, 68u8, 111u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
                ),
                (
                    concatcp!(
                        "this",
                        <<(bool, u128,) as SolValue>::SolType as SolType>::SOL_NAME
                    ),
                    &[16u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
                ),
            ],
            <Svc as ServiceSignature>::METHODS
        );
    }

    impl ProgramSignature for Prg {
        const METHODS_LEN: usize = <Svc as ServiceSignature>::METHODS.len()
            + <ExtendedSvc as ServiceSignature>::METHODS.len();

        const CTORS: &[MethodRoute] = &[(
            concatcp!(
                "default",
                <<(u128,) as SolValue>::SolType as SolType>::SOL_NAME,
            ),
            &[28u8, 68u8, 101u8, 102u8, 97u8, 117u8, 108u8, 116u8] as &[u8],
        )];

        const SERVICES: &[(&'static str, &'static [u8], &[MethodRoute])] = &[
            (
                "svc1",
                &[16u8, 83u8, 118u8, 99u8, 49u8] as &[u8],
                <Svc as ServiceSignature>::METHODS,
            ),
            (
                "svc2",
                &[16u8, 83u8, 118u8, 99u8, 49u8] as &[u8],
                <ExtendedSvc as ServiceSignature>::METHODS,
            ),
        ];
    }

    #[test]
    fn service_signature_extended() {
        assert_eq!(4, ExtendedSvc::METHODS.len());

        let do_this = (
            "do_this(uint32,string,uint128)",
            &[24u8, 68u8, 111u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
        );
        let this = (
            concatcp!(
                "this",
                <<(bool, u128,) as SolValue>::SolType as SolType>::SOL_NAME
            ),
            &[16u8, 84u8, 104u8, 105u8, 115u8] as &[u8],
        );
        assert_eq!(do_this, ExtendedSvc::METHODS[0]);
        assert_eq!(this, ExtendedSvc::METHODS[1]);
        assert_eq!(do_this, ExtendedSvc::METHODS[2]);
        assert_eq!(this, ExtendedSvc::METHODS[3]);
    }

    #[test]
    fn program_signature() {
        const S1: [u8; 4] = [107, 214, 203, 248];
        const S2: [u8; 4] = [141, 22, 87, 153];
        const SIGS: [[u8; 4]; <Prg as solidity::ProgramSignature>::METHODS_LEN] =
            solidity::ConstProgramMeta::<Prg>::method_sigs();
        assert_eq!(6, SIGS.len());

        let sig1 = selector("svc1_do_this(uint32,string,uint128)");
        assert_eq!(S1, sig1.as_slice());
        assert_eq!(S1, SIGS[0]);

        let sig2 = selector("svc1_this(bool,uint128)");
        assert_eq!(S2, sig2.as_slice());
        assert_eq!(S2, SIGS[1]);

        assert_eq!(Some(0), SIGS.iter().position(|s| s == &S1));
        assert_eq!(Some(1), SIGS.iter().position(|s| s == &S2));

        let sig3 = selector("svc2_do_this(uint32,string,uint128)");
        assert_eq!(Some(2), SIGS.iter().position(|s| s == sig3.as_slice()));

        let sig4 = selector("svc2_this(bool,uint128)");
        assert_eq!(Some(3), SIGS.iter().position(|s| s == sig4.as_slice()));
    }

    #[test]
    fn program_ctor_sigs() {
        const CTOR_SIGS: [[u8; 4]; <Prg as solidity::ProgramSignature>::CTORS.len()] =
            solidity::ConstProgramMeta::<Prg>::ctor_sigs();
        let sig_ctor = selector("default(uint128)");
        assert_eq!(CTOR_SIGS[0], sig_ctor.as_slice());
    }

    #[allow(unused)]
    #[derive(EvmEvent, TypeInfo)]
    #[sails_path(crate = crate)]
    enum Events {
        MyEvent1 {
            #[indexed]
            sender: u128,
            #[indexed]
            amount: u128,
            note: String,
        },
        MyEvent2(#[indexed] u128, u128, String),
        MyEvent3,
    }

    #[test]
    fn evm_event_sig() {
        const SIG_TOPIC: [u8; 32] = [
            148, 157, 201, 65, 144, 217, 114, 52, 67, 86, 206, 75, 197, 220, 61, 74, 138, 251, 52,
            61, 243, 110, 252, 93, 62, 91, 109, 51, 209, 107, 68, 200,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(SIG_TOPIC.as_slice(), ev.topics()[0].as_slice());
    }

    #[test]
    fn evm_event_topic_1() {
        const SENDER_TOPIC: [u8; 32] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(SENDER_TOPIC.as_slice(), ev.topics()[1].as_slice());
    }

    #[test]
    fn evm_event_data() {
        const DATA: &[u8] = &[
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 5, 104, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(DATA, ev.data().as_slice());
    }
}
