use super::*;
use ::gstd::errors::Error;
use core::{
    pin::Pin,
    task::{Context, Poll, ready},
};

pub struct SimpleMessageFuture {
    /// A message identifier for an expected reply.
    ///
    /// This identifier is generated by the corresponding send function (e.g.
    /// [`send_bytes`](super::send_bytes)).
    pub waiting_reply_to: MessageId,
    // /// Reply deposit that was allocated for this message. Checked in
    // /// handle_reply.
    // #[cfg_attr(feature = "ethexe", allow(unused))]
    pub reply_deposit: Option<u64>,
}

impl Unpin for SimpleMessageFuture {}

impl Future for SimpleMessageFuture {
    type Output = Result<Vec<u8>, Error>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // let message_id = ::gcore::msg::id();

        // check if message is timed out.
        // if let Some((expected, now)) = async_runtime::locks().is_timeout(msg_id, waiting_reply_to) {
        //     // Remove lock after timeout.
        //     async_runtime::locks().remove(msg_id, waiting_reply_to);

        //     return Poll::Ready(Err(Error::Timeout(expected, now)));
        // }
        let (payload, reply_code) = ready!(poll(&self.waiting_reply_to, cx));
        match reply_code {
            ReplyCode::Success(_) => Poll::Ready(Ok(payload)),
            ReplyCode::Error(reason) => Poll::Ready(Err(Error::ErrorReply(payload.into(), reason))),
            ReplyCode::Unsupported => Poll::Ready(Err(Error::UnsupportedReply(payload))),
        }
    }
}

pub fn send_bytes_for_reply(
    destination: ActorId,
    payload: &[u8],
    value: ValueUnit,
    gas_limit: Option<GasUnit>,
    reply_deposit: Option<GasUnit>,
) -> Result<SimpleMessageFuture, ::gstd::errors::Error> {
    let waiting_reply_to = if let Some(gas_limit) = gas_limit {
        ::gcore::msg::send_with_gas(destination, payload, gas_limit, value).map_err(Error::Core)?
    } else {
        ::gcore::msg::send(destination, payload, value).map_err(Error::Core)?
    };

    if let Some(reply_deposit) = reply_deposit {
        ::gcore::exec::reply_deposit(waiting_reply_to, reply_deposit)?;
    }

    let message_id = ::gcore::msg::id();
    signals().insert(
        waiting_reply_to,
        ReplySignal::Pending {
            message_id,
            // waker: cx.waker().clone(),
        },
    );

    Ok(SimpleMessageFuture {
        waiting_reply_to,
        reply_deposit,
    })
}

enum ReplySignal {
    Pending {
        message_id: MessageId,
        // waker: task::Waker,
    },
    Ready {
        payload: Vec<u8>,
        reply_code: ReplyCode,
    },
}

// fn signals() -> &'static mut crate::collections::BTreeMap<MessageId, ReplySignal> {
//     static mut SIGNALS: crate::collections::BTreeMap<MessageId, ReplySignal> =
//         crate::collections::BTreeMap::new();
//     unsafe { &mut *core::ptr::addr_of_mut!(SIGNALS) }
// }

fn signals() -> &'static mut crate::collections::HashMap<MessageId, ReplySignal> {
    static mut MAP: Option<crate::collections::HashMap<MessageId, ReplySignal>> = None;
    unsafe { &mut *core::ptr::addr_of_mut!(MAP) }
        .get_or_insert_with(crate::collections::HashMap::new)
}

#[inline]
fn poll(reply_to: &MessageId, _cx: &mut Context<'_>) -> Poll<(Vec<u8>, ReplyCode)> {
    let signals_map = signals();
    match signals_map.get(reply_to) {
        Some(ReplySignal::Ready { .. }) => {
            let ReplySignal::Ready {
                payload,
                reply_code,
            } = signals_map.remove(reply_to).unwrap()
            else {
                unreachable!()
            };
            Poll::Ready((payload, reply_code))
        }
        Some(ReplySignal::Pending { .. }) => {
            // waker.clone_from(cx.waker());
            Poll::Pending
        }
        None => panic!(
            "Somebody created a future with the MessageId that never ended in static replies!"
        ),
    }
}

// pub fn register_signal(waiting_reply_to: MessageId) {
//     let message_id = ::gcore::msg::id();

//     // crate::async_runtime::locks().lock(message_id, waiting_reply_to, Default::default());
// }

fn record_reply() {
    let reply_to: MessageId =
        ::gcore::msg::reply_to().expect("`gcore::msg::reply_to()` called in wrong context");
    let signals_map = signals();
    if let Some(ReplySignal::Pending { message_id }) = signals_map.remove(&reply_to) {
        let payload = ::gstd::msg::load_bytes().expect("Failed to load bytes");
        let reply_code =
            ::gcore::msg::reply_code().expect("Shouldn't be called with incorrect context");
        signals_map.insert(
            reply_to,
            ReplySignal::Ready {
                payload,
                reply_code,
            },
        );

        // waker.wake_by_ref();

        ::gcore::exec::wake(message_id).expect("Failed to wake the message");
    } else {
        ::gstd::debug!(
            "A message has received a reply though it wasn't to receive one, or a processed message has received a reply"
        );
    }
}

type PinnedFuture = Pin<Box<dyn Future<Output = ()> + 'static>>;

fn futures() -> &'static mut crate::collections::HashMap<MessageId, PinnedFuture> {
    static mut MAP: Option<crate::collections::HashMap<MessageId, PinnedFuture>> = None;
    unsafe { &mut *core::ptr::addr_of_mut!(MAP) }
        .get_or_insert_with(crate::collections::HashMap::new)
}

pub const SYSTEM_RESERVE: u64 = 10_000_000_000;

/// The main asynchronous message handling loop.
///
/// Gear allows user and program interaction via
/// messages. This function is the entry point to run the asynchronous message
/// processing.
#[inline]
pub fn message_loop<F>(future: F)
where
    F: Future<Output = ()> + 'static,
{
    let msg_id = ::gcore::msg::id();
    let futures_map = futures();
    let completed = {
        let task = futures_map.entry(msg_id).or_insert_with(|| {
            #[cfg(not(feature = "ethexe"))]
            {
                ::gcore::exec::system_reserve_gas(SYSTEM_RESERVE)
                    .expect("Failed to reserve gas for system signal");
            }
            // Task::new(future)
            Box::pin(future)
        });

        // if task.lock_exceeded {
        //     // Futures and locks for the message will be cleaned up by
        //     // the async_runtime::handle_signal function
        //     panic!(
        //         "Message 0x{} has exceeded lock ownership time",
        //         hex::encode(msg_id)
        //     );
        // }

        let mut cx = Context::from_waker(task::Waker::noop());

        ::gstd::debug!("message_loop: polling future for {msg_id}");

        task.as_mut().poll(&mut cx).is_ready()
    };

    if completed {
        futures_map.remove(&msg_id);
        // super::locks().remove_message_entry(msg_id);
        // #[cfg(not(feature = "ethexe"))]
        // let _ = critical::take_hook();
    } else {
        ::gcore::exec::wait_up_to(100);
        // super::locks().wait(msg_id);
    }
}

/// Default reply handler.
pub fn handle_reply_with_hook() {
    record_reply();

    // Execute reply hook (if it was registered)
    // let replied_to =
    //     crate::msg::reply_to().expect("`gstd::handle_reply_with_hook()` called in wrong context");

    // #[cfg(not(feature = "ethexe"))]
    // reply_hooks().execute_and_remove(replied_to);

    // #[cfg(feature = "ethexe")]
    // let _ = replied_to;
}
