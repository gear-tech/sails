use super::*;
use crate::collections::HashMap;
use ::gstd::{BlockNumber, errors::Error};
use core::{
    pin::Pin,
    task::{Context, Poll},
};
use futures::future::FusedFuture;

pub struct MessageFuture {
    /// A message identifier for an expected reply.
    ///
    /// This identifier is generated by the corresponding send function (e.g.
    /// [`send_bytes`](super::send_bytes)).
    pub waiting_reply_to: MessageId,
    // /// Reply deposit that was allocated for this message. Checked in
    // /// handle_reply.
    // #[cfg_attr(feature = "ethexe", allow(unused))]
    pub reply_deposit: Option<u64>,
}

impl Unpin for MessageFuture {}

impl Future for MessageFuture {
    type Output = Result<Vec<u8>, Error>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // let msg_id = ::gcore::msg::id();

        // check if message is timed out.
        // if let Some((expected, now)) = locks().is_timeout(msg_id, self.waiting_reply_to) {
        //     // Remove lock after timeout.
        //     async_runtime::locks().remove(msg_id, self.waiting_reply_to);

        //     return Poll::Ready(Err(Error::Timeout(expected, now)));
        // }

        poll(&self.waiting_reply_to, cx)
        // locks().remove(msg_id, self.waiting_reply_to);
        // match reply_code {
        //     ReplyCode::Success(_) => Poll::Ready(Ok(payload)),
        //     ReplyCode::Error(reason) => Poll::Ready(Err(Error::ErrorReply(payload.into(), reason))),
        //     ReplyCode::Unsupported => Poll::Ready(Err(Error::UnsupportedReply(payload))),
        // }
    }
}

impl FusedFuture for MessageFuture {
    fn is_terminated(&self) -> bool {
        !signals().contains_key(&self.waiting_reply_to)
    }
}

pub fn send_bytes_for_reply(
    destination: ActorId,
    payload: &[u8],
    value: ValueUnit,
    gas_limit: Option<GasUnit>,
    reply_deposit: Option<GasUnit>,
) -> Result<MessageFuture, ::gstd::errors::Error> {
    let waiting_reply_to = if let Some(gas_limit) = gas_limit {
        ::gcore::msg::send_with_gas(destination, payload, gas_limit, value).map_err(Error::Core)?
    } else {
        ::gcore::msg::send(destination, payload, value).map_err(Error::Core)?
    };

    if let Some(reply_deposit) = reply_deposit {
        ::gcore::exec::reply_deposit(waiting_reply_to, reply_deposit)?;
    }

    let message_id = ::gcore::msg::id();
    signals().insert(
        waiting_reply_to,
        ReplySignal::Pending {
            message_id,
            // waker: cx.waker().clone(),
        },
    );
    ::gstd::debug!(
        "send_bytes_for_reply: add lock for reply_to {waiting_reply_to} in message {message_id}"
    );
    tasks()
        .get_mut(&message_id)
        .expect("Message task must exist")
        .reply_to_locks
        .insert(waiting_reply_to, Default::default());

    // locks().lock(message_id, waiting_reply_to, Default::default());

    Ok(MessageFuture {
        waiting_reply_to,
        reply_deposit,
    })
}

enum ReplySignal {
    Pending {
        message_id: MessageId,
        // waker: task::Waker,
    },
    Ready {
        payload: Vec<u8>,
        reply_code: ReplyCode,
    },
    Timeout {
        expected: BlockNumber,
        now: BlockNumber,
    },
}

// fn signals() -> &'static mut crate::collections::BTreeMap<MessageId, ReplySignal> {
//     static mut SIGNALS: crate::collections::BTreeMap<MessageId, ReplySignal> =
//         crate::collections::BTreeMap::new();
//     unsafe { &mut *core::ptr::addr_of_mut!(SIGNALS) }
// }

fn signals() -> &'static mut crate::collections::HashMap<MessageId, ReplySignal> {
    static mut MAP: Option<crate::collections::HashMap<MessageId, ReplySignal>> = None;
    unsafe { &mut *core::ptr::addr_of_mut!(MAP) }
        .get_or_insert_with(crate::collections::HashMap::new)
}

#[inline]
fn poll(reply_to: &MessageId, _cx: &mut Context<'_>) -> Poll<Result<Vec<u8>, Error>> {
    let signals_map = signals();
    match signals_map.get(reply_to) {
        Some(ReplySignal::Pending { .. }) => {
            // waker.clone_from(cx.waker());
            Poll::Pending
        }
        Some(ReplySignal::Ready { .. }) => {
            let ReplySignal::Ready {
                payload,
                reply_code,
            } = signals_map.remove(reply_to).unwrap()
            else {
                unreachable!()
            };
            match reply_code {
                ReplyCode::Success(_) => Poll::Ready(Ok(payload)),
                ReplyCode::Error(reason) => {
                    Poll::Ready(Err(Error::ErrorReply(payload.into(), reason)))
                }
                ReplyCode::Unsupported => Poll::Ready(Err(Error::UnsupportedReply(payload))),
            }
        }
        Some(ReplySignal::Timeout { .. }) => {
            let ReplySignal::Timeout { expected, now } = signals_map.remove(reply_to).unwrap()
            else {
                unreachable!()
            };
            Poll::Ready(Err(Error::Timeout(expected, now)))
        }
        None => panic!(
            "Somebody created a future with the MessageId that never ended in static replies!"
        ),
    }
}

// pub fn register_signal(waiting_reply_to: MessageId) {
//     let message_id = ::gcore::msg::id();

//     // crate::async_runtime::locks().lock(message_id, waiting_reply_to, Default::default());
// }

fn record_reply() {
    let reply_to: MessageId =
        ::gcore::msg::reply_to().expect("`gcore::msg::reply_to()` called in wrong context");
    let signals_map = signals();
    if let Some(ReplySignal::Pending { message_id }) = signals_map.remove(&reply_to) {
        let payload = ::gstd::msg::load_bytes().expect("Failed to load bytes");
        let reply_code =
            ::gcore::msg::reply_code().expect("Shouldn't be called with incorrect context");
        signals_map.insert(
            reply_to,
            ReplySignal::Ready {
                payload,
                reply_code,
            },
        );
        ::gstd::debug!("record_reply: remove lock for reply_to {reply_to} in message {message_id}");
        tasks()
            .get_mut(&message_id)
            .expect("Message task must exist")
            .reply_to_locks
            .remove(&reply_to);

        // waker.wake_by_ref();

        ::gcore::exec::wake(message_id).expect("Failed to wake the message");
    } else {
        ::gstd::debug!(
            "A message has received a reply though it wasn't to receive one, or a processed message has received a reply"
        );
    }
}

type PinnedFuture = Pin<Box<dyn Future<Output = ()> + 'static>>;

/// Matches a task to a some message in order to avoid duplicate execution
/// of code that was running before the program was interrupted by `wait`.
pub struct Task {
    future: PinnedFuture,
    reply_to_locks: HashMap<MessageId, locks::Lock>,
}

impl Task {
    fn new<F>(future: F) -> Self
    where
        F: Future<Output = ()> + 'static,
    {
        Self {
            future: Box::pin(future),
            reply_to_locks: HashMap::new(),
        }
    }

    fn signal_reply_timeout(&mut self, now: BlockNumber) {
        let signals_map = signals();

        self.reply_to_locks
            .extract_if(|_, lock| now >= lock.deadline())
            .for_each(|(reply_to, lock)| {
                if let Some(ReplySignal::Pending { .. }) = signals_map.remove(&reply_to) {
                    signals_map.insert(
                        reply_to,
                        ReplySignal::Timeout {
                            expected: lock.deadline(),
                            now,
                        },
                    );
                }
                ::gstd::debug!(
                    "reply_timeout: remove lock for reply_to {reply_to} in message due to timeout"
                );
            });
    }

    fn wait(&self, now: BlockNumber) {
        self.reply_to_locks
            .values()
            .min_by(|lock1, lock2| lock1.cmp(lock2))
            .expect("Cannot find lock to be waited")
            .wait(now);
    }
}

fn tasks() -> &'static mut crate::collections::HashMap<MessageId, Task> {
    static mut MAP: Option<crate::collections::HashMap<MessageId, Task>> = None;
    unsafe { &mut *core::ptr::addr_of_mut!(MAP) }
        .get_or_insert_with(crate::collections::HashMap::new)
}

pub const SYSTEM_RESERVE: u64 = 10_000_000_000;

/// The main asynchronous message handling loop.
///
/// Gear allows user and program interaction via
/// messages. This function is the entry point to run the asynchronous message
/// processing.
#[inline]
pub fn message_loop<F>(future: F)
where
    F: Future<Output = ()> + 'static,
{
    let msg_id = ::gcore::msg::id();
    let tasks_map = tasks();
    let task = tasks_map.entry(msg_id).or_insert_with(|| {
        #[cfg(not(feature = "ethexe"))]
        {
            ::gcore::exec::system_reserve_gas(SYSTEM_RESERVE)
                .expect("Failed to reserve gas for system signal");
        }
        Task::new(future)
    });

    // Check if any reply has timed out before polling them.
    let current_block = exec::block_height();
    task.signal_reply_timeout(current_block);

    let completed = {
        let mut cx = Context::from_waker(task::Waker::noop());
        ::gstd::debug!("message_loop: polling future for {msg_id}");
        task.future.as_mut().poll(&mut cx).is_ready()
    };

    if completed {
        tasks_map.remove(&msg_id);
        // locks().remove_message_entry(msg_id);
        // #[cfg(not(feature = "ethexe"))]
        // let _ = critical::take_hook();
    } else {
        // ::gcore::exec::wait_up_to(100);
        task.wait(current_block);
    }
}

/// Default reply handler.
pub fn handle_reply_with_hook() {
    record_reply();

    // Execute reply hook (if it was registered)
    // let replied_to =
    //     crate::msg::reply_to().expect("`gstd::handle_reply_with_hook()` called in wrong context");

    // #[cfg(not(feature = "ethexe"))]
    // reply_hooks().execute_and_remove(replied_to);

    // #[cfg(feature = "ethexe")]
    // let _ = replied_to;
}
