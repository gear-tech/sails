use crate::prelude::*;
use alloy_sol_types::{SolType, SolValue, abi::TokenSeq};

#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __emit_eth_event<TEvents>(event: TEvents) -> crate::errors::Result<()>
where
    TEvents: crate::EthEvent,
{
    with_optimized_encode(event, |payload| {
        gstd::msg::send_bytes(crate::solidity::ETH_EVENT_ADDR, payload, 0)?;
        Ok(())
    })
}

#[cfg(target_arch = "wasm32")]
fn with_optimized_encode<T, E: EthEvent>(event: E, f: impl FnOnce(&[u8]) -> T) -> T {
    struct ExternalBufferOutput<'a> {
        buffer: &'a mut [mem::MaybeUninit<u8>],
        offset: usize,
    }

    // use `parity_scale_codec::Output` trait to not add a custom trait
    impl Output for ExternalBufferOutput<'_> {
        fn write(&mut self, bytes: &[u8]) {
            // SAFETY: same as
            // `MaybeUninit::write_slice(&mut self.buffer[self.offset..end_offset], bytes)`.
            // This code transmutes `bytes: &[T]` to `bytes: &[MaybeUninit<T>]`. These types
            // can be safely transmuted since they have the same layout. Then `bytes:
            // &[MaybeUninit<T>]` is written to uninitialized memory via `copy_from_slice`.
            let end_offset = self.offset + bytes.len();
            let this = unsafe { self.buffer.get_unchecked_mut(self.offset..end_offset) };
            this.copy_from_slice(unsafe {
                mem::transmute::<&[u8], &[core::mem::MaybeUninit<u8>]>(bytes)
            });
            self.offset = end_offset;
        }
    }

    let topics = event.topics();
    let data = event.data();
    let size = 1 + topics.len() * 32 + data.len();

    gcore::stack_buffer::with_byte_buffer(size, |buffer| {
        let mut output = ExternalBufferOutput { buffer, offset: 0 };

        // encode topics lenght as u8
        output.write(&[topics.len() as u8]);
        for topic in topics {
            output.write(topic.as_slice());
        }
        output.write(data.as_slice());

        let ExternalBufferOutput { buffer, offset } = output;
        // SAFETY: same as `MaybeUninit::slice_assume_init_ref(&buffer[..offset])`.
        // `ExternalBufferOutput` writes data to uninitialized memory. So we can take
        // slice `&buffer[..offset]` and say that it was initialized earlier
        // because the buffer from `0` to `offset` was initialized.
        let payload = unsafe { &*(&buffer[..offset] as *const _ as *const [u8]) };
        f(payload)
    })
}

pub type EthEventExpo = (
    &'static str, // Event name
    &'static str, // Event parameters types
    [u8; 32],     // Topic hash
);

/// Trait for encoding Ethereum events for the EVM.
///
/// This trait provides a uniform interface to convert an event into the topics and data payload
/// that are used to emit logs in the Ethereum Virtual Machine (EVM). The logs generated by the EVM
/// consist of:
///
/// - **Topics:** An array of 32-byte values. The first topic is always the keccak256 hash of the event
///   signature, while the remaining topics correspond to indexed fields. For dynamic types (as determined
///   by `<T as alloy_sol_types::SolType>::IS_DYNAMIC`), the ABI-encoded value is hashed before being stored.
///   For static types, the ABI-encoded value is left-padded with zeros to 32 bytes.
/// - **Data:** A byte array containing the ABI-encoded non-indexed fields of the event, encoded as a tuple.
///
/// This trait is intended to be used with the `#[derive(EthEvent)]` procedural macro, which automatically
/// implements the trait for your enum-based event definitions.
///
/// # Examples
///
/// Given an event definition:
///
/// ```rust
/// #[derive(EthEvent)]
/// pub enum Events {
///     MyEvent {
///         #[indexed]
///         sender: uint128,
///         amount: uint128,
///         note: String,
///     },
/// }
/// ```
///
/// Calling the methods:
///
/// ```rust
/// let event = Events::MyEvent {
///     sender: 123,
///     amount: 1000,
///     note: "Hello, Ethereum".to_owned(),
/// };
///
/// let topics = event.topics();
/// let data = event.data();
/// ```
///
/// The first topic will be the hash of the event signature (e.g. `"MyEvent(uint128,uint128,String)"`),
/// and additional topics and the data payload will be computed based on the field attributes.
///
/// # Methods
///
/// - `topics()`: Returns a vector of 32-byte topics (`alloy_primitives::B256`) for the event.
/// - `data()`: Returns the ABI-encoded data payload (a `Vec<u8>`) for the non-indexed fields.
pub trait EthEvent {
    /// The signature(s) associated with the event.
    ///
    /// The signature is the event name and its parameter types, e.g. `MyEvent` and `(uint128,uint128,string)`.
    /// The signature is used as the first topic in the log.
    const SIGNATURES: &'static [EthEventExpo];

    /// Returns the topics associated with the event.
    ///
    /// The topics vector includes:
    ///
    /// 1. The keccak256 hash of the event signature as the first topic.
    /// 2. For each indexed field, a topic that is generated based on the field's ABI encoding:
    ///    - For dynamic types, the ABI-encoded value is hashed using keccak256.
    ///    - For static types, the ABI-encoded value is left-padded with zeros to 32 bytes.
    ///
    /// # Returns
    ///
    /// A vector of topics (`alloy_primitives::B256`) that represent the event.
    fn topics(&self) -> Vec<alloy_primitives::B256>;

    /// Returns the ABI-encoded data payload of the event.
    ///
    /// The non-indexed fields of the event are ABI-encoded together as a tuple. If there are no non-indexed
    /// fields, an empty vector is returned.
    ///
    /// # Returns
    ///
    /// A `Vec<u8>` containing the ABI-encoded data of the non-indexed fields.
    fn data(&self) -> Vec<u8>;

    /// Returns the topic hash for a given value.
    fn topic_hash<T: SolValue>(value: &T) -> alloy_primitives::B256 {
        if <T::SolType as SolType>::DYNAMIC {
            alloy_primitives::keccak256(SolValue::abi_encode(value))
        } else {
            let encoded = SolValue::abi_encode(value);
            // Assume ABI encoding gives us a byte vector no longer than 32 bytes.
            let mut topic = [0u8; 32];
            // Right-align (pad on the left) if needed.
            topic[(32 - encoded.len())..].copy_from_slice(&encoded);
            topic.into()
        }
    }

    /// Encodes a sequence of values into a single byte vector.
    #[inline]
    fn encode_sequence<T: SolValue>(value: &T) -> Vec<u8>
    where
        for<'a> <T::SolType as SolType>::Token<'a>: TokenSeq<'a>,
    {
        // this method always allocates `Vec<Word>` and transmutes it to `Vec<u8>`
        // there is no point in using `parity_scale_codec::Output`
        alloy_sol_types::SolValue::abi_encode_sequence(value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::String;
    use gstd::TypeInfo;
    use sails_macros::EthEvent;

    #[allow(unused)]
    #[derive(EthEvent, TypeInfo)]
    #[sails_path(crate = crate)]
    enum Events {
        MyEvent1 {
            #[indexed]
            sender: u128,
            #[indexed]
            amount: u128,
            note: String,
        },
        MyEvent2(#[indexed] u128, u128, String),
        MyEvent3,
    }

    #[test]
    fn eth_event_sig() {
        const SIG_TOPIC: [u8; 32] = [
            148, 157, 201, 65, 144, 217, 114, 52, 67, 86, 206, 75, 197, 220, 61, 74, 138, 251, 52,
            61, 243, 110, 252, 93, 62, 91, 109, 51, 209, 107, 68, 200,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(SIG_TOPIC.as_slice(), ev.topics()[0].as_slice());
    }

    #[test]
    fn eth_event_topic_1() {
        const SENDER_TOPIC: [u8; 32] = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(SENDER_TOPIC.as_slice(), ev.topics()[1].as_slice());
    }

    #[test]
    fn eth_event_data() {
        const DATA: &[u8] = &[
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 5, 104, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        let ev = Events::MyEvent1 {
            sender: 1,
            amount: 2,
            note: "hello".to_string(),
        };
        assert_eq!(DATA, ev.data().as_slice());
    }
}
