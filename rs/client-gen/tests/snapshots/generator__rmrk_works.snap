---
source: rs/client-gen/tests/generator.rs
expression: "gen_client(idl, \"RmrkCatalog\")"
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    String,
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
};
pub struct RmrkCatalogFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> RmrkCatalogFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::RmrkCatalogFactory for RmrkCatalogFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, rmrk_catalog_factory::io::New>::new(self.remoting.clone(), ())
    }
}

pub mod rmrk_catalog_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const IS_ACTIVATION: bool = true;
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
    }
}
pub struct RmrkCatalog<R> {
    remoting: R,
}
impl<R> RmrkCatalog<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::RmrkCatalog for RmrkCatalog<R> {
    type Args = R::Args;
    fn add_equippables(
        &mut self,
        part_id: u32,
        collection_ids: Vec<ActorId>,
    ) -> impl Call<Output = Result<(u32, Vec<ActorId>), Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::AddEquippables>::new(
            self.remoting.clone(),
            (part_id, collection_ids),
        )
    }
    fn add_parts(
        &mut self,
        parts: BTreeMap<u32, Part>,
    ) -> impl Call<Output = Result<BTreeMap<u32, Part>, Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::AddParts>::new(self.remoting.clone(), parts)
    }
    fn remove_equippable(
        &mut self,
        part_id: u32,
        collection_id: ActorId,
    ) -> impl Call<Output = Result<(u32, ActorId), Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::RemoveEquippable>::new(
            self.remoting.clone(),
            (part_id, collection_id),
        )
    }
    fn remove_parts(
        &mut self,
        part_ids: Vec<u32>,
    ) -> impl Call<Output = Result<Vec<u32>, Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::RemoveParts>::new(self.remoting.clone(), part_ids)
    }
    fn reset_equippables(
        &mut self,
        part_id: u32,
    ) -> impl Call<Output = Result<(), Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::ResetEquippables>::new(self.remoting.clone(), part_id)
    }
    fn set_equippables_to_all(
        &mut self,
        part_id: u32,
    ) -> impl Call<Output = Result<(), Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::SetEquippablesToAll>::new(
            self.remoting.clone(),
            part_id,
        )
    }
    fn equippable(
        &self,
        part_id: u32,
        collection_id: ActorId,
    ) -> impl Query<Output = Result<bool, Error>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::Equippable>::new(
            self.remoting.clone(),
            (part_id, collection_id),
        )
    }
    fn part(&self, part_id: u32) -> impl Query<Output = Option<Part>, Args = R::Args> {
        RemotingAction::<_, rmrk_catalog::io::Part>::new(self.remoting.clone(), part_id)
    }
}

pub mod rmrk_catalog {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddEquippables(());
        impl AddEquippables {
            #[allow(dead_code)]
            pub fn encode_call(part_id: u32, collection_ids: Vec<ActorId>) -> Vec<u8> {
                <AddEquippables as ActionIo>::encode_call(&(part_id, collection_ids))
            }
        }
        impl ActionIo for AddEquippables {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 56, 65, 100, 100, 69, 113,
                117, 105, 112, 112, 97, 98, 108, 101, 115,
            ];
            type Params = (u32, Vec<ActorId>);
            type Reply = Result<(u32, Vec<ActorId>), super::Error>;
        }
        pub struct AddParts(());
        impl AddParts {
            #[allow(dead_code)]
            pub fn encode_call(parts: BTreeMap<u32, super::Part>) -> Vec<u8> {
                <AddParts as ActionIo>::encode_call(&parts)
            }
        }
        impl ActionIo for AddParts {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 32, 65, 100, 100, 80, 97,
                114, 116, 115,
            ];
            type Params = BTreeMap<u32, super::Part>;
            type Reply = Result<BTreeMap<u32, super::Part>, super::Error>;
        }
        pub struct RemoveEquippable(());
        impl RemoveEquippable {
            #[allow(dead_code)]
            pub fn encode_call(part_id: u32, collection_id: ActorId) -> Vec<u8> {
                <RemoveEquippable as ActionIo>::encode_call(&(part_id, collection_id))
            }
        }
        impl ActionIo for RemoveEquippable {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 64, 82, 101, 109, 111, 118,
                101, 69, 113, 117, 105, 112, 112, 97, 98, 108, 101,
            ];
            type Params = (u32, ActorId);
            type Reply = Result<(u32, ActorId), super::Error>;
        }
        pub struct RemoveParts(());
        impl RemoveParts {
            #[allow(dead_code)]
            pub fn encode_call(part_ids: Vec<u32>) -> Vec<u8> {
                <RemoveParts as ActionIo>::encode_call(&part_ids)
            }
        }
        impl ActionIo for RemoveParts {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 44, 82, 101, 109, 111, 118,
                101, 80, 97, 114, 116, 115,
            ];
            type Params = Vec<u32>;
            type Reply = Result<Vec<u32>, super::Error>;
        }
        pub struct ResetEquippables(());
        impl ResetEquippables {
            #[allow(dead_code)]
            pub fn encode_call(part_id: u32) -> Vec<u8> {
                <ResetEquippables as ActionIo>::encode_call(&part_id)
            }
        }
        impl ActionIo for ResetEquippables {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 64, 82, 101, 115, 101, 116,
                69, 113, 117, 105, 112, 112, 97, 98, 108, 101, 115,
            ];
            type Params = u32;
            type Reply = Result<(), super::Error>;
        }
        pub struct SetEquippablesToAll(());
        impl SetEquippablesToAll {
            #[allow(dead_code)]
            pub fn encode_call(part_id: u32) -> Vec<u8> {
                <SetEquippablesToAll as ActionIo>::encode_call(&part_id)
            }
        }
        impl ActionIo for SetEquippablesToAll {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 76, 83, 101, 116, 69, 113,
                117, 105, 112, 112, 97, 98, 108, 101, 115, 84, 111, 65, 108, 108,
            ];
            type Params = u32;
            type Reply = Result<(), super::Error>;
        }
        pub struct Equippable(());
        impl Equippable {
            #[allow(dead_code)]
            pub fn encode_call(part_id: u32, collection_id: ActorId) -> Vec<u8> {
                <Equippable as ActionIo>::encode_call(&(part_id, collection_id))
            }
        }
        impl ActionIo for Equippable {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 40, 69, 113, 117, 105, 112,
                112, 97, 98, 108, 101,
            ];
            type Params = (u32, ActorId);
            type Reply = Result<bool, super::Error>;
        }
        pub struct Part(());
        impl Part {
            #[allow(dead_code)]
            pub fn encode_call(part_id: u32) -> Vec<u8> {
                <Part as ActionIo>::encode_call(&part_id)
            }
        }
        impl ActionIo for Part {
            const IS_ACTIVATION: bool = false;
            const ROUTE: &'static [u8] = &[
                44, 82, 109, 114, 107, 67, 97, 116, 97, 108, 111, 103, 16, 80, 97, 114, 116,
            ];
            type Params = u32;
            type Reply = Option<super::Part>;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Error {
    PartIdCantBeZero,
    BadConfig,
    PartAlreadyExists,
    ZeroLengthPassed,
    PartDoesNotExist,
    WrongPartFormat,
    NotAllowedToCall,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Part {
    Fixed(FixedPart),
    Slot(SlotPart),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct FixedPart {
    /// An optional zIndex of base part layer.
    /// specifies the stack order of an element.
    /// An element with greater stack order is always in front of an element with a lower stack order.
    pub z: Option<u32>,
    /// The metadata URI of the part.
    pub metadata_uri: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SlotPart {
    /// Array of whitelisted collections that can be equipped in the given slot. Used with slot parts only.
    pub equippable: Vec<ActorId>,
    /// An optional zIndex of base part layer.
    /// specifies the stack order of an element.
    /// An element with greater stack order is always in front of an element with a lower stack order.
    pub z: Option<u32>,
    /// The metadata URI of the part.
    pub metadata_uri: String,
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait RmrkCatalogFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait RmrkCatalog {
        type Args;
        fn add_equippables(
            &mut self,
            part_id: u32,
            collection_ids: Vec<ActorId>,
        ) -> impl Call<Output = Result<(u32, Vec<ActorId>), Error>, Args = Self::Args>;
        fn add_parts(
            &mut self,
            parts: BTreeMap<u32, Part>,
        ) -> impl Call<Output = Result<BTreeMap<u32, Part>, Error>, Args = Self::Args>;
        fn remove_equippable(
            &mut self,
            part_id: u32,
            collection_id: ActorId,
        ) -> impl Call<Output = Result<(u32, ActorId), Error>, Args = Self::Args>;
        fn remove_parts(
            &mut self,
            part_ids: Vec<u32>,
        ) -> impl Call<Output = Result<Vec<u32>, Error>, Args = Self::Args>;
        fn reset_equippables(
            &mut self,
            part_id: u32,
        ) -> impl Call<Output = Result<(), Error>, Args = Self::Args>;
        fn set_equippables_to_all(
            &mut self,
            part_id: u32,
        ) -> impl Call<Output = Result<(), Error>, Args = Self::Args>;
        fn equippable(
            &self,
            part_id: u32,
            collection_id: ActorId,
        ) -> impl Query<Output = Result<bool, Error>, Args = Self::Args>;
        fn part(&self, part_id: u32) -> impl Query<Output = Option<Part>, Args = Self::Args>;
    }
}

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub RmrkCatalog<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::RmrkCatalog for RmrkCatalog<A> { type Args = A; fn add_equippables (&mut self, part_id: u32,collection_ids: Vec<ActorId>,) -> MockCall<A, Result<(u32,Vec<ActorId>,), Error>>;fn add_parts (&mut self, parts: BTreeMap<u32, Part>,) -> MockCall<A, Result<BTreeMap<u32, Part>, Error>>;fn remove_equippable (&mut self, part_id: u32,collection_id: ActorId,) -> MockCall<A, Result<(u32,ActorId,), Error>>;fn remove_parts (&mut self, part_ids: Vec<u32>,) -> MockCall<A, Result<Vec<u32>, Error>>;fn reset_equippables (&mut self, part_id: u32,) -> MockCall<A, Result<(), Error>>;fn set_equippables_to_all (&mut self, part_id: u32,) -> MockCall<A, Result<(), Error>>;fn equippable (& self, part_id: u32,collection_id: ActorId,) -> MockQuery<A, Result<bool, Error>>;fn part (& self, part_id: u32,) -> MockQuery<A, Option<Part>>; } }
}
