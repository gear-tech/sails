---
source: rs/client-gen/tests/generator.rs
expression: "gen_client(idl, \"RmrkCatalog\")"
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct RmrkCatalogProgram;
impl sails_rs::client::Program for RmrkCatalogProgram {}
pub trait RmrkCatalog {
    type Env: sails_rs::client::GearEnv;
    fn rmrk_catalog(&self) -> sails_rs::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RmrkCatalog for sails_rs::client::Actor<RmrkCatalogProgram, E> {
    type Env = E;
    fn rmrk_catalog(&self) -> sails_rs::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env> {
        self.service(stringify!(RmrkCatalog))
    }
}
pub trait RmrkCatalogCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> sails_rs::client::PendingCtor<RmrkCatalogProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> RmrkCatalogCtors
    for sails_rs::client::Deployment<RmrkCatalogProgram, E>
{
    type Env = E;
    fn new(self) -> sails_rs::client::PendingCtor<RmrkCatalogProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod rmrk_catalog {
    use super::*;
    pub trait RmrkCatalog {
        type Env: sails_rs::client::GearEnv;
        /// !@interface_id = 0x441648d18a3b7366
        /// !@entry_id = 0x0001
        fn add_equippables(
            &mut self,
            part_id: u32,
            collection_ids: Vec<ActorId>,
        ) -> sails_rs::client::PendingCall<io::AddEquippables, Self::Env>;
        /// !@entry_id = 0x0002
        fn add_parts(
            &mut self,
            parts: BTreeMap<u32, Part>,
        ) -> sails_rs::client::PendingCall<io::AddParts, Self::Env>;
        /// !@entry_id = 0x0005
        fn remove_equippable(
            &mut self,
            part_id: u32,
            collection_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveEquippable, Self::Env>;
        /// !@entry_id = 0x0006
        fn remove_parts(
            &mut self,
            part_ids: Vec<u32>,
        ) -> sails_rs::client::PendingCall<io::RemoveParts, Self::Env>;
        /// !@entry_id = 0x0007
        fn reset_equippables(
            &mut self,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::ResetEquippables, Self::Env>;
        /// !@entry_id = 0x0008
        fn set_equippables_to_all(
            &mut self,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::SetEquippablesToAll, Self::Env>;
        /// !@entry_id = 0x0003
        fn equippable(
            &self,
            part_id: u32,
            collection_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::Equippable, Self::Env>;
        /// !@entry_id = 0x0004
        fn part(&self, part_id: u32) -> sails_rs::client::PendingCall<io::Part, Self::Env>;
    }
    pub struct RmrkCatalogImpl;
    impl<E: sails_rs::client::GearEnv> RmrkCatalog for sails_rs::client::Service<RmrkCatalogImpl, E> {
        type Env = E;
        fn add_equippables(
            &mut self,
            part_id: u32,
            collection_ids: Vec<ActorId>,
        ) -> sails_rs::client::PendingCall<io::AddEquippables, Self::Env> {
            self.pending_call((part_id, collection_ids))
        }
        fn add_parts(
            &mut self,
            parts: BTreeMap<u32, Part>,
        ) -> sails_rs::client::PendingCall<io::AddParts, Self::Env> {
            self.pending_call((parts,))
        }
        fn remove_equippable(
            &mut self,
            part_id: u32,
            collection_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveEquippable, Self::Env> {
            self.pending_call((part_id, collection_id))
        }
        fn remove_parts(
            &mut self,
            part_ids: Vec<u32>,
        ) -> sails_rs::client::PendingCall<io::RemoveParts, Self::Env> {
            self.pending_call((part_ids,))
        }
        fn reset_equippables(
            &mut self,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::ResetEquippables, Self::Env> {
            self.pending_call((part_id,))
        }
        fn set_equippables_to_all(
            &mut self,
            part_id: u32,
        ) -> sails_rs::client::PendingCall<io::SetEquippablesToAll, Self::Env> {
            self.pending_call((part_id,))
        }
        fn equippable(
            &self,
            part_id: u32,
            collection_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::Equippable, Self::Env> {
            self.pending_call((part_id, collection_id))
        }
        fn part(&self, part_id: u32) -> sails_rs::client::PendingCall<io::Part, Self::Env> {
            self.pending_call((part_id,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AddEquippables (part_id: u32, collection_ids: Vec<ActorId>) -> Result<(u32,Vec<ActorId>,), super::Error>);
        sails_rs::io_struct_impl!(AddParts (parts: BTreeMap<u32, super::Part>) -> Result<BTreeMap<u32, super::Part>, super::Error>);
        sails_rs::io_struct_impl!(RemoveEquippable (part_id: u32, collection_id: ActorId) -> Result<(u32,ActorId,), super::Error>);
        sails_rs::io_struct_impl!(RemoveParts (part_ids: Vec<u32>) -> Result<Vec<u32>, super::Error>);
        sails_rs::io_struct_impl!(ResetEquippables (part_id: u32) -> Result<(), super::Error>);
        sails_rs::io_struct_impl!(SetEquippablesToAll (part_id: u32) -> Result<(), super::Error>);
        sails_rs::io_struct_impl!(Equippable (part_id: u32, collection_id: ActorId) -> Result<bool, super::Error>);
        sails_rs::io_struct_impl!(Part (part_id: u32) -> Option<super::Part>);
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Error {
    PartIdCantBeZero,
    BadConfig,
    PartAlreadyExists,
    ZeroLengthPassed,
    PartDoesNotExist,
    WrongPartFormat,
    NotAllowedToCall,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Part {
    Fixed(FixedPart),
    Slot(SlotPart),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct FixedPart {
    /// An optional zIndex of base part layer.
    /// specifies the stack order of an element.
    /// An element with greater stack order is always in front of an element with a lower stack order.
    pub z: Option<u32>,
    /// The metadata URI of the part.
    pub metadata_uri: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SlotPart {
    /// Array of whitelisted collections that can be equipped in the given slot. Used with slot parts only.
    pub equippable: Vec<ActorId>,
    /// An optional zIndex of base part layer.
    /// specifies the stack order of an element.
    /// An element with greater stack order is always in front of an element with a lower stack order.
    pub z: Option<u32>,
    /// The metadata URI of the part.
    pub metadata_uri: String,
}

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub RmrkCatalog {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl rmrk_catalog::RmrkCatalog for RmrkCatalog { type Env = sails_rs::client::GstdEnv; fn add_equippables (&mut self, part_id: u32, collection_ids: Vec<ActorId>) -> sails_rs::client::PendingCall<rmrk_catalog::io::AddEquippables, sails_rs::client::GstdEnv>;fn add_parts (&mut self, parts: BTreeMap<u32, Part>) -> sails_rs::client::PendingCall<rmrk_catalog::io::AddParts, sails_rs::client::GstdEnv>;fn remove_equippable (&mut self, part_id: u32, collection_id: ActorId) -> sails_rs::client::PendingCall<rmrk_catalog::io::RemoveEquippable, sails_rs::client::GstdEnv>;fn remove_parts (&mut self, part_ids: Vec<u32>) -> sails_rs::client::PendingCall<rmrk_catalog::io::RemoveParts, sails_rs::client::GstdEnv>;fn reset_equippables (&mut self, part_id: u32) -> sails_rs::client::PendingCall<rmrk_catalog::io::ResetEquippables, sails_rs::client::GstdEnv>;fn set_equippables_to_all (&mut self, part_id: u32) -> sails_rs::client::PendingCall<rmrk_catalog::io::SetEquippablesToAll, sails_rs::client::GstdEnv>;fn equippable (& self, part_id: u32, collection_id: ActorId) -> sails_rs::client::PendingCall<rmrk_catalog::io::Equippable, sails_rs::client::GstdEnv>;fn part (& self, part_id: u32) -> sails_rs::client::PendingCall<rmrk_catalog::io::Part, sails_rs::client::GstdEnv>; } }
}
