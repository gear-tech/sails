---
source: rs/client-gen/tests/generator.rs
expression: "gen_client(idl, \"RmrkCatalog\")"
---
// Code generated by sails-client-gen. DO NOT EDIT.
use sails_rs::{client::*, prelude::*};
pub struct RmrkCatalogProgram;
impl Program for RmrkCatalogProgram {}
pub trait RmrkCatalog {
    type Env: GearEnv;
    fn rmrk_catalog(&self) -> Service<Self::Env, rmrk_catalog::RmrkCatalogImpl>;
}
impl<E: GearEnv> RmrkCatalog for Actor<E, RmrkCatalogProgram> {
    type Env = E;
    fn rmrk_catalog(&self) -> Service<Self::Env, rmrk_catalog::RmrkCatalogImpl> {
        self.service(stringify!(RmrkCatalog))
    }
}
pub trait RmrkCatalogCtors {
    type Env: GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> PendingCtor<Self::Env, RmrkCatalogProgram, io::New>;
}
impl<E: GearEnv> RmrkCatalogCtors for Deployment<E, RmrkCatalogProgram> {
    type Env = E;
    fn new(self) -> PendingCtor<Self::Env, RmrkCatalogProgram, io::New> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod rmrk_catalog {
    use super::*;
    pub trait RmrkCatalog {
        type Env: GearEnv;
        fn add_equippables(
            &mut self,
            part_id: u32,
            collection_ids: Vec<ActorId>,
        ) -> PendingCall<Self::Env, io::AddEquippables>;
        fn add_parts(&mut self, parts: BTreeMap<u32, Part>)
        -> PendingCall<Self::Env, io::AddParts>;
        fn remove_equippable(
            &mut self,
            part_id: u32,
            collection_id: ActorId,
        ) -> PendingCall<Self::Env, io::RemoveEquippable>;
        fn remove_parts(&mut self, part_ids: Vec<u32>) -> PendingCall<Self::Env, io::RemoveParts>;
        fn reset_equippables(
            &mut self,
            part_id: u32,
        ) -> PendingCall<Self::Env, io::ResetEquippables>;
        fn set_equippables_to_all(
            &mut self,
            part_id: u32,
        ) -> PendingCall<Self::Env, io::SetEquippablesToAll>;
        fn equippable(
            &self,
            part_id: u32,
            collection_id: ActorId,
        ) -> PendingCall<Self::Env, io::Equippable>;
        fn part(&self, part_id: u32) -> PendingCall<Self::Env, io::Part>;
    }
    pub struct RmrkCatalogImpl;
    impl<E: GearEnv> RmrkCatalog for Service<E, RmrkCatalogImpl> {
        type Env = E;
        fn add_equippables(
            &mut self,
            part_id: u32,
            collection_ids: Vec<ActorId>,
        ) -> PendingCall<Self::Env, io::AddEquippables> {
            self.pending_call((part_id, collection_ids))
        }
        fn add_parts(
            &mut self,
            parts: BTreeMap<u32, Part>,
        ) -> PendingCall<Self::Env, io::AddParts> {
            self.pending_call((parts,))
        }
        fn remove_equippable(
            &mut self,
            part_id: u32,
            collection_id: ActorId,
        ) -> PendingCall<Self::Env, io::RemoveEquippable> {
            self.pending_call((part_id, collection_id))
        }
        fn remove_parts(&mut self, part_ids: Vec<u32>) -> PendingCall<Self::Env, io::RemoveParts> {
            self.pending_call((part_ids,))
        }
        fn reset_equippables(
            &mut self,
            part_id: u32,
        ) -> PendingCall<Self::Env, io::ResetEquippables> {
            self.pending_call((part_id,))
        }
        fn set_equippables_to_all(
            &mut self,
            part_id: u32,
        ) -> PendingCall<Self::Env, io::SetEquippablesToAll> {
            self.pending_call((part_id,))
        }
        fn equippable(
            &self,
            part_id: u32,
            collection_id: ActorId,
        ) -> PendingCall<Self::Env, io::Equippable> {
            self.pending_call((part_id, collection_id))
        }
        fn part(&self, part_id: u32) -> PendingCall<Self::Env, io::Part> {
            self.pending_call((part_id,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AddEquippables (part_id: u32, collection_ids: Vec<ActorId>) -> Result<(u32,Vec<ActorId>,), super::Error>);
        sails_rs::io_struct_impl!(AddParts (parts: BTreeMap<u32, super::Part>) -> Result<BTreeMap<u32, super::Part>, super::Error>);
        sails_rs::io_struct_impl!(RemoveEquippable (part_id: u32, collection_id: ActorId) -> Result<(u32,ActorId,), super::Error>);
        sails_rs::io_struct_impl!(RemoveParts (part_ids: Vec<u32>) -> Result<Vec<u32>, super::Error>);
        sails_rs::io_struct_impl!(ResetEquippables (part_id: u32) -> Result<(), super::Error>);
        sails_rs::io_struct_impl!(SetEquippablesToAll (part_id: u32) -> Result<(), super::Error>);
        sails_rs::io_struct_impl!(Equippable (part_id: u32, collection_id: ActorId) -> Result<bool, super::Error>);
        sails_rs::io_struct_impl!(Part (part_id: u32) -> Option<super::Part>);
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Error {
    PartIdCantBeZero,
    BadConfig,
    PartAlreadyExists,
    ZeroLengthPassed,
    PartDoesNotExist,
    WrongPartFormat,
    NotAllowedToCall,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Part {
    Fixed(FixedPart),
    Slot(SlotPart),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct FixedPart {
    /// An optional zIndex of base part layer.
    /// specifies the stack order of an element.
    /// An element with greater stack order is always in front of an element with a lower stack order.
    pub z: Option<u32>,
    /// The metadata URI of the part.
    pub metadata_uri: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SlotPart {
    /// Array of whitelisted collections that can be equipped in the given slot. Used with slot parts only.
    pub equippable: Vec<ActorId>,
    /// An optional zIndex of base part layer.
    /// specifies the stack order of an element.
    /// An element with greater stack order is always in front of an element with a lower stack order.
    pub z: Option<u32>,
    /// The metadata URI of the part.
    pub metadata_uri: String,
}

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub RmrkCatalog {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl rmrk_catalog::RmrkCatalog for RmrkCatalog { type Env = GstdEnv; fn add_equippables (&mut self, part_id: u32, collection_ids: Vec<ActorId>) -> PendingCall<GstdEnv, rmrk_catalog::io::AddEquippables>;fn add_parts (&mut self, parts: BTreeMap<u32, Part>) -> PendingCall<GstdEnv, rmrk_catalog::io::AddParts>;fn remove_equippable (&mut self, part_id: u32, collection_id: ActorId) -> PendingCall<GstdEnv, rmrk_catalog::io::RemoveEquippable>;fn remove_parts (&mut self, part_ids: Vec<u32>) -> PendingCall<GstdEnv, rmrk_catalog::io::RemoveParts>;fn reset_equippables (&mut self, part_id: u32) -> PendingCall<GstdEnv, rmrk_catalog::io::ResetEquippables>;fn set_equippables_to_all (&mut self, part_id: u32) -> PendingCall<GstdEnv, rmrk_catalog::io::SetEquippablesToAll>;fn equippable (& self, part_id: u32, collection_id: ActorId) -> PendingCall<GstdEnv, rmrk_catalog::io::Equippable>;fn part (& self, part_id: u32) -> PendingCall<GstdEnv, rmrk_catalog::io::Part>; } }
}
