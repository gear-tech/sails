---
source: rs/client-gen/tests/generator.rs
expression: "gen_client(IDL, \"ComplexTypesProgram\")"
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct ComplexTypesProgramProgram;
impl sails_rs::client::Program for ComplexTypesProgramProgram {}
pub trait ComplexTypesProgram {
    type Env: sails_rs::client::GearEnv;
    fn my_complex_service(
        &self,
    ) -> sails_rs::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env>;
    fn another_service(
        &self,
    ) -> sails_rs::client::Service<another_service::AnotherServiceImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> ComplexTypesProgram
    for sails_rs::client::Actor<ComplexTypesProgramProgram, E>
{
    type Env = E;
    fn my_complex_service(
        &self,
    ) -> sails_rs::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env> {
        self.service(stringify!(MyComplexService))
    }
    fn another_service(
        &self,
    ) -> sails_rs::client::Service<another_service::AnotherServiceImpl, Self::Env> {
        self.service(stringify!(AnotherService))
    }
}
pub trait ComplexTypesProgramCtors {
    type Env: sails_rs::client::GearEnv;
    fn new_program(
        self,
        initial_count: u32,
        id_prefix: String,
    ) -> sails_rs::client::PendingCtor<ComplexTypesProgramProgram, io::NewProgram, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> ComplexTypesProgramCtors
    for sails_rs::client::Deployment<ComplexTypesProgramProgram, E>
{
    type Env = E;
    fn new_program(
        self,
        initial_count: u32,
        id_prefix: String,
    ) -> sails_rs::client::PendingCtor<ComplexTypesProgramProgram, io::NewProgram, Self::Env> {
        self.pending_ctor((initial_count, id_prefix))
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(NewProgram (initial_count: u32, id_prefix: String) -> ());
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ProgramGlobalInfo {
    pub id: ActorId,
    pub config_version: u32,
    pub map_of_data: Vec<(String, ProgramScopedData)>,
    pub optional_value: Option<u64>,
    pub result_status: Result<(u32, bool), ErrorType>,
    pub values_vec: Vec<u8>,
    pub non_zero_id: NonZeroU16,
    pub h256_hash: H256,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ProgramScopedData {
    pub name: String,
    pub value: U256,
    pub sub_id: u32,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ErrorType {
    InvalidInput,
    NotFound(String),
    AccessDenied { id: ActorId, reason: String },
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct GenericData<T, U> {
    pub value_t: T,
    pub value_u: U,
    pub description: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum GenericResult<V> {
    Success(V),
    Failure(ErrorType),
}

pub mod my_complex_service {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct ServiceLocalConfig {
        pub enabled: bool,
        pub retry_count: NonZeroU8,
        pub actor_list: Vec<ActorId>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ServiceStatus {
        Active(ServiceLocalConfig),
        Paused,
        Error(ErrorType),
    }
    pub trait MyComplexService {
        type Env: sails_rs::client::GearEnv;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: NonZeroU32,
        ) -> sails_rs::client::PendingCall<io::Initialize, Self::Env>;
        fn get_data(
            &mut self,
            key: String,
        ) -> sails_rs::client::PendingCall<io::GetData, Self::Env>;
        fn get_info(&self) -> sails_rs::client::PendingCall<io::GetInfo, Self::Env>;
        fn get_actor_ids(
            &self,
            count: u32,
        ) -> sails_rs::client::PendingCall<io::GetActorIds, Self::Env>;
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> sails_rs::client::PendingCall<io::ProcessGenericData, Self::Env>;
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> sails_rs::client::PendingCall<io::UpdateStatus, Self::Env>;
    }
    pub struct MyComplexServiceImpl;
    impl<E: sails_rs::client::GearEnv> MyComplexService
        for sails_rs::client::Service<MyComplexServiceImpl, E>
    {
        type Env = E;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: NonZeroU32,
        ) -> sails_rs::client::PendingCall<io::Initialize, Self::Env> {
            self.pending_call((start_data, max_size))
        }
        fn get_data(
            &mut self,
            key: String,
        ) -> sails_rs::client::PendingCall<io::GetData, Self::Env> {
            self.pending_call((key,))
        }
        fn get_info(&self) -> sails_rs::client::PendingCall<io::GetInfo, Self::Env> {
            self.pending_call(())
        }
        fn get_actor_ids(
            &self,
            count: u32,
        ) -> sails_rs::client::PendingCall<io::GetActorIds, Self::Env> {
            self.pending_call((count,))
        }
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> sails_rs::client::PendingCall<io::ProcessGenericData, Self::Env> {
            self.pending_call((input_data, list_of_generics, optional_generic_result))
        }
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> sails_rs::client::PendingCall<io::UpdateStatus, Self::Env> {
            self.pending_call((id, new_status, metadata))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Initialize (start_data: super::ProgramGlobalInfo, max_size: super::NonZeroU32) -> super::Result<(), super::ErrorType>);
        sails_rs::io_struct_impl!(GetData (key: String) -> super::Result<super::ProgramScopedData, super::ErrorType>);
        sails_rs::io_struct_impl!(GetInfo () -> super::ProgramGlobalInfo);
        sails_rs::io_struct_impl!(GetActorIds (count: u32) -> Vec<ActorId>);
        sails_rs::io_struct_impl!(ProcessGenericData (input_data: super::GenericData<u32, String>, list_of_generics: Vec<super::GenericData<ActorId, U256>>, optional_generic_result: super::Option<super::GenericResult<bool>>) -> super::GenericData<bool, u8>);
        sails_rs::io_struct_impl!(UpdateStatus (id: u64, new_status: super::ServiceStatus, metadata: super::Option<String>) -> super::GenericResult<u32>);
    }
}

pub mod another_service {
    use super::*;
    pub trait AnotherService {
        type Env: sails_rs::client::GearEnv;
        fn ping(&mut self) -> sails_rs::client::PendingCall<io::Ping, Self::Env>;
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> sails_rs::client::PendingCall<io::ProcessValues, Self::Env>;
    }
    pub struct AnotherServiceImpl;
    impl<E: sails_rs::client::GearEnv> AnotherService
        for sails_rs::client::Service<AnotherServiceImpl, E>
    {
        type Env = E;
        fn ping(&mut self) -> sails_rs::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call(())
        }
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> sails_rs::client::PendingCall<io::ProcessValues, Self::Env> {
            self.pending_call((data,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Ping () -> String);
        sails_rs::io_struct_impl!(ProcessValues (data: Vec<U256>) -> super::Result<(), super::ErrorType>);
    }
}

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub MyComplexService {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl my_complex_service::MyComplexService for MyComplexService { type Env = sails_rs::client::GstdEnv; fn initialize (&mut self, start_data: ProgramGlobalInfo, max_size: NonZeroU32) -> sails_rs::client::PendingCall<my_complex_service::io::Initialize, sails_rs::client::GstdEnv>;fn get_data (&mut self, key: String) -> sails_rs::client::PendingCall<my_complex_service::io::GetData, sails_rs::client::GstdEnv>;fn get_info (&self, ) -> sails_rs::client::PendingCall<my_complex_service::io::GetInfo, sails_rs::client::GstdEnv>;fn get_actor_ids (&self, count: u32) -> sails_rs::client::PendingCall<my_complex_service::io::GetActorIds, sails_rs::client::GstdEnv>;fn process_generic_data (&mut self, input_data: GenericData<u32, String>, list_of_generics: Vec<GenericData<ActorId, U256>>, optional_generic_result: Option<GenericResult<bool>>) -> sails_rs::client::PendingCall<my_complex_service::io::ProcessGenericData, sails_rs::client::GstdEnv>;fn update_status (&mut self, id: u64, new_status: ServiceStatus, metadata: Option<String>) -> sails_rs::client::PendingCall<my_complex_service::io::UpdateStatus, sails_rs::client::GstdEnv>; } }
    mock! { pub AnotherService {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl another_service::AnotherService for AnotherService { type Env = sails_rs::client::GstdEnv; fn ping (&mut self, ) -> sails_rs::client::PendingCall<another_service::io::Ping, sails_rs::client::GstdEnv>;fn process_values (&mut self, data: Vec<U256>) -> sails_rs::client::PendingCall<another_service::io::ProcessValues, sails_rs::client::GstdEnv>; } }
}
