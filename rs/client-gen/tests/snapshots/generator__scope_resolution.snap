---
source: rs/client-gen/tests/generator.rs
expression: gen_client(IDL)
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct MyProgramProgram;
impl MyProgramProgram {
    pub const MY_SERVICE_ROUTE_ID: u8 = 1;
}
impl sails_rs::client::Program for MyProgramProgram {}
pub trait MyProgram {
    type Env: sails_rs::client::GearEnv;
    fn my_service(&self) -> sails_rs::client::Service<my_service::MyServiceImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> MyProgram for sails_rs::client::Actor<MyProgramProgram, E> {
    type Env = E;
    fn my_service(&self) -> sails_rs::client::Service<my_service::MyServiceImpl, Self::Env> {
        self.service(MyProgramProgram::MY_SERVICE_ROUTE_ID)
    }
}
pub trait MyProgramCtors {
    type Env: sails_rs::client::GearEnv;
    fn init(self) -> sails_rs::client::PendingCtor<MyProgramProgram, io::Init, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> MyProgramCtors
    for sails_rs::client::Deployment<MyProgramProgram, E>
{
    type Env = E;
    fn init(self) -> sails_rs::client::PendingCtor<MyProgramProgram, io::Init, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(Init () -> (), 0, sails_rs::meta::InterfaceId::zero());
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
#[reflect_hash(crate = sails_rs)]
pub struct CommonType {
    pub program_value: u32,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
#[reflect_hash(crate = sails_rs)]
pub struct ProgramOnlyType {
    pub data: CommonType,
}

pub mod my_service {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub struct CommonType {
        pub service_name: String,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub struct ServiceCommonType {
        pub service_id: u64,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    #[reflect_hash(crate = sails_rs)]
    pub struct ProgramOnlyType {
        pub data: CommonType,
    }
    pub trait MyService {
        type Env: sails_rs::client::GearEnv;
        /// Uses CommonType from service scope.
        fn another_action(
            &mut self,
            input: ServiceCommonType,
        ) -> sails_rs::client::PendingCall<io::AnotherAction, Self::Env>;
        /// Uses CommonType from program scope.
        fn do_something(
            &mut self,
            input: CommonType,
        ) -> sails_rs::client::PendingCall<io::DoSomething, Self::Env>;
        /// TBD: Uses ProgramOnlyType from program scope.
        fn use_program_type(
            &mut self,
            input: ProgramOnlyType,
        ) -> sails_rs::client::PendingCall<io::UseProgramType, Self::Env>;
    }
    pub struct MyServiceImpl;
    impl sails_rs::client::Identifiable for MyServiceImpl {
        const INTERFACE_ID: sails_rs::InterfaceId =
            sails_rs::InterfaceId::from_bytes_8([253, 255, 66, 173, 41, 217, 46, 249]);
    }
    impl<E: sails_rs::client::GearEnv> MyService for sails_rs::client::Service<MyServiceImpl, E> {
        type Env = E;
        fn another_action(
            &mut self,
            input: ServiceCommonType,
        ) -> sails_rs::client::PendingCall<io::AnotherAction, Self::Env> {
            self.pending_call((input,))
        }
        fn do_something(
            &mut self,
            input: CommonType,
        ) -> sails_rs::client::PendingCall<io::DoSomething, Self::Env> {
            self.pending_call((input,))
        }
        fn use_program_type(
            &mut self,
            input: ProgramOnlyType,
        ) -> sails_rs::client::PendingCall<io::UseProgramType, Self::Env> {
            self.pending_call((input,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AnotherAction (input: super::ServiceCommonType) -> u32, 0, <super::MyServiceImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
        sails_rs::io_struct_impl!(DoSomething (input: super::CommonType) -> u32, 1, <super::MyServiceImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
        sails_rs::io_struct_impl!(UseProgramType (input: super::ProgramOnlyType) -> bool, 2, <super::MyServiceImpl as sails_rs::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(feature = "with_mocks")]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod mockall {
        use super::*;
        use sails_rs::mockall::*;
        mock! { pub MyService {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl my_service::MyService for MyService { type Env = sails_rs::client::GstdEnv; fn another_action (&mut self, input: ServiceCommonType) -> sails_rs::client::PendingCall<my_service::io::AnotherAction, sails_rs::client::GstdEnv>;fn do_something (&mut self, input: CommonType) -> sails_rs::client::PendingCall<my_service::io::DoSomething, sails_rs::client::GstdEnv>;fn use_program_type (&mut self, input: ProgramOnlyType) -> sails_rs::client::PendingCall<my_service::io::UseProgramType, sails_rs::client::GstdEnv>; } }
    }
}
