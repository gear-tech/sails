---
source: rs/client-gen/tests/generator.rs
expression: code
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use my_crate::sails::{client::*, collections::*, prelude::*};
pub struct FullCoverageProgramProgram;
impl my_crate::sails::client::Program for FullCoverageProgramProgram {}
pub trait FullCoverageProgram {
    type Env: my_crate::sails::client::GearEnv;
    /// Exported Canvas service
    fn canvas(&self) -> my_crate::sails::client::Service<canvas::CanvasImpl, Self::Env>;
    /// Exported PingPong service
    fn ping_pong(&self) -> my_crate::sails::client::Service<ping_pong::PingPongImpl, Self::Env>;
    /// Exported Counter service
    fn counter(&self) -> my_crate::sails::client::Service<counter::CounterImpl, Self::Env>;
    /// Exported References service
    fn references(&self)
    -> my_crate::sails::client::Service<references::ReferencesImpl, Self::Env>;
    /// Exported ThisThat service
    fn this_that(&self) -> my_crate::sails::client::Service<this_that::ThisThatImpl, Self::Env>;
    /// Exported ValueFee service
    fn value_fee(&self) -> my_crate::sails::client::Service<value_fee::ValueFeeImpl, Self::Env>;
    /// Exported RmrkCatalog service
    fn rmrk_catalog(
        &self,
    ) -> my_crate::sails::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env>;
    /// Exported NonZeroParams service
    fn non_zero_params(
        &self,
    ) -> my_crate::sails::client::Service<non_zero_params::NonZeroParamsImpl, Self::Env>;
    /// Exported ServiceWithEvents service
    fn service_with_events(
        &self,
    ) -> my_crate::sails::client::Service<service_with_events::ServiceWithEventsImpl, Self::Env>;
    /// Exported Basic service
    fn basic(&self) -> my_crate::sails::client::Service<basic::BasicImpl, Self::Env>;
    /// Exported AnotherService service
    fn another_service(
        &self,
    ) -> my_crate::sails::client::Service<another_service::AnotherServiceImpl, Self::Env>;
    /// Exported MyComplexService service
    fn my_complex_service(
        &self,
    ) -> my_crate::sails::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env>;
    fn dog(&self) -> my_crate::sails::client::Service<dog::DogImpl, Self::Env>;
    fn pausable(&self) -> my_crate::sails::client::Service<pausable::PausableImpl, Self::Env>;
    fn ownable(&self) -> my_crate::sails::client::Service<ownable::OwnableImpl, Self::Env>;
    fn tippable(&self) -> my_crate::sails::client::Service<tippable::TippableImpl, Self::Env>;
}
impl<E: my_crate::sails::client::GearEnv> FullCoverageProgram
    for my_crate::sails::client::Actor<FullCoverageProgramProgram, E>
{
    type Env = E;
    fn canvas(&self) -> my_crate::sails::client::Service<canvas::CanvasImpl, Self::Env> {
        self.service(stringify!(Canvas))
    }
    fn ping_pong(&self) -> my_crate::sails::client::Service<ping_pong::PingPongImpl, Self::Env> {
        self.service(stringify!(PingPong))
    }
    fn counter(&self) -> my_crate::sails::client::Service<counter::CounterImpl, Self::Env> {
        self.service(stringify!(Counter))
    }
    fn references(
        &self,
    ) -> my_crate::sails::client::Service<references::ReferencesImpl, Self::Env> {
        self.service(stringify!(References))
    }
    fn this_that(&self) -> my_crate::sails::client::Service<this_that::ThisThatImpl, Self::Env> {
        self.service(stringify!(ThisThat))
    }
    fn value_fee(&self) -> my_crate::sails::client::Service<value_fee::ValueFeeImpl, Self::Env> {
        self.service(stringify!(ValueFee))
    }
    fn rmrk_catalog(
        &self,
    ) -> my_crate::sails::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env> {
        self.service(stringify!(RmrkCatalog))
    }
    fn non_zero_params(
        &self,
    ) -> my_crate::sails::client::Service<non_zero_params::NonZeroParamsImpl, Self::Env> {
        self.service(stringify!(NonZeroParams))
    }
    fn service_with_events(
        &self,
    ) -> my_crate::sails::client::Service<service_with_events::ServiceWithEventsImpl, Self::Env>
    {
        self.service(stringify!(ServiceWithEvents))
    }
    fn basic(&self) -> my_crate::sails::client::Service<basic::BasicImpl, Self::Env> {
        self.service(stringify!(Basic))
    }
    fn another_service(
        &self,
    ) -> my_crate::sails::client::Service<another_service::AnotherServiceImpl, Self::Env> {
        self.service(stringify!(AnotherService))
    }
    fn my_complex_service(
        &self,
    ) -> my_crate::sails::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env> {
        self.service(stringify!(MyComplexService))
    }
    fn dog(&self) -> my_crate::sails::client::Service<dog::DogImpl, Self::Env> {
        self.service(stringify!(Dog))
    }
    fn pausable(&self) -> my_crate::sails::client::Service<pausable::PausableImpl, Self::Env> {
        self.service(stringify!(Pausable))
    }
    fn ownable(&self) -> my_crate::sails::client::Service<ownable::OwnableImpl, Self::Env> {
        self.service(stringify!(Ownable))
    }
    fn tippable(&self) -> my_crate::sails::client::Service<tippable::TippableImpl, Self::Env> {
        self.service(stringify!(Tippable))
    }
}
pub trait FullCoverageProgramCtors {
    type Env: my_crate::sails::client::GearEnv;
    /// Default program constructor
    fn default(
        self,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::Default, Self::Env>;
    /// Constructor with owner and initial config
    fn with_owner(
        self,
        owner: ActorId,
        initial_config: ProgramConfig,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::WithOwner, Self::Env>;
}
impl<E: my_crate::sails::client::GearEnv> FullCoverageProgramCtors
    for my_crate::sails::client::Deployment<FullCoverageProgramProgram, E>
{
    type Env = E;
    fn default(
        self,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::Default, Self::Env>
    {
        self.pending_ctor(())
    }
    fn with_owner(
        self,
        owner: ActorId,
        initial_config: ProgramConfig,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::WithOwner, Self::Env>
    {
        self.pending_ctor((owner, initial_config))
    }
}

pub mod io {
    use super::*;
    my_crate::sails::io_struct_impl!(Default () -> ());
    my_crate::sails::io_struct_impl!(WithOwner (owner: ActorId, initial_config: super::ProgramConfig) -> ());
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
#[reflect_hash(crate = my_crate::sails)]
pub struct ProgramConfig {
    pub initial_value: u32,
    pub admin: ActorId,
    pub is_active: bool,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
#[reflect_hash(crate = my_crate::sails)]
pub enum ProgramError {
    InvalidOwner,
    ConfigError(String),
}

pub mod canvas {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct Point<T> {
        pub x: T,
        pub y: T,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct Color {
        pub color: [u8; 4],
        pub space: ColorSpace,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ColorSpace {
        RGB,
        HSV,
        CMYK,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum PointStatus {
        Colored { author: ActorId, color: Color },
        Dead,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ColorError {
        InvalidSource,
        DeadPoint,
    }
    pub trait Canvas {
        type Env: my_crate::sails::client::GearEnv;
        /// Sets color for the point.
        fn color_point(
            &mut self,
            point: Point<u32>,
            color: Color,
        ) -> my_crate::sails::client::PendingCall<io::ColorPoint, Self::Env>;
        /// Kills the point.
        fn kill_point(
            &mut self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::KillPoint, Self::Env>;
        /// Returns known points.
        fn points(
            &self,
            offset: u32,
            len: u32,
        ) -> my_crate::sails::client::PendingCall<io::Points, Self::Env>;
        /// Returns status set for given point.
        fn point_status(
            &self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::PointStatus, Self::Env>;
        fn ownable(
            &self,
        ) -> my_crate::sails::client::Service<super::ownable::OwnableImpl, Self::Env>;
        fn tippable(
            &self,
        ) -> my_crate::sails::client::Service<super::tippable::TippableImpl, Self::Env>;
        fn pausable(
            &self,
        ) -> my_crate::sails::client::Service<super::pausable::PausableImpl, Self::Env>;
    }
    pub struct CanvasImpl;
    impl<E: my_crate::sails::client::GearEnv> Canvas
        for my_crate::sails::client::Service<CanvasImpl, E>
    {
        type Env = E;
        fn color_point(
            &mut self,
            point: Point<u32>,
            color: Color,
        ) -> my_crate::sails::client::PendingCall<io::ColorPoint, Self::Env> {
            self.pending_call((point, color))
        }
        fn kill_point(
            &mut self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::KillPoint, Self::Env> {
            self.pending_call((point,))
        }
        fn points(
            &self,
            offset: u32,
            len: u32,
        ) -> my_crate::sails::client::PendingCall<io::Points, Self::Env> {
            self.pending_call((offset, len))
        }
        fn point_status(
            &self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::PointStatus, Self::Env> {
            self.pending_call((point,))
        }
        fn ownable(
            &self,
        ) -> my_crate::sails::client::Service<super::ownable::OwnableImpl, Self::Env> {
            self.for_service("Canvas")
        }
        fn tippable(
            &self,
        ) -> my_crate::sails::client::Service<super::tippable::TippableImpl, Self::Env> {
            self.for_service("Canvas")
        }
        fn pausable(
            &self,
        ) -> my_crate::sails::client::Service<super::pausable::PausableImpl, Self::Env> {
            self.for_service("Canvas")
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(ColorPoint (point: super::Point<u32, >, color: super::Color) -> Result<(), super::ColorError>);
        my_crate::sails::io_struct_impl!(KillPoint (point: super::Point<u32, >) -> Result<bool, String>);
        my_crate::sails::io_struct_impl!(Points (offset: u32, len: u32) -> Result<Vec<(super::Point<u32, >, super::PointStatus, )>, String>);
        my_crate::sails::io_struct_impl!(PointStatus (point: super::Point<u32, >) -> super::Option<super::PointStatus, >);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum CanvasEvents {
            StatusChanged(Point<u32>),
            Jubilee {
                /// Amount of alive points.
                amount: u64,
                bits: Vec<u8>,
            },
            E1,
        }
        impl my_crate::sails::client::Event for CanvasEvents {
            const EVENT_NAMES: &'static [Route] = &["StatusChanged", "Jubilee", "E1"];
        }
        impl my_crate::sails::client::ServiceWithEvents for CanvasImpl {
            type Event = CanvasEvents;
        }
    }
}

pub mod ping_pong {
    use super::*;
    pub trait PingPong {
        type Env: my_crate::sails::client::GearEnv;
        fn ping(
            &mut self,
            input: String,
        ) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env>;
    }
    pub struct PingPongImpl;
    impl<E: my_crate::sails::client::GearEnv> PingPong
        for my_crate::sails::client::Service<PingPongImpl, E>
    {
        type Env = E;
        fn ping(
            &mut self,
            input: String,
        ) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call((input,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Ping (input: String) -> Result<String, String>);
    }
}

pub mod counter {
    use super::*;
    pub trait Counter {
        type Env: my_crate::sails::client::GearEnv;
        /// Add a value to the counter
        fn add(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env>;
        /// Substract a value from the counter
        fn sub(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Sub, Self::Env>;
        /// Get the current value
        fn value(&self) -> my_crate::sails::client::PendingCall<io::Value, Self::Env>;
    }
    pub struct CounterImpl;
    impl<E: my_crate::sails::client::GearEnv> Counter
        for my_crate::sails::client::Service<CounterImpl, E>
    {
        type Env = E;
        fn add(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((value,))
        }
        fn sub(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Sub, Self::Env> {
            self.pending_call((value,))
        }
        fn value(&self) -> my_crate::sails::client::PendingCall<io::Value, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Add (value: u32) -> u32);
        my_crate::sails::io_struct_impl!(Sub (value: u32) -> u32);
        my_crate::sails::io_struct_impl!(Value () -> u32);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum CounterEvents {
            /// Emitted when a new value is added to the counter
            Added(u32),
            /// Emitted when a value is subtracted from the counter
            Subtracted(u32),
        }
        impl my_crate::sails::client::Event for CounterEvents {
            const EVENT_NAMES: &'static [Route] = &["Added", "Subtracted"];
        }
        impl my_crate::sails::client::ServiceWithEvents for CounterImpl {
            type Event = CounterEvents;
        }
    }
}

pub mod dog {
    use super::*;
    pub trait Dog {
        type Env: my_crate::sails::client::GearEnv;
        fn make_sound(&mut self) -> my_crate::sails::client::PendingCall<io::MakeSound, Self::Env>;
        fn walk(
            &mut self,
            dx: i32,
            dy: i32,
        ) -> my_crate::sails::client::PendingCall<io::Walk, Self::Env>;
        fn avg_weight(&self) -> my_crate::sails::client::PendingCall<io::AvgWeight, Self::Env>;
        fn position(&self) -> my_crate::sails::client::PendingCall<io::Position, Self::Env>;
    }
    pub struct DogImpl;
    impl<E: my_crate::sails::client::GearEnv> Dog for my_crate::sails::client::Service<DogImpl, E> {
        type Env = E;
        fn make_sound(&mut self) -> my_crate::sails::client::PendingCall<io::MakeSound, Self::Env> {
            self.pending_call(())
        }
        fn walk(
            &mut self,
            dx: i32,
            dy: i32,
        ) -> my_crate::sails::client::PendingCall<io::Walk, Self::Env> {
            self.pending_call((dx, dy))
        }
        fn avg_weight(&self) -> my_crate::sails::client::PendingCall<io::AvgWeight, Self::Env> {
            self.pending_call(())
        }
        fn position(&self) -> my_crate::sails::client::PendingCall<io::Position, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(MakeSound () -> String);
        my_crate::sails::io_struct_impl!(Walk (dx: i32, dy: i32) -> ());
        my_crate::sails::io_struct_impl!(AvgWeight () -> u32);
        my_crate::sails::io_struct_impl!(Position () -> (i32, i32, ));
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum DogEvents {
            Barked,
            Walked { from: (i32, i32), to: (i32, i32) },
        }
        impl my_crate::sails::client::Event for DogEvents {
            const EVENT_NAMES: &'static [Route] = &["Barked", "Walked"];
        }
        impl my_crate::sails::client::ServiceWithEvents for DogImpl {
            type Event = DogEvents;
        }
    }
}

pub mod references {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ReferenceCount(pub u32);
    pub trait References {
        type Env: my_crate::sails::client::GearEnv;
        fn add(&mut self, v: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env>;
        fn add_byte(
            &mut self,
            byte: u8,
        ) -> my_crate::sails::client::PendingCall<io::AddByte, Self::Env>;
        fn guess_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::GuessNum, Self::Env>;
        fn incr(&mut self) -> my_crate::sails::client::PendingCall<io::Incr, Self::Env>;
        fn set_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::SetNum, Self::Env>;
        fn baked(&self) -> my_crate::sails::client::PendingCall<io::Baked, Self::Env>;
        fn last_byte(&self) -> my_crate::sails::client::PendingCall<io::LastByte, Self::Env>;
        fn message(&self) -> my_crate::sails::client::PendingCall<io::Message, Self::Env>;
    }
    pub struct ReferencesImpl;
    impl<E: my_crate::sails::client::GearEnv> References
        for my_crate::sails::client::Service<ReferencesImpl, E>
    {
        type Env = E;
        fn add(&mut self, v: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((v,))
        }
        fn add_byte(
            &mut self,
            byte: u8,
        ) -> my_crate::sails::client::PendingCall<io::AddByte, Self::Env> {
            self.pending_call((byte,))
        }
        fn guess_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::GuessNum, Self::Env> {
            self.pending_call((number,))
        }
        fn incr(&mut self) -> my_crate::sails::client::PendingCall<io::Incr, Self::Env> {
            self.pending_call(())
        }
        fn set_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::SetNum, Self::Env> {
            self.pending_call((number,))
        }
        fn baked(&self) -> my_crate::sails::client::PendingCall<io::Baked, Self::Env> {
            self.pending_call(())
        }
        fn last_byte(&self) -> my_crate::sails::client::PendingCall<io::LastByte, Self::Env> {
            self.pending_call(())
        }
        fn message(&self) -> my_crate::sails::client::PendingCall<io::Message, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Add (v: u32) -> u32);
        my_crate::sails::io_struct_impl!(AddByte (byte: u8) -> Vec<u8>);
        my_crate::sails::io_struct_impl!(GuessNum (number: u8) -> Result<String, String>);
        my_crate::sails::io_struct_impl!(Incr () -> super::ReferenceCount);
        my_crate::sails::io_struct_impl!(SetNum (number: u8) -> Result<(), String>);
        my_crate::sails::io_struct_impl!(Baked () -> String);
        my_crate::sails::io_struct_impl!(LastByte () -> super::Option<u8, >);
        my_crate::sails::io_struct_impl!(Message () -> super::Option<String, >);
    }
}

pub mod this_that {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct DoThatParam {
        pub p1: u32,
        pub p2: ActorId,
        pub p3: ManyVariants,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ManyVariants {
        One,
        Two(u32),
        Three(Option<U256>),
        Four { a: u32, b: Option<u16> },
        Five(String, H256),
        Six((u32,)),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ManyVariantsReply {
        One,
        Two,
        Three,
        Four,
        Five,
        Six,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct TupleStruct(pub bool);
    pub trait ThisThat {
        type Env: my_crate::sails::client::GearEnv;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env>;
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, u8),
            p4: TupleStruct,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
        fn noop(&mut self) -> my_crate::sails::client::PendingCall<io::Noop, Self::Env>;
        fn that(&self) -> my_crate::sails::client::PendingCall<io::That, Self::Env>;
        fn this(&self) -> my_crate::sails::client::PendingCall<io::This, Self::Env>;
    }
    pub struct ThisThatImpl;
    impl<E: my_crate::sails::client::GearEnv> ThisThat
        for my_crate::sails::client::Service<ThisThatImpl, E>
    {
        type Env = E;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((param,))
        }
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, u8),
            p4: TupleStruct,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2, p3, p4))
        }
        fn noop(&mut self) -> my_crate::sails::client::PendingCall<io::Noop, Self::Env> {
            self.pending_call(())
        }
        fn that(&self) -> my_crate::sails::client::PendingCall<io::That, Self::Env> {
            self.pending_call(())
        }
        fn this(&self) -> my_crate::sails::client::PendingCall<io::This, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThat (param: super::DoThatParam) -> Result<(ActorId, u32, super::ManyVariantsReply, ), (String, )>);
        my_crate::sails::io_struct_impl!(DoThis (p1: u32, p2: String, p3: (super::Option<H160, >, u8, ), p4: super::TupleStruct) -> (String, u32, ));
        my_crate::sails::io_struct_impl!(Noop () -> ());
        my_crate::sails::io_struct_impl!(That () -> Result<String, String>);
        my_crate::sails::io_struct_impl!(This () -> u32);
    }
}

pub mod value_fee {
    use super::*;
    pub trait ValueFee {
        type Env: my_crate::sails::client::GearEnv;
        /// Return flag if fee taken and remain value,
        /// using special type `CommandReply<T>`
        fn do_something_and_take_fee(
            &mut self,
        ) -> my_crate::sails::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env>;
    }
    pub struct ValueFeeImpl;
    impl<E: my_crate::sails::client::GearEnv> ValueFee
        for my_crate::sails::client::Service<ValueFeeImpl, E>
    {
        type Env = E;
        fn do_something_and_take_fee(
            &mut self,
        ) -> my_crate::sails::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoSomethingAndTakeFee () -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum ValueFeeEvents {
            Withheld(u128),
        }
        impl my_crate::sails::client::Event for ValueFeeEvents {
            const EVENT_NAMES: &'static [Route] = &["Withheld"];
        }
        impl my_crate::sails::client::ServiceWithEvents for ValueFeeImpl {
            type Event = ValueFeeEvents;
        }
    }
}

pub mod pausable {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct PausedError();
    pub trait Pausable {
        type Env: my_crate::sails::client::GearEnv;
        fn pause(&mut self) -> my_crate::sails::client::PendingCall<io::Pause, Self::Env>;
        fn unpause(&mut self) -> my_crate::sails::client::PendingCall<io::Unpause, Self::Env>;
    }
    pub struct PausableImpl;
    impl<E: my_crate::sails::client::GearEnv> Pausable
        for my_crate::sails::client::Service<PausableImpl, E>
    {
        type Env = E;
        fn pause(&mut self) -> my_crate::sails::client::PendingCall<io::Pause, Self::Env> {
            self.pending_call(())
        }
        fn unpause(&mut self) -> my_crate::sails::client::PendingCall<io::Unpause, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Pause () -> ());
        my_crate::sails::io_struct_impl!(Unpause () -> ());
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum PausableEvents {
            Paused,
            Unpaused,
        }
        impl my_crate::sails::client::Event for PausableEvents {
            const EVENT_NAMES: &'static [Route] = &["Paused", "Unpaused"];
        }
        impl my_crate::sails::client::ServiceWithEvents for PausableImpl {
            type Event = PausableEvents;
        }
    }
}

pub mod ownable {
    use super::*;
    pub trait Ownable {
        type Env: my_crate::sails::client::GearEnv;
        fn get_owner(&mut self) -> my_crate::sails::client::PendingCall<io::GetOwner, Self::Env>;
    }
    pub struct OwnableImpl;
    impl<E: my_crate::sails::client::GearEnv> Ownable
        for my_crate::sails::client::Service<OwnableImpl, E>
    {
        type Env = E;
        fn get_owner(&mut self) -> my_crate::sails::client::PendingCall<io::GetOwner, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(GetOwner () -> ActorId);
    }
}

pub mod tippable {
    use super::*;
    pub trait Tippable {
        type Env: my_crate::sails::client::GearEnv;
        fn tip(&mut self, amount: u128)
        -> my_crate::sails::client::PendingCall<io::Tip, Self::Env>;
    }
    pub struct TippableImpl;
    impl<E: my_crate::sails::client::GearEnv> Tippable
        for my_crate::sails::client::Service<TippableImpl, E>
    {
        type Env = E;
        fn tip(
            &mut self,
            amount: u128,
        ) -> my_crate::sails::client::PendingCall<io::Tip, Self::Env> {
            self.pending_call((amount,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Tip (amount: u128) -> ());
    }
}

pub mod non_zero_params {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct MyParam {
        pub f1: U256,
        pub f2: Vec<u8>,
        pub f3: Option<(u64, U256)>,
    }
    pub trait NonZeroParams {
        type Env: my_crate::sails::client::GearEnv;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
    }
    pub struct NonZeroParamsImpl;
    impl<E: my_crate::sails::client::GearEnv> NonZeroParams
        for my_crate::sails::client::Service<NonZeroParamsImpl, E>
    {
        type Env = E;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThis (p1: U256, p2: super::MyParam) -> u64);
    }
}

pub mod service_with_events {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct MyParam {
        pub f1: U256,
        pub f2: Vec<u8>,
        pub f3: Option<(u64, U256)>,
    }
    pub trait ServiceWithEvents {
        type Env: my_crate::sails::client::GearEnv;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
    }
    pub struct ServiceWithEventsImpl;
    impl<E: my_crate::sails::client::GearEnv> ServiceWithEvents
        for my_crate::sails::client::Service<ServiceWithEventsImpl, E>
    {
        type Env = E;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThis (p1: U256, p2: super::MyParam) -> u64);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum ServiceWithEventsEvents {
            Event1(u32),
            Event2 { field1: String, field2: u64 },
        }
        impl my_crate::sails::client::Event for ServiceWithEventsEvents {
            const EVENT_NAMES: &'static [Route] = &["Event1", "Event2"];
        }
        impl my_crate::sails::client::ServiceWithEvents for ServiceWithEventsImpl {
            type Event = ServiceWithEventsEvents;
        }
    }
}

pub mod basic {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct MyParam {
        pub f1: u32,
        pub f2: Vec<String>,
        pub f3: Option<(u8, u32)>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum MyParam2 {
        Variant1,
        Variant2(u32),
        Variant3(u32),
        Variant4(u8, u32),
        Variant5 { f1: String, f2: Vec<u8> },
    }
    pub trait Basic {
        type Env: my_crate::sails::client::GearEnv;
        fn do_this(
            &mut self,
            p1: u32,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
        fn do_that(
            &mut self,
            p1: (u8, u32),
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env>;
    }
    pub struct BasicImpl;
    impl<E: my_crate::sails::client::GearEnv> Basic for my_crate::sails::client::Service<BasicImpl, E> {
        type Env = E;
        fn do_this(
            &mut self,
            p1: u32,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
        fn do_that(
            &mut self,
            p1: (u8, u32),
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((p1,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThis (p1: u32, p2: super::MyParam) -> u16);
        my_crate::sails::io_struct_impl!(DoThat (p1: (u8, u32, )) -> u8);
    }
}

pub mod another_service {
    use super::*;
    pub trait AnotherService {
        type Env: my_crate::sails::client::GearEnv;
        fn ping(&mut self) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env>;
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessValues, Self::Env>;
    }
    pub struct AnotherServiceImpl;
    impl<E: my_crate::sails::client::GearEnv> AnotherService
        for my_crate::sails::client::Service<AnotherServiceImpl, E>
    {
        type Env = E;
        fn ping(&mut self) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call(())
        }
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessValues, Self::Env> {
            self.pending_call((data,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Ping () -> String);
        my_crate::sails::io_struct_impl!(ProcessValues (data: Vec<U256>) -> Result<(), super::ProgramError>);
    }
}

pub mod my_complex_service {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ProgramGlobalInfo {
        pub id: ActorId,
        pub config_version: u32,
        pub map_of_data: Vec<(String, ProgramScopedData)>,
        pub optional_value: Option<u64>,
        pub result_status: Result<(u32, bool), ProgramError>,
        pub values_vec: Vec<u8>,
        pub non_zero_id: u16,
        pub h256_hash: H256,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ProgramScopedData {
        pub name: String,
        pub value: U256,
        pub sub_id: u32,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ErrorType {
        InvalidInput,
        NotFound(String),
        AccessDenied { id: ActorId, reason: String },
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct GenericData<T, U> {
        pub value_t: T,
        pub value_u: U,
        pub description: String,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum GenericResult<V> {
        Success(V),
        Failure(ProgramError),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ServiceLocalConfig {
        pub enabled: bool,
        pub retry_count: u8,
        pub actor_list: Vec<ActorId>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ServiceStatus {
        Active(ServiceLocalConfig),
        Paused,
        Error(ProgramError),
    }
    pub trait MyComplexService {
        type Env: my_crate::sails::client::GearEnv;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: u32,
        ) -> my_crate::sails::client::PendingCall<io::Initialize, Self::Env>;
        fn get_data(
            &mut self,
            key: String,
        ) -> my_crate::sails::client::PendingCall<io::GetData, Self::Env>;
        fn get_info(&mut self) -> my_crate::sails::client::PendingCall<io::GetInfo, Self::Env>;
        fn get_actor_ids(
            &mut self,
            count: u32,
        ) -> my_crate::sails::client::PendingCall<io::GetActorIds, Self::Env>;
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessGenericData, Self::Env>;
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> my_crate::sails::client::PendingCall<io::UpdateStatus, Self::Env>;
    }
    pub struct MyComplexServiceImpl;
    impl<E: my_crate::sails::client::GearEnv> MyComplexService
        for my_crate::sails::client::Service<MyComplexServiceImpl, E>
    {
        type Env = E;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: u32,
        ) -> my_crate::sails::client::PendingCall<io::Initialize, Self::Env> {
            self.pending_call((start_data, max_size))
        }
        fn get_data(
            &mut self,
            key: String,
        ) -> my_crate::sails::client::PendingCall<io::GetData, Self::Env> {
            self.pending_call((key,))
        }
        fn get_info(&mut self) -> my_crate::sails::client::PendingCall<io::GetInfo, Self::Env> {
            self.pending_call(())
        }
        fn get_actor_ids(
            &mut self,
            count: u32,
        ) -> my_crate::sails::client::PendingCall<io::GetActorIds, Self::Env> {
            self.pending_call((count,))
        }
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessGenericData, Self::Env> {
            self.pending_call((input_data, list_of_generics, optional_generic_result))
        }
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> my_crate::sails::client::PendingCall<io::UpdateStatus, Self::Env> {
            self.pending_call((id, new_status, metadata))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Initialize (start_data: super::ProgramGlobalInfo, max_size: u32) -> Result<(), super::ProgramError>);
        my_crate::sails::io_struct_impl!(GetData (key: String) -> Result<super::ProgramScopedData, super::ProgramError>);
        my_crate::sails::io_struct_impl!(GetInfo () -> super::ProgramGlobalInfo);
        my_crate::sails::io_struct_impl!(GetActorIds (count: u32) -> Vec<ActorId>);
        my_crate::sails::io_struct_impl!(ProcessGenericData (input_data: super::GenericData<u32, String, >, list_of_generics: Vec<super::GenericData<ActorId, U256, >>, optional_generic_result: super::Option<super::GenericResult<bool, >, >) -> super::GenericData<bool, u8, >);
        my_crate::sails::io_struct_impl!(UpdateStatus (id: u64, new_status: super::ServiceStatus, metadata: super::Option<String, >) -> super::GenericResult<u32, >);
    }
}
