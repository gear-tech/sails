---
source: rs/client-gen/tests/generator.rs
expression: code
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use my_crate::sails::{client::*, collections::*, prelude::*};
pub struct FullCoverageProgramProgram;

impl FullCoverageProgramProgram {
    pub const ROUTE_ID_CANVAS: u8 = 1;
    pub const ROUTE_ID_PING_PONG: u8 = 2;
    pub const ROUTE_ID_COUNTER: u8 = 3;
    pub const ROUTE_ID_REFERENCES: u8 = 4;
    pub const ROUTE_ID_THIS_THAT: u8 = 5;
    pub const ROUTE_ID_VALUE_FEE: u8 = 6;
    pub const ROUTE_ID_RMRK_CATALOG: u8 = 7;
    pub const ROUTE_ID_NON_ZERO_PARAMS: u8 = 8;
    pub const ROUTE_ID_SERVICE_WITH_EVENTS: u8 = 9;
    pub const ROUTE_ID_BASIC: u8 = 10;
    pub const ROUTE_ID_ANOTHER_SERVICE: u8 = 11;
    pub const ROUTE_ID_MY_COMPLEX_SERVICE: u8 = 12;
}

impl my_crate::sails::client::Program for FullCoverageProgramProgram {}

pub trait FullCoverageProgram {
    type Env: my_crate::sails::client::GearEnv;
    /// Exported Canvas service
    fn canvas(&self) -> my_crate::sails::client::Service<canvas::CanvasImpl, Self::Env>;
    /// Exported PingPong service
    fn ping_pong(&self) -> my_crate::sails::client::Service<ping_pong::PingPongImpl, Self::Env>;
    /// Exported Counter service
    fn counter(&self) -> my_crate::sails::client::Service<counter::CounterImpl, Self::Env>;
    /// Exported References service
    fn references(&self)
    -> my_crate::sails::client::Service<references::ReferencesImpl, Self::Env>;
    /// Exported ThisThat service
    fn this_that(&self) -> my_crate::sails::client::Service<this_that::ThisThatImpl, Self::Env>;
    /// Exported ValueFee service
    fn value_fee(&self) -> my_crate::sails::client::Service<value_fee::ValueFeeImpl, Self::Env>;
    /// Exported RmrkCatalog service
    fn rmrk_catalog(
        &self,
    ) -> my_crate::sails::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env>;
    /// Exported NonZeroParams service
    fn non_zero_params(
        &self,
    ) -> my_crate::sails::client::Service<non_zero_params::NonZeroParamsImpl, Self::Env>;
    /// Exported ServiceWithEvents service
    fn service_with_events(
        &self,
    ) -> my_crate::sails::client::Service<service_with_events::ServiceWithEventsImpl, Self::Env>;
    /// Exported Basic service
    fn basic(&self) -> my_crate::sails::client::Service<basic::BasicImpl, Self::Env>;
    /// Exported AnotherService service
    fn another_service(
        &self,
    ) -> my_crate::sails::client::Service<another_service::AnotherServiceImpl, Self::Env>;
    /// Exported MyComplexService service
    fn my_complex_service(
        &self,
    ) -> my_crate::sails::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env>;
}

impl<E: my_crate::sails::client::GearEnv> FullCoverageProgram
    for my_crate::sails::client::Actor<FullCoverageProgramProgram, E>
{
    type Env = E;
    fn canvas(&self) -> my_crate::sails::client::Service<canvas::CanvasImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_CANVAS)
    }
    fn ping_pong(&self) -> my_crate::sails::client::Service<ping_pong::PingPongImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_PING_PONG)
    }
    fn counter(&self) -> my_crate::sails::client::Service<counter::CounterImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_COUNTER)
    }
    fn references(
        &self,
    ) -> my_crate::sails::client::Service<references::ReferencesImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_REFERENCES)
    }
    fn this_that(&self) -> my_crate::sails::client::Service<this_that::ThisThatImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_THIS_THAT)
    }
    fn value_fee(&self) -> my_crate::sails::client::Service<value_fee::ValueFeeImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_VALUE_FEE)
    }
    fn rmrk_catalog(
        &self,
    ) -> my_crate::sails::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_RMRK_CATALOG)
    }
    fn non_zero_params(
        &self,
    ) -> my_crate::sails::client::Service<non_zero_params::NonZeroParamsImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_NON_ZERO_PARAMS)
    }
    fn service_with_events(
        &self,
    ) -> my_crate::sails::client::Service<service_with_events::ServiceWithEventsImpl, Self::Env>
    {
        self.service(FullCoverageProgramProgram::ROUTE_ID_SERVICE_WITH_EVENTS)
    }
    fn basic(&self) -> my_crate::sails::client::Service<basic::BasicImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_BASIC)
    }
    fn another_service(
        &self,
    ) -> my_crate::sails::client::Service<another_service::AnotherServiceImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_ANOTHER_SERVICE)
    }
    fn my_complex_service(
        &self,
    ) -> my_crate::sails::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env> {
        self.service(FullCoverageProgramProgram::ROUTE_ID_MY_COMPLEX_SERVICE)
    }
}
pub trait FullCoverageProgramCtors {
    type Env: my_crate::sails::client::GearEnv;
    /// Default program constructor
    fn default(
        self,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::Default, Self::Env>;
    /// Constructor with owner and initial config
    fn with_owner(
        self,
        owner: ActorId,
        initial_config: ProgramConfig,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::WithOwner, Self::Env>;
}

impl<E: my_crate::sails::client::GearEnv> FullCoverageProgramCtors
    for my_crate::sails::client::Deployment<FullCoverageProgramProgram, E>
{
    type Env = E;
    fn default(
        self,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::Default, Self::Env>
    {
        self.pending_ctor(())
    }
    fn with_owner(
        self,
        owner: ActorId,
        initial_config: ProgramConfig,
    ) -> my_crate::sails::client::PendingCtor<FullCoverageProgramProgram, io::WithOwner, Self::Env>
    {
        self.pending_ctor((owner, initial_config))
    }
}

pub mod io {
    use super::*;
    my_crate::sails::io_struct_impl!(Default () -> (), 0);
    my_crate::sails::io_struct_impl!(WithOwner (owner: ActorId, initial_config: super::ProgramConfig) -> (), 1);
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
#[reflect_hash(crate = my_crate::sails)]
pub struct ProgramConfig {
    pub initial_value: u32,
    pub admin: ActorId,
    pub is_active: bool,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
#[reflect_hash(crate = my_crate::sails)]
pub enum ProgramError {
    InvalidOwner,
    ConfigError(String),
}

pub mod canvas {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct Point<T> {
        pub x: T,
        pub y: T,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct Color {
        pub color: [u8; 4],
        pub space: ColorSpace,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ColorSpace {
        RGB,
        HSV,
        CMYK,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum PointStatus {
        Colored { author: ActorId, color: Color },
        Dead,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ColorError {
        InvalidSource,
        DeadPoint,
    }

    pub trait Canvas {
        type Env: my_crate::sails::client::GearEnv;
        /// Sets color for the point.
        fn color_point(
            &mut self,
            point: Point<u32>,
            color: Color,
        ) -> my_crate::sails::client::PendingCall<io::ColorPoint, Self::Env>;
        /// Kills the point.
        fn kill_point(
            &mut self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::KillPoint, Self::Env>;
        /// Returns known points.
        fn points(
            &self,
            offset: u32,
            len: u32,
        ) -> my_crate::sails::client::PendingCall<io::Points, Self::Env>;
        /// Returns status set for given point.
        fn point_status(
            &self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::PointStatus, Self::Env>;
        fn ownable(
            &self,
        ) -> my_crate::sails::client::Service<super::ownable::OwnableImpl, Self::Env>;
        fn pausable(
            &self,
        ) -> my_crate::sails::client::Service<super::pausable::PausableImpl, Self::Env>;
        fn tippable(
            &self,
        ) -> my_crate::sails::client::Service<super::tippable::TippableImpl, Self::Env>;
    }

    pub struct CanvasImpl;

    impl my_crate::sails::client::Identifiable for CanvasImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([159, 96, 48, 64, 97, 141, 24, 70]);
    }

    impl<E: my_crate::sails::client::GearEnv> Canvas
        for my_crate::sails::client::Service<CanvasImpl, E>
    {
        type Env = E;
        fn color_point(
            &mut self,
            point: Point<u32>,
            color: Color,
        ) -> my_crate::sails::client::PendingCall<io::ColorPoint, Self::Env> {
            self.pending_call((point, color))
        }
        fn kill_point(
            &mut self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::KillPoint, Self::Env> {
            self.pending_call((point,))
        }
        fn points(
            &self,
            offset: u32,
            len: u32,
        ) -> my_crate::sails::client::PendingCall<io::Points, Self::Env> {
            self.pending_call((offset, len))
        }
        fn point_status(
            &self,
            point: Point<u32>,
        ) -> my_crate::sails::client::PendingCall<io::PointStatus, Self::Env> {
            self.pending_call((point,))
        }
        fn ownable(
            &self,
        ) -> my_crate::sails::client::Service<super::ownable::OwnableImpl, Self::Env> {
            self.base_service()
        }
        fn pausable(
            &self,
        ) -> my_crate::sails::client::Service<super::pausable::PausableImpl, Self::Env> {
            self.base_service()
        }
        fn tippable(
            &self,
        ) -> my_crate::sails::client::Service<super::tippable::TippableImpl, Self::Env> {
            self.base_service()
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(ColorPoint (point: super::Point<u32, >, color: super::Color) -> super::Result<(), super::ColorError>, 0, <super::CanvasImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(KillPoint (point: super::Point<u32, >) -> super::Result<bool, String>, 1, <super::CanvasImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Points (offset: u32, len: u32) -> super::Result<Vec<(super::Point<u32, >, super::PointStatus, )>, String>, 2, <super::CanvasImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(PointStatus (point: super::Point<u32, >) -> super::Option<super::PointStatus, >, 3, <super::CanvasImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum CanvasEvents {
            #[codec(index = 0)]
            E1,
            #[codec(index = 1)]
            Jubilee {
                /// Amount of alive points.
                amount: u64,
                bits: Vec<u8>,
            },
            #[codec(index = 2)]
            StatusChanged(Point<u32>),
        }

        impl CanvasEvents {
            pub fn entry_id(&self) -> u16 {
                match self {
                    Self::E1 { .. } => 0,
                    Self::Jubilee { .. } => 1,
                    Self::StatusChanged { .. } => 2,
                }
            }
        }

        impl my_crate::sails::client::Event for CanvasEvents {}

        impl my_crate::sails::client::Identifiable for CanvasEvents {
            const INTERFACE_ID: my_crate::sails::InterfaceId =
                <CanvasImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID;
        }

        impl my_crate::sails::client::ServiceWithEvents for CanvasImpl {
            type Event = CanvasEvents;
        }
    }
}

pub mod ping_pong {
    use super::*;

    pub trait PingPong {
        type Env: my_crate::sails::client::GearEnv;
        fn ping(
            &mut self,
            input: String,
        ) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env>;
    }

    pub struct PingPongImpl;

    impl my_crate::sails::client::Identifiable for PingPongImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([33, 189, 154, 154, 165, 29, 162, 100]);
    }

    impl<E: my_crate::sails::client::GearEnv> PingPong
        for my_crate::sails::client::Service<PingPongImpl, E>
    {
        type Env = E;
        fn ping(
            &mut self,
            input: String,
        ) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call((input,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Ping (input: String) -> super::Result<String, String>, 0, <super::PingPongImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod counter {
    use super::*;

    pub trait Counter {
        type Env: my_crate::sails::client::GearEnv;
        /// Add a value to the counter
        fn add(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env>;
        /// Substract a value from the counter
        fn sub(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Sub, Self::Env>;
        /// Get the current value
        fn value(&self) -> my_crate::sails::client::PendingCall<io::Value, Self::Env>;
    }

    pub struct CounterImpl;

    impl my_crate::sails::client::Identifiable for CounterImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([87, 157, 109, 171, 164, 27, 125, 130]);
    }

    impl<E: my_crate::sails::client::GearEnv> Counter
        for my_crate::sails::client::Service<CounterImpl, E>
    {
        type Env = E;
        fn add(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((value,))
        }
        fn sub(&mut self, value: u32) -> my_crate::sails::client::PendingCall<io::Sub, Self::Env> {
            self.pending_call((value,))
        }
        fn value(&self) -> my_crate::sails::client::PendingCall<io::Value, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Add (value: u32) -> u32, 0, <super::CounterImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Sub (value: u32) -> u32, 1, <super::CounterImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Value () -> u32, 2, <super::CounterImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum CounterEvents {
            /// Emitted when a new value is added to the counter
            #[codec(index = 0)]
            Added(u32),
            /// Emitted when a value is subtracted from the counter
            #[codec(index = 1)]
            Subtracted(u32),
        }

        impl CounterEvents {
            pub fn entry_id(&self) -> u16 {
                match self {
                    Self::Added { .. } => 0,
                    Self::Subtracted { .. } => 1,
                }
            }
        }

        impl my_crate::sails::client::Event for CounterEvents {}

        impl my_crate::sails::client::Identifiable for CounterEvents {
            const INTERFACE_ID: my_crate::sails::InterfaceId =
                <CounterImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID;
        }

        impl my_crate::sails::client::ServiceWithEvents for CounterImpl {
            type Event = CounterEvents;
        }
    }
}

pub mod dog {
    use super::*;

    pub trait Dog {
        type Env: my_crate::sails::client::GearEnv;
        fn make_sound(&mut self) -> my_crate::sails::client::PendingCall<io::MakeSound, Self::Env>;
        fn walk(
            &mut self,
            dx: i32,
            dy: i32,
        ) -> my_crate::sails::client::PendingCall<io::Walk, Self::Env>;
        fn avg_weight(&self) -> my_crate::sails::client::PendingCall<io::AvgWeight, Self::Env>;
        fn position(&self) -> my_crate::sails::client::PendingCall<io::Position, Self::Env>;
    }

    pub struct DogImpl;

    impl my_crate::sails::client::Identifiable for DogImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([75, 2, 200, 107, 128, 2, 138, 218]);
    }

    impl<E: my_crate::sails::client::GearEnv> Dog for my_crate::sails::client::Service<DogImpl, E> {
        type Env = E;
        fn make_sound(&mut self) -> my_crate::sails::client::PendingCall<io::MakeSound, Self::Env> {
            self.pending_call(())
        }
        fn walk(
            &mut self,
            dx: i32,
            dy: i32,
        ) -> my_crate::sails::client::PendingCall<io::Walk, Self::Env> {
            self.pending_call((dx, dy))
        }
        fn avg_weight(&self) -> my_crate::sails::client::PendingCall<io::AvgWeight, Self::Env> {
            self.pending_call(())
        }
        fn position(&self) -> my_crate::sails::client::PendingCall<io::Position, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(MakeSound () -> String, 0, <super::DogImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Walk (dx: i32, dy: i32) -> (), 1, <super::DogImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(AvgWeight () -> u32, 2, <super::DogImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Position () -> (i32, i32, ), 3, <super::DogImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum DogEvents {
            #[codec(index = 0)]
            Barked,
            #[codec(index = 1)]
            Walked { from: (i32, i32), to: (i32, i32) },
        }

        impl DogEvents {
            pub fn entry_id(&self) -> u16 {
                match self {
                    Self::Barked { .. } => 0,
                    Self::Walked { .. } => 1,
                }
            }
        }

        impl my_crate::sails::client::Event for DogEvents {}

        impl my_crate::sails::client::Identifiable for DogEvents {
            const INTERFACE_ID: my_crate::sails::InterfaceId =
                <DogImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID;
        }

        impl my_crate::sails::client::ServiceWithEvents for DogImpl {
            type Event = DogEvents;
        }
    }
}

pub mod references {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ReferenceCount(pub u32);

    pub trait References {
        type Env: my_crate::sails::client::GearEnv;
        fn add(&mut self, v: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env>;
        fn add_byte(
            &mut self,
            byte: u8,
        ) -> my_crate::sails::client::PendingCall<io::AddByte, Self::Env>;
        fn guess_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::GuessNum, Self::Env>;
        fn incr(&mut self) -> my_crate::sails::client::PendingCall<io::Incr, Self::Env>;
        fn set_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::SetNum, Self::Env>;
        fn baked(&self) -> my_crate::sails::client::PendingCall<io::Baked, Self::Env>;
        fn last_byte(&self) -> my_crate::sails::client::PendingCall<io::LastByte, Self::Env>;
        fn message(&self) -> my_crate::sails::client::PendingCall<io::Message, Self::Env>;
    }

    pub struct ReferencesImpl;

    impl my_crate::sails::client::Identifiable for ReferencesImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([61, 171, 145, 177, 150, 71, 129, 98]);
    }

    impl<E: my_crate::sails::client::GearEnv> References
        for my_crate::sails::client::Service<ReferencesImpl, E>
    {
        type Env = E;
        fn add(&mut self, v: u32) -> my_crate::sails::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((v,))
        }
        fn add_byte(
            &mut self,
            byte: u8,
        ) -> my_crate::sails::client::PendingCall<io::AddByte, Self::Env> {
            self.pending_call((byte,))
        }
        fn guess_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::GuessNum, Self::Env> {
            self.pending_call((number,))
        }
        fn incr(&mut self) -> my_crate::sails::client::PendingCall<io::Incr, Self::Env> {
            self.pending_call(())
        }
        fn set_num(
            &mut self,
            number: u8,
        ) -> my_crate::sails::client::PendingCall<io::SetNum, Self::Env> {
            self.pending_call((number,))
        }
        fn baked(&self) -> my_crate::sails::client::PendingCall<io::Baked, Self::Env> {
            self.pending_call(())
        }
        fn last_byte(&self) -> my_crate::sails::client::PendingCall<io::LastByte, Self::Env> {
            self.pending_call(())
        }
        fn message(&self) -> my_crate::sails::client::PendingCall<io::Message, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Add (v: u32) -> u32, 0, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(AddByte (byte: u8) -> Vec<u8>, 1, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(GuessNum (number: u8) -> super::Result<String, String>, 2, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Incr () -> super::ReferenceCount, 3, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(SetNum (number: u8) -> super::Result<(), String>, 4, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Baked () -> String, 5, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(LastByte () -> super::Option<u8, >, 6, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Message () -> super::Option<String, >, 7, <super::ReferencesImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod this_that {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct DoThatParam {
        pub p1: u32,
        pub p2: ActorId,
        pub p3: ManyVariants,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ManyVariants {
        One,
        Two(u32),
        Three(Option<U256>),
        Four { a: u32, b: Option<u16> },
        Five(String, H256),
        Six((u32,)),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ManyVariantsReply {
        One,
        Two,
        Three,
        Four,
        Five,
        Six,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct TupleStruct(pub bool);

    pub trait ThisThat {
        type Env: my_crate::sails::client::GearEnv;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env>;
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, u8),
            p4: TupleStruct,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
        fn noop(&mut self) -> my_crate::sails::client::PendingCall<io::Noop, Self::Env>;
        fn that(&self) -> my_crate::sails::client::PendingCall<io::That, Self::Env>;
        fn this(&self) -> my_crate::sails::client::PendingCall<io::This, Self::Env>;
    }

    pub struct ThisThatImpl;

    impl my_crate::sails::client::Identifiable for ThisThatImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([220, 131, 135, 131, 19, 27, 44, 105]);
    }

    impl<E: my_crate::sails::client::GearEnv> ThisThat
        for my_crate::sails::client::Service<ThisThatImpl, E>
    {
        type Env = E;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((param,))
        }
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, u8),
            p4: TupleStruct,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2, p3, p4))
        }
        fn noop(&mut self) -> my_crate::sails::client::PendingCall<io::Noop, Self::Env> {
            self.pending_call(())
        }
        fn that(&self) -> my_crate::sails::client::PendingCall<io::That, Self::Env> {
            self.pending_call(())
        }
        fn this(&self) -> my_crate::sails::client::PendingCall<io::This, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThat (param: super::DoThatParam) -> super::Result<(ActorId, u32, super::ManyVariantsReply, ), (String, )>, 0, <super::ThisThatImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(DoThis (p1: u32, p2: String, p3: (super::Option<H160, >, u8, ), p4: super::TupleStruct) -> (String, u32, ), 1, <super::ThisThatImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Noop () -> (), 2, <super::ThisThatImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(That () -> super::Result<String, String>, 3, <super::ThisThatImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(This () -> u32, 4, <super::ThisThatImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod value_fee {
    use super::*;

    pub trait ValueFee {
        type Env: my_crate::sails::client::GearEnv;
        /// Return flag if fee taken and remain value,
        /// using special type `CommandReply<T>`
        fn do_something_and_take_fee(
            &mut self,
        ) -> my_crate::sails::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env>;
    }

    pub struct ValueFeeImpl;

    impl my_crate::sails::client::Identifiable for ValueFeeImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([65, 193, 8, 11, 78, 30, 141, 197]);
    }

    impl<E: my_crate::sails::client::GearEnv> ValueFee
        for my_crate::sails::client::Service<ValueFeeImpl, E>
    {
        type Env = E;
        fn do_something_and_take_fee(
            &mut self,
        ) -> my_crate::sails::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoSomethingAndTakeFee () -> bool, 0, <super::ValueFeeImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum ValueFeeEvents {
            #[codec(index = 0)]
            Withheld(u128),
        }

        impl ValueFeeEvents {
            pub fn entry_id(&self) -> u16 {
                match self {
                    Self::Withheld { .. } => 0,
                }
            }
        }

        impl my_crate::sails::client::Event for ValueFeeEvents {}

        impl my_crate::sails::client::Identifiable for ValueFeeEvents {
            const INTERFACE_ID: my_crate::sails::InterfaceId =
                <ValueFeeImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID;
        }

        impl my_crate::sails::client::ServiceWithEvents for ValueFeeImpl {
            type Event = ValueFeeEvents;
        }
    }
}

pub mod pausable {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct PausedError();

    pub trait Pausable {
        type Env: my_crate::sails::client::GearEnv;
        fn pause(&mut self) -> my_crate::sails::client::PendingCall<io::Pause, Self::Env>;
        fn unpause(&mut self) -> my_crate::sails::client::PendingCall<io::Unpause, Self::Env>;
    }

    pub struct PausableImpl;

    impl my_crate::sails::client::Identifiable for PausableImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([119, 153, 244, 54, 223, 215, 83, 198]);
    }

    impl<E: my_crate::sails::client::GearEnv> Pausable
        for my_crate::sails::client::Service<PausableImpl, E>
    {
        type Env = E;
        fn pause(&mut self) -> my_crate::sails::client::PendingCall<io::Pause, Self::Env> {
            self.pending_call(())
        }
        fn unpause(&mut self) -> my_crate::sails::client::PendingCall<io::Unpause, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Pause () -> (), 0, <super::PausableImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Unpause () -> (), 1, <super::PausableImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum PausableEvents {
            #[codec(index = 0)]
            Paused,
            #[codec(index = 1)]
            Unpaused,
        }

        impl PausableEvents {
            pub fn entry_id(&self) -> u16 {
                match self {
                    Self::Paused { .. } => 0,
                    Self::Unpaused { .. } => 1,
                }
            }
        }

        impl my_crate::sails::client::Event for PausableEvents {}

        impl my_crate::sails::client::Identifiable for PausableEvents {
            const INTERFACE_ID: my_crate::sails::InterfaceId =
                <PausableImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID;
        }

        impl my_crate::sails::client::ServiceWithEvents for PausableImpl {
            type Event = PausableEvents;
        }
    }
}

pub mod ownable {
    use super::*;

    pub trait Ownable {
        type Env: my_crate::sails::client::GearEnv;
        fn get_owner(&mut self) -> my_crate::sails::client::PendingCall<io::GetOwner, Self::Env>;
    }

    pub struct OwnableImpl;

    impl my_crate::sails::client::Identifiable for OwnableImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([45, 223, 161, 186, 121, 8, 187, 243]);
    }

    impl<E: my_crate::sails::client::GearEnv> Ownable
        for my_crate::sails::client::Service<OwnableImpl, E>
    {
        type Env = E;
        fn get_owner(&mut self) -> my_crate::sails::client::PendingCall<io::GetOwner, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(GetOwner () -> ActorId, 0, <super::OwnableImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod tippable {
    use super::*;

    pub trait Tippable {
        type Env: my_crate::sails::client::GearEnv;
        fn tip(&mut self, amount: u128)
        -> my_crate::sails::client::PendingCall<io::Tip, Self::Env>;
    }

    pub struct TippableImpl;

    impl my_crate::sails::client::Identifiable for TippableImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([237, 182, 209, 207, 204, 160, 182, 70]);
    }

    impl<E: my_crate::sails::client::GearEnv> Tippable
        for my_crate::sails::client::Service<TippableImpl, E>
    {
        type Env = E;
        fn tip(
            &mut self,
            amount: u128,
        ) -> my_crate::sails::client::PendingCall<io::Tip, Self::Env> {
            self.pending_call((amount,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Tip (amount: u128) -> (), 0, <super::TippableImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod non_zero_params {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct MyParam {
        pub f1: U256,
        pub f2: Vec<u8>,
        pub f3: Option<(u64, U256)>,
    }

    pub trait NonZeroParams {
        type Env: my_crate::sails::client::GearEnv;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
    }

    pub struct NonZeroParamsImpl;

    impl my_crate::sails::client::Identifiable for NonZeroParamsImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([247, 238, 3, 214, 44, 137, 30, 3]);
    }

    impl<E: my_crate::sails::client::GearEnv> NonZeroParams
        for my_crate::sails::client::Service<NonZeroParamsImpl, E>
    {
        type Env = E;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThis (p1: U256, p2: super::MyParam) -> u64, 0, <super::NonZeroParamsImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod service_with_events {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct MyParam {
        pub f1: U256,
        pub f2: Vec<u8>,
        pub f3: Option<(u64, U256)>,
    }

    pub trait ServiceWithEvents {
        type Env: my_crate::sails::client::GearEnv;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
    }

    pub struct ServiceWithEventsImpl;

    impl my_crate::sails::client::Identifiable for ServiceWithEventsImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([192, 205, 152, 45, 145, 112, 193, 0]);
    }

    impl<E: my_crate::sails::client::GearEnv> ServiceWithEvents
        for my_crate::sails::client::Service<ServiceWithEventsImpl, E>
    {
        type Env = E;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThis (p1: U256, p2: super::MyParam) -> u64, 0, <super::ServiceWithEventsImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode, ReflectHash)]
        #[codec(crate = my_crate::sails::scale_codec)]
        #[reflect_hash(crate = my_crate::sails)]
        pub enum ServiceWithEventsEvents {
            #[codec(index = 0)]
            Event1(u32),
            #[codec(index = 1)]
            Event2 { field1: String, field2: u64 },
        }

        impl ServiceWithEventsEvents {
            pub fn entry_id(&self) -> u16 {
                match self {
                    Self::Event1 { .. } => 0,
                    Self::Event2 { .. } => 1,
                }
            }
        }

        impl my_crate::sails::client::Event for ServiceWithEventsEvents {}

        impl my_crate::sails::client::Identifiable for ServiceWithEventsEvents {
            const INTERFACE_ID: my_crate::sails::InterfaceId =
                <ServiceWithEventsImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID;
        }

        impl my_crate::sails::client::ServiceWithEvents for ServiceWithEventsImpl {
            type Event = ServiceWithEventsEvents;
        }
    }
}

pub mod basic {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct MyParam {
        pub f1: u32,
        pub f2: Vec<String>,
        pub f3: Option<(u8, u32)>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum MyParam2 {
        Variant1,
        Variant2(u32),
        Variant3(u32),
        Variant4(u8, u32),
        Variant5 { f1: String, f2: Vec<u8> },
    }

    pub trait Basic {
        type Env: my_crate::sails::client::GearEnv;
        fn do_that(
            &mut self,
            p1: (u8, u32),
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env>;
        fn do_this(
            &mut self,
            p1: u32,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env>;
    }

    pub struct BasicImpl;

    impl my_crate::sails::client::Identifiable for BasicImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([82, 241, 49, 169, 231, 31, 0, 230]);
    }

    impl<E: my_crate::sails::client::GearEnv> Basic for my_crate::sails::client::Service<BasicImpl, E> {
        type Env = E;
        fn do_that(
            &mut self,
            p1: (u8, u32),
        ) -> my_crate::sails::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((p1,))
        }
        fn do_this(
            &mut self,
            p1: u32,
            p2: MyParam,
        ) -> my_crate::sails::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThat (p1: (u8, u32, )) -> u8, 0, <super::BasicImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(DoThis (p1: u32, p2: super::MyParam) -> u16, 1, <super::BasicImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod another_service {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ProgramError {
        InvalidOwner,
        ConfigError(String),
    }

    pub trait AnotherService {
        type Env: my_crate::sails::client::GearEnv;
        fn ping(&mut self) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env>;
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessValues, Self::Env>;
    }

    pub struct AnotherServiceImpl;

    impl my_crate::sails::client::Identifiable for AnotherServiceImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([98, 254, 176, 83, 233, 74, 173, 234]);
    }

    impl<E: my_crate::sails::client::GearEnv> AnotherService
        for my_crate::sails::client::Service<AnotherServiceImpl, E>
    {
        type Env = E;
        fn ping(&mut self) -> my_crate::sails::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call(())
        }
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessValues, Self::Env> {
            self.pending_call((data,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Ping () -> String, 0, <super::AnotherServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(ProcessValues (data: Vec<U256>) -> super::Result<(), super::ProgramError>, 1, <super::AnotherServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod my_complex_service {
    use super::*;

    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ProgramGlobalInfo {
        pub id: ActorId,
        pub config_version: u32,
        pub map_of_data: Vec<(String, ProgramScopedData)>,
        pub optional_value: Option<u64>,
        pub result_status: Result<(u32, bool), ProgramError>,
        pub values_vec: Vec<u8>,
        pub non_zero_id: u16,
        pub h256_hash: H256,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ProgramScopedData {
        pub name: String,
        pub value: U256,
        pub sub_id: u32,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ErrorType {
        InvalidInput,
        NotFound(String),
        AccessDenied { id: ActorId, reason: String },
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct GenericData<T, U> {
        pub value_t: T,
        pub value_u: U,
        pub description: String,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum GenericResult<V> {
        Success(V),
        Failure(ProgramError),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub struct ServiceLocalConfig {
        pub enabled: bool,
        pub retry_count: u8,
        pub actor_list: Vec<ActorId>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ServiceStatus {
        Active(ServiceLocalConfig),
        Paused,
        Error(ProgramError),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo, ReflectHash)]
    #[codec(crate = my_crate::sails::scale_codec)]
    #[scale_info(crate = my_crate::sails::scale_info)]
    #[reflect_hash(crate = my_crate::sails)]
    pub enum ProgramError {
        InvalidOwner,
        ConfigError(String),
    }

    pub trait MyComplexService {
        type Env: my_crate::sails::client::GearEnv;
        fn get_actor_ids(
            &mut self,
            count: u32,
        ) -> my_crate::sails::client::PendingCall<io::GetActorIds, Self::Env>;
        fn get_data(
            &mut self,
            key: String,
        ) -> my_crate::sails::client::PendingCall<io::GetData, Self::Env>;
        fn get_info(&mut self) -> my_crate::sails::client::PendingCall<io::GetInfo, Self::Env>;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: u32,
        ) -> my_crate::sails::client::PendingCall<io::Initialize, Self::Env>;
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessGenericData, Self::Env>;
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> my_crate::sails::client::PendingCall<io::UpdateStatus, Self::Env>;
    }

    pub struct MyComplexServiceImpl;

    impl my_crate::sails::client::Identifiable for MyComplexServiceImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([86, 209, 202, 3, 195, 8, 232, 253]);
    }

    impl<E: my_crate::sails::client::GearEnv> MyComplexService
        for my_crate::sails::client::Service<MyComplexServiceImpl, E>
    {
        type Env = E;
        fn get_actor_ids(
            &mut self,
            count: u32,
        ) -> my_crate::sails::client::PendingCall<io::GetActorIds, Self::Env> {
            self.pending_call((count,))
        }
        fn get_data(
            &mut self,
            key: String,
        ) -> my_crate::sails::client::PendingCall<io::GetData, Self::Env> {
            self.pending_call((key,))
        }
        fn get_info(&mut self) -> my_crate::sails::client::PendingCall<io::GetInfo, Self::Env> {
            self.pending_call(())
        }
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: u32,
        ) -> my_crate::sails::client::PendingCall<io::Initialize, Self::Env> {
            self.pending_call((start_data, max_size))
        }
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> my_crate::sails::client::PendingCall<io::ProcessGenericData, Self::Env> {
            self.pending_call((input_data, list_of_generics, optional_generic_result))
        }
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> my_crate::sails::client::PendingCall<io::UpdateStatus, Self::Env> {
            self.pending_call((id, new_status, metadata))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(GetActorIds (count: u32) -> Vec<ActorId>, 0, <super::MyComplexServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(GetData (key: String) -> super::Result<super::ProgramScopedData, super::ProgramError>, 1, <super::MyComplexServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(GetInfo () -> super::ProgramGlobalInfo, 2, <super::MyComplexServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(Initialize (start_data: super::ProgramGlobalInfo, max_size: u32) -> super::Result<(), super::ProgramError>, 3, <super::MyComplexServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(ProcessGenericData (input_data: super::GenericData<u32, String, >, list_of_generics: Vec<super::GenericData<ActorId, U256, >>, optional_generic_result: super::Option<super::GenericResult<bool, >, >) -> super::GenericData<bool, u8, >, 4, <super::MyComplexServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
        my_crate::sails::io_struct_impl!(UpdateStatus (id: u64, new_status: super::ServiceStatus, metadata: super::Option<String, >) -> super::GenericResult<u32, >, 5, <super::MyComplexServiceImpl as my_crate::sails::client::Identifiable>::INTERFACE_ID);
    }
}

pub mod rmrk_catalog {
    use super::*;

    pub trait RmrkCatalog {
        type Env: my_crate::sails::client::GearEnv;
    }

    pub struct RmrkCatalogImpl;

    impl my_crate::sails::client::Identifiable for RmrkCatalogImpl {
        const INTERFACE_ID: my_crate::sails::InterfaceId =
            my_crate::sails::InterfaceId::from_bytes_8([197, 210, 70, 1, 134, 247, 35, 60]);
    }

    impl<E: my_crate::sails::client::GearEnv> RmrkCatalog
        for my_crate::sails::client::Service<RmrkCatalogImpl, E>
    {
        type Env = E;
    }

    pub mod io {
        use super::*;
    }
}
