---
source: rs/client-gen/tests/generator.rs
expression: code
---
// Code generated by sails-client-gen. DO NOT EDIT.
use my_crate::sails::{client::*, prelude::*};
pub struct ServiceProgram;
impl Program for ServiceProgram {}
pub trait Service {
    type Env: GearEnv;
    fn service(&self) -> Service<Self::Env, service::ServiceImpl>;
    fn counter(&self) -> Service<Self::Env, counter::CounterImpl>;
}
impl<E: GearEnv> Service for Actor<E, ServiceProgram> {
    type Env = E;
    fn service(&self) -> Service<Self::Env, service::ServiceImpl> {
        self.service(stringify!(Service))
    }
    fn counter(&self) -> Service<Self::Env, counter::CounterImpl> {
        self.service(stringify!(Counter))
    }
}
pub trait ServiceCtors {
    type Env: GearEnv;
    /// New constructor#[allow(clippy::new_ret_no_self)] #[allow(clippy::wrong_self_convention)]
    fn new(self, a: u32) -> PendingCtor<Self::Env, ServiceProgram, io::New>;
    /// CreateWithData constructor
    fn create_with_data(
        self,
        a: u32,
        b: String,
        c: ThisThatSvcAppManyVariants,
    ) -> PendingCtor<Self::Env, ServiceProgram, io::CreateWithData>;
}
impl<E: GearEnv> ServiceCtors for Deployment<E, ServiceProgram> {
    type Env = E;
    fn new(self, a: u32) -> PendingCtor<Self::Env, ServiceProgram, io::New> {
        self.pending_ctor((a,))
    }
    fn create_with_data(
        self,
        a: u32,
        b: String,
        c: ThisThatSvcAppManyVariants,
    ) -> PendingCtor<Self::Env, ServiceProgram, io::CreateWithData> {
        self.pending_ctor((a, b, c))
    }
}

pub mod io {
    use super::*;
    my_crate::sails::io_struct_impl!(New (a: u32) -> ());
    my_crate::sails::io_struct_impl!(CreateWithData (a: u32, b: String, c: super::ThisThatSvcAppManyVariants) -> ());
}

pub mod service {
    use super::*;
    pub trait Service {
        type Env: GearEnv;
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<String>, u8),
            p4: ThisThatSvcAppTupleStruct,
        ) -> PendingCall<Self::Env, io::DoThis>;
        fn do_that(
            &mut self,
            param: ThisThatSvcAppDoThatParam,
        ) -> PendingCall<Self::Env, io::DoThat>;
        fn this(&self, v1: Vec<u16>) -> PendingCall<Self::Env, io::This>;
        fn that(&self, v1: ()) -> PendingCall<Self::Env, io::That>;
    }
    pub struct ServiceImpl;
    impl<E: GearEnv> Service for Service<E, ServiceImpl> {
        type Env = E;
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<String>, u8),
            p4: ThisThatSvcAppTupleStruct,
        ) -> PendingCall<Self::Env, io::DoThis> {
            self.pending_call((p1, p2, p3, p4))
        }
        fn do_that(
            &mut self,
            param: ThisThatSvcAppDoThatParam,
        ) -> PendingCall<Self::Env, io::DoThat> {
            self.pending_call((param,))
        }
        fn this(&self, v1: Vec<u16>) -> PendingCall<Self::Env, io::This> {
            self.pending_call((v1,))
        }
        fn that(&self, v1: ()) -> PendingCall<Self::Env, io::That> {
            self.pending_call((v1,))
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(DoThis (p1: u32, p2: String, p3: (Option<String>,u8,), p4: super::ThisThatSvcAppTupleStruct) -> (String,u32,));
        my_crate::sails::io_struct_impl!(DoThat (param: super::ThisThatSvcAppDoThatParam) -> Result<(String,u32,), (String,)>);
        my_crate::sails::io_struct_impl!(This (v1: Vec<u16>) -> u32);
        my_crate::sails::io_struct_impl!(That (v1: ()) -> Result<String, String>);
    }
}

pub mod counter {
    use super::*;
    pub trait Counter {
        type Env: GearEnv;
        /// Add a value to the counter
        fn add(&mut self, value: u32) -> PendingCall<Self::Env, io::Add>;
        /// Substract a value from the counter
        fn sub(&mut self, value: u32) -> PendingCall<Self::Env, io::Sub>;
        /// Get the current value
        fn value(&self) -> PendingCall<Self::Env, io::Value>;
    }
    pub struct CounterImpl;
    impl<E: GearEnv> Counter for Service<E, CounterImpl> {
        type Env = E;
        fn add(&mut self, value: u32) -> PendingCall<Self::Env, io::Add> {
            self.pending_call((value,))
        }
        fn sub(&mut self, value: u32) -> PendingCall<Self::Env, io::Sub> {
            self.pending_call((value,))
        }
        fn value(&self) -> PendingCall<Self::Env, io::Value> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        my_crate::sails::io_struct_impl!(Add (value: u32) -> u32);
        my_crate::sails::io_struct_impl!(Sub (value: u32) -> u32);
        my_crate::sails::io_struct_impl!(Value () -> u32);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = my_crate::sails::scale_codec)]
        pub enum CounterEvents {
            /// Emitted when a new value is added to the counter
            Added(u32),
            /// Emitted when a value is subtracted from the counter
            Subtracted(u32),
        }
        impl EventDecode for CounterEvents {
            const EVENT_NAMES: &'static [Route] = &["Added", "Subtracted"];
        }
        impl ServiceEvent for CounterImpl {
            type Event = CounterEvents;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
pub struct ThisThatSvcAppTupleStruct(pub bool);
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
pub struct ThisThatSvcAppDoThatParam {
    pub p1: u32,
    pub p2: String,
    pub p3: ThisThatSvcAppManyVariants,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
pub enum ThisThatSvcAppManyVariants {
    One,
    Two(u32),
    Three(Option<u32>),
    Four { a: u32, b: Option<u16> },
    Five((String, u32)),
    Six((u32,)),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = my_crate::sails::scale_codec)]
#[scale_info(crate = my_crate::sails::scale_info)]
pub enum T {
    One,
}
