---
source: rs/client-gen/tests/generator.rs
expression: "gen_client(IDL, \"FullCoverageProgram\")"
---
// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct FullCoverageProgramProgram;
impl sails_rs::client::Program for FullCoverageProgramProgram {}
pub trait FullCoverageProgram {
    type Env: sails_rs::client::GearEnv;
    /// Exported Canvas service
    fn canvas(&self) -> sails_rs::client::Service<canvas::CanvasImpl, Self::Env>;
    /// Exported PingPong service
    fn ping_pong(&self) -> sails_rs::client::Service<ping_pong::PingPongImpl, Self::Env>;
    /// Exported Counter service
    fn counter(&self) -> sails_rs::client::Service<counter::CounterImpl, Self::Env>;
    /// Exported References service
    fn references(&self) -> sails_rs::client::Service<references::ReferencesImpl, Self::Env>;
    /// Exported ThisThat service
    fn this_that(&self) -> sails_rs::client::Service<this_that::ThisThatImpl, Self::Env>;
    /// Exported ValueFee service
    fn value_fee(&self) -> sails_rs::client::Service<value_fee::ValueFeeImpl, Self::Env>;
    /// Exported RmrkCatalog service
    fn rmrk_catalog(&self) -> sails_rs::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env>;
    /// Exported NonZeroParams service
    fn non_zero_params(
        &self,
    ) -> sails_rs::client::Service<non_zero_params::NonZeroParamsImpl, Self::Env>;
    /// Exported ServiceWithEvents service
    fn service_with_events(
        &self,
    ) -> sails_rs::client::Service<service_with_events::ServiceWithEventsImpl, Self::Env>;
    /// Exported Basic service
    fn basic(&self) -> sails_rs::client::Service<basic::BasicImpl, Self::Env>;
    /// Exported AnotherService service
    fn another_service(
        &self,
    ) -> sails_rs::client::Service<another_service::AnotherServiceImpl, Self::Env>;
    /// Exported MyComplexService service
    fn my_complex_service(
        &self,
    ) -> sails_rs::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env>;
    fn dog(&self) -> sails_rs::client::Service<dog::DogImpl, Self::Env>;
    fn pausable(&self) -> sails_rs::client::Service<pausable::PausableImpl, Self::Env>;
    fn ownable(&self) -> sails_rs::client::Service<ownable::OwnableImpl, Self::Env>;
    fn tippable(&self) -> sails_rs::client::Service<tippable::TippableImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> FullCoverageProgram
    for sails_rs::client::Actor<FullCoverageProgramProgram, E>
{
    type Env = E;
    fn canvas(&self) -> sails_rs::client::Service<canvas::CanvasImpl, Self::Env> {
        self.service(stringify!(Canvas))
    }
    fn ping_pong(&self) -> sails_rs::client::Service<ping_pong::PingPongImpl, Self::Env> {
        self.service(stringify!(PingPong))
    }
    fn counter(&self) -> sails_rs::client::Service<counter::CounterImpl, Self::Env> {
        self.service(stringify!(Counter))
    }
    fn references(&self) -> sails_rs::client::Service<references::ReferencesImpl, Self::Env> {
        self.service(stringify!(References))
    }
    fn this_that(&self) -> sails_rs::client::Service<this_that::ThisThatImpl, Self::Env> {
        self.service(stringify!(ThisThat))
    }
    fn value_fee(&self) -> sails_rs::client::Service<value_fee::ValueFeeImpl, Self::Env> {
        self.service(stringify!(ValueFee))
    }
    fn rmrk_catalog(&self) -> sails_rs::client::Service<rmrk_catalog::RmrkCatalogImpl, Self::Env> {
        self.service(stringify!(RmrkCatalog))
    }
    fn non_zero_params(
        &self,
    ) -> sails_rs::client::Service<non_zero_params::NonZeroParamsImpl, Self::Env> {
        self.service(stringify!(NonZeroParams))
    }
    fn service_with_events(
        &self,
    ) -> sails_rs::client::Service<service_with_events::ServiceWithEventsImpl, Self::Env> {
        self.service(stringify!(ServiceWithEvents))
    }
    fn basic(&self) -> sails_rs::client::Service<basic::BasicImpl, Self::Env> {
        self.service(stringify!(Basic))
    }
    fn another_service(
        &self,
    ) -> sails_rs::client::Service<another_service::AnotherServiceImpl, Self::Env> {
        self.service(stringify!(AnotherService))
    }
    fn my_complex_service(
        &self,
    ) -> sails_rs::client::Service<my_complex_service::MyComplexServiceImpl, Self::Env> {
        self.service(stringify!(MyComplexService))
    }
    fn dog(&self) -> sails_rs::client::Service<dog::DogImpl, Self::Env> {
        self.service(stringify!(Dog))
    }
    fn pausable(&self) -> sails_rs::client::Service<pausable::PausableImpl, Self::Env> {
        self.service(stringify!(Pausable))
    }
    fn ownable(&self) -> sails_rs::client::Service<ownable::OwnableImpl, Self::Env> {
        self.service(stringify!(Ownable))
    }
    fn tippable(&self) -> sails_rs::client::Service<tippable::TippableImpl, Self::Env> {
        self.service(stringify!(Tippable))
    }
}
pub trait FullCoverageProgramCtors {
    type Env: sails_rs::client::GearEnv;
    /// Default program constructor
    fn default(
        self,
    ) -> sails_rs::client::PendingCtor<FullCoverageProgramProgram, io::Default, Self::Env>;
    /// Constructor with owner and initial config
    fn with_owner(
        self,
        owner: ActorId,
        initial_config: ProgramConfig,
    ) -> sails_rs::client::PendingCtor<FullCoverageProgramProgram, io::WithOwner, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> FullCoverageProgramCtors
    for sails_rs::client::Deployment<FullCoverageProgramProgram, E>
{
    type Env = E;
    fn default(
        self,
    ) -> sails_rs::client::PendingCtor<FullCoverageProgramProgram, io::Default, Self::Env> {
        self.pending_ctor(())
    }
    fn with_owner(
        self,
        owner: ActorId,
        initial_config: ProgramConfig,
    ) -> sails_rs::client::PendingCtor<FullCoverageProgramProgram, io::WithOwner, Self::Env> {
        self.pending_ctor((owner, initial_config))
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(Default () -> ());
    sails_rs::io_struct_impl!(WithOwner (owner: ActorId, initial_config: ProgramConfig) -> ());
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct ProgramConfig {
    pub initial_value: u32,
    pub admin: ActorId,
    pub is_active: bool,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ProgramError {
    InvalidOwner,
    ConfigError(String),
}

pub mod canvas {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct Point<T> {
        pub x: T,
        pub y: T,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct Color {
        pub color: [u8; 4],
        pub space: ColorSpace,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ColorSpace {
        RGB,
        HSV,
        CMYK,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum PointStatus {
        Colored { author: ActorId, color: Color },
        Dead,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ColorError {
        InvalidSource,
        DeadPoint,
    }
    pub trait Canvas {
        type Env: sails_rs::client::GearEnv;
        /// Sets color for the point.
        fn color_point(
            &mut self,
            point: Point<u32>,
            color: Color,
        ) -> sails_rs::client::PendingCall<io::ColorPoint, Self::Env>;
        /// Kills the point.
        fn kill_point(
            &mut self,
            point: Point<u32>,
        ) -> sails_rs::client::PendingCall<io::KillPoint, Self::Env>;
        /// Returns known points.
        fn points(
            &self,
            offset: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Points, Self::Env>;
        /// Returns status set for given point.
        fn point_status(
            &self,
            point: Point<u32>,
        ) -> sails_rs::client::PendingCall<io::PointStatus, Self::Env>;
    }
    pub struct CanvasImpl;
    impl<E: sails_rs::client::GearEnv> Canvas for sails_rs::client::Service<CanvasImpl, E> {
        type Env = E;
        fn color_point(
            &mut self,
            point: Point<u32>,
            color: Color,
        ) -> sails_rs::client::PendingCall<io::ColorPoint, Self::Env> {
            self.pending_call((point, color))
        }
        fn kill_point(
            &mut self,
            point: Point<u32>,
        ) -> sails_rs::client::PendingCall<io::KillPoint, Self::Env> {
            self.pending_call((point,))
        }
        fn points(
            &self,
            offset: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Points, Self::Env> {
            self.pending_call((offset, len))
        }
        fn point_status(
            &self,
            point: Point<u32>,
        ) -> sails_rs::client::PendingCall<io::PointStatus, Self::Env> {
            self.pending_call((point,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(ColorPoint (point: Point<u32>, color: Color) -> Result<(), ColorError>);
        sails_rs::io_struct_impl!(KillPoint (point: Point<u32>) -> Result<bool, String>);
        sails_rs::io_struct_impl!(Points (offset: u32, len: u32) -> Result<Vec<(Point<u32>, PointStatus)>, String>);
        sails_rs::io_struct_impl!(PointStatus (point: Point<u32>) -> Option<PointStatus>);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum CanvasEvents {
            StatusChanged(Point<u32>),
            Jubilee {
                /// Amount of alive points.
                amount: u64,
                bits: Vec<u8>,
            },
            E1,
        }
        impl sails_rs::client::Event for CanvasEvents {
            const EVENT_NAMES: &'static [Route] = &["StatusChanged", "Jubilee", "E1"];
        }
        impl sails_rs::client::ServiceWithEvents for CanvasImpl {
            type Event = CanvasEvents;
        }
    }
}

pub mod ping_pong {
    use super::*;
    pub trait PingPong {
        type Env: sails_rs::client::GearEnv;
        fn ping(&mut self, input: String) -> sails_rs::client::PendingCall<io::Ping, Self::Env>;
    }
    pub struct PingPongImpl;
    impl<E: sails_rs::client::GearEnv> PingPong for sails_rs::client::Service<PingPongImpl, E> {
        type Env = E;
        fn ping(&mut self, input: String) -> sails_rs::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call((input,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Ping (input: String) -> Result<String, String>);
    }
}

pub mod counter {
    use super::*;
    pub trait Counter {
        type Env: sails_rs::client::GearEnv;
        /// Add a value to the counter
        fn add(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env>;
        /// Substract a value from the counter
        fn sub(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Sub, Self::Env>;
        /// Get the current value
        fn value(&self) -> sails_rs::client::PendingCall<io::Value, Self::Env>;
    }
    pub struct CounterImpl;
    impl<E: sails_rs::client::GearEnv> Counter for sails_rs::client::Service<CounterImpl, E> {
        type Env = E;
        fn add(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((value,))
        }
        fn sub(&mut self, value: u32) -> sails_rs::client::PendingCall<io::Sub, Self::Env> {
            self.pending_call((value,))
        }
        fn value(&self) -> sails_rs::client::PendingCall<io::Value, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Add (value: u32) -> u32);
        sails_rs::io_struct_impl!(Sub (value: u32) -> u32);
        sails_rs::io_struct_impl!(Value () -> u32);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum CounterEvents {
            /// Emitted when a new value is added to the counter
            Added(u32),
            /// Emitted when a value is subtracted from the counter
            Subtracted(u32),
        }
        impl sails_rs::client::Event for CounterEvents {
            const EVENT_NAMES: &'static [Route] = &["Added", "Subtracted"];
        }
        impl sails_rs::client::ServiceWithEvents for CounterImpl {
            type Event = CounterEvents;
        }
    }
}

pub mod dog {
    use super::*;
    pub trait Dog {
        type Env: sails_rs::client::GearEnv;
        fn make_sound(&mut self) -> sails_rs::client::PendingCall<io::MakeSound, Self::Env>;
        fn walk(&mut self, dx: i32, dy: i32) -> sails_rs::client::PendingCall<io::Walk, Self::Env>;
        fn avg_weight(&self) -> sails_rs::client::PendingCall<io::AvgWeight, Self::Env>;
        fn position(&self) -> sails_rs::client::PendingCall<io::Position, Self::Env>;
    }
    pub struct DogImpl;
    impl<E: sails_rs::client::GearEnv> Dog for sails_rs::client::Service<DogImpl, E> {
        type Env = E;
        fn make_sound(&mut self) -> sails_rs::client::PendingCall<io::MakeSound, Self::Env> {
            self.pending_call(())
        }
        fn walk(&mut self, dx: i32, dy: i32) -> sails_rs::client::PendingCall<io::Walk, Self::Env> {
            self.pending_call((dx, dy))
        }
        fn avg_weight(&self) -> sails_rs::client::PendingCall<io::AvgWeight, Self::Env> {
            self.pending_call(())
        }
        fn position(&self) -> sails_rs::client::PendingCall<io::Position, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(MakeSound () -> String);
        sails_rs::io_struct_impl!(Walk (dx: i32, dy: i32) -> ());
        sails_rs::io_struct_impl!(AvgWeight () -> u32);
        sails_rs::io_struct_impl!(Position () -> (i32, i32));
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum DogEvents {
            Barked,
            Walked { from: (i32, i32), to: (i32, i32) },
        }
        impl sails_rs::client::Event for DogEvents {
            const EVENT_NAMES: &'static [Route] = &["Barked", "Walked"];
        }
        impl sails_rs::client::ServiceWithEvents for DogImpl {
            type Event = DogEvents;
        }
    }
}

pub mod references {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct ReferenceCount(pub u32);
    pub trait References {
        type Env: sails_rs::client::GearEnv;
        fn add(&mut self, v: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env>;
        fn add_byte(&mut self, byte: u8) -> sails_rs::client::PendingCall<io::AddByte, Self::Env>;
        fn guess_num(
            &mut self,
            number: u8,
        ) -> sails_rs::client::PendingCall<io::GuessNum, Self::Env>;
        fn incr(&mut self) -> sails_rs::client::PendingCall<io::Incr, Self::Env>;
        fn set_num(&mut self, number: u8) -> sails_rs::client::PendingCall<io::SetNum, Self::Env>;
        fn baked(&self) -> sails_rs::client::PendingCall<io::Baked, Self::Env>;
        fn last_byte(&self) -> sails_rs::client::PendingCall<io::LastByte, Self::Env>;
        fn message(&self) -> sails_rs::client::PendingCall<io::Message, Self::Env>;
    }
    pub struct ReferencesImpl;
    impl<E: sails_rs::client::GearEnv> References for sails_rs::client::Service<ReferencesImpl, E> {
        type Env = E;
        fn add(&mut self, v: u32) -> sails_rs::client::PendingCall<io::Add, Self::Env> {
            self.pending_call((v,))
        }
        fn add_byte(&mut self, byte: u8) -> sails_rs::client::PendingCall<io::AddByte, Self::Env> {
            self.pending_call((byte,))
        }
        fn guess_num(
            &mut self,
            number: u8,
        ) -> sails_rs::client::PendingCall<io::GuessNum, Self::Env> {
            self.pending_call((number,))
        }
        fn incr(&mut self) -> sails_rs::client::PendingCall<io::Incr, Self::Env> {
            self.pending_call(())
        }
        fn set_num(&mut self, number: u8) -> sails_rs::client::PendingCall<io::SetNum, Self::Env> {
            self.pending_call((number,))
        }
        fn baked(&self) -> sails_rs::client::PendingCall<io::Baked, Self::Env> {
            self.pending_call(())
        }
        fn last_byte(&self) -> sails_rs::client::PendingCall<io::LastByte, Self::Env> {
            self.pending_call(())
        }
        fn message(&self) -> sails_rs::client::PendingCall<io::Message, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Add (v: u32) -> u32);
        sails_rs::io_struct_impl!(AddByte (byte: u8) -> Vec<u8>);
        sails_rs::io_struct_impl!(GuessNum (number: u8) -> Result<String, String>);
        sails_rs::io_struct_impl!(Incr () -> ReferenceCount);
        sails_rs::io_struct_impl!(SetNum (number: u8) -> Result<(), String>);
        sails_rs::io_struct_impl!(Baked () -> String);
        sails_rs::io_struct_impl!(LastByte () -> Option<u8>);
        sails_rs::io_struct_impl!(Message () -> Option<String>);
    }
}

pub mod this_that {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct DoThatParam {
        pub p1: u32,
        pub p2: ActorId,
        pub p3: ManyVariants,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ManyVariants {
        One,
        Two(u32),
        Three(Option<U256>),
        Four { a: u32, b: Option<u16> },
        Five(String, H256),
        Six((u32,)),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ManyVariantsReply {
        One,
        Two,
        Three,
        Four,
        Five,
        Six,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct TupleStruct(pub bool);
    pub trait ThisThat {
        type Env: sails_rs::client::GearEnv;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> sails_rs::client::PendingCall<io::DoThat, Self::Env>;
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, u8),
            p4: TupleStruct,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env>;
        fn noop(&mut self) -> sails_rs::client::PendingCall<io::Noop, Self::Env>;
        fn that(&self) -> sails_rs::client::PendingCall<io::That, Self::Env>;
        fn this(&self) -> sails_rs::client::PendingCall<io::This, Self::Env>;
    }
    pub struct ThisThatImpl;
    impl<E: sails_rs::client::GearEnv> ThisThat for sails_rs::client::Service<ThisThatImpl, E> {
        type Env = E;
        fn do_that(
            &mut self,
            param: DoThatParam,
        ) -> sails_rs::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((param,))
        }
        fn do_this(
            &mut self,
            p1: u32,
            p2: String,
            p3: (Option<H160>, u8),
            p4: TupleStruct,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2, p3, p4))
        }
        fn noop(&mut self) -> sails_rs::client::PendingCall<io::Noop, Self::Env> {
            self.pending_call(())
        }
        fn that(&self) -> sails_rs::client::PendingCall<io::That, Self::Env> {
            self.pending_call(())
        }
        fn this(&self) -> sails_rs::client::PendingCall<io::This, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoThat (param: DoThatParam) -> Result<(ActorId, u32, ManyVariantsReply), (String,)>);
        sails_rs::io_struct_impl!(DoThis (p1: u32, p2: String, p3: (Option<H160>, u8), p4: TupleStruct) -> (String, u32));
        sails_rs::io_struct_impl!(Noop () -> ());
        sails_rs::io_struct_impl!(That () -> Result<String, String>);
        sails_rs::io_struct_impl!(This () -> u32);
    }
}

pub mod value_fee {
    use super::*;
    pub trait ValueFee {
        type Env: sails_rs::client::GearEnv;
        /// Return flag if fee taken and remain value,
        /// using special type `CommandReply<T>`
        fn do_something_and_take_fee(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env>;
    }
    pub struct ValueFeeImpl;
    impl<E: sails_rs::client::GearEnv> ValueFee for sails_rs::client::Service<ValueFeeImpl, E> {
        type Env = E;
        fn do_something_and_take_fee(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::DoSomethingAndTakeFee, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoSomethingAndTakeFee () -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum ValueFeeEvents {
            Withheld(u128),
        }
        impl sails_rs::client::Event for ValueFeeEvents {
            const EVENT_NAMES: &'static [Route] = &["Withheld"];
        }
        impl sails_rs::client::ServiceWithEvents for ValueFeeImpl {
            type Event = ValueFeeEvents;
        }
    }
}

pub mod pausable {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct PausedError();
    pub trait Pausable {
        type Env: sails_rs::client::GearEnv;
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env>;
        fn unpause(&mut self) -> sails_rs::client::PendingCall<io::Unpause, Self::Env>;
    }
    pub struct PausableImpl;
    impl<E: sails_rs::client::GearEnv> Pausable for sails_rs::client::Service<PausableImpl, E> {
        type Env = E;
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env> {
            self.pending_call(())
        }
        fn unpause(&mut self) -> sails_rs::client::PendingCall<io::Unpause, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Pause () -> ());
        sails_rs::io_struct_impl!(Unpause () -> ());
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum PausableEvents {
            Paused,
            Unpaused,
        }
        impl sails_rs::client::Event for PausableEvents {
            const EVENT_NAMES: &'static [Route] = &["Paused", "Unpaused"];
        }
        impl sails_rs::client::ServiceWithEvents for PausableImpl {
            type Event = PausableEvents;
        }
    }
}

pub mod ownable {
    use super::*;
    pub trait Ownable {
        type Env: sails_rs::client::GearEnv;
        fn get_owner(&mut self) -> sails_rs::client::PendingCall<io::GetOwner, Self::Env>;
    }
    pub struct OwnableImpl;
    impl<E: sails_rs::client::GearEnv> Ownable for sails_rs::client::Service<OwnableImpl, E> {
        type Env = E;
        fn get_owner(&mut self) -> sails_rs::client::PendingCall<io::GetOwner, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(GetOwner () -> ActorId);
    }
}

pub mod tippable {
    use super::*;
    pub trait Tippable {
        type Env: sails_rs::client::GearEnv;
        fn tip(&mut self, amount: u128) -> sails_rs::client::PendingCall<io::Tip, Self::Env>;
    }
    pub struct TippableImpl;
    impl<E: sails_rs::client::GearEnv> Tippable for sails_rs::client::Service<TippableImpl, E> {
        type Env = E;
        fn tip(&mut self, amount: u128) -> sails_rs::client::PendingCall<io::Tip, Self::Env> {
            self.pending_call((amount,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Tip (amount: u128) -> ());
    }
}

pub mod non_zero_params {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct MyParam {
        pub f1: U256,
        pub f2: Vec<u8>,
        pub f3: Option<(u64, U256)>,
    }
    pub trait NonZeroParams {
        type Env: sails_rs::client::GearEnv;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env>;
    }
    pub struct NonZeroParamsImpl;
    impl<E: sails_rs::client::GearEnv> NonZeroParams
        for sails_rs::client::Service<NonZeroParamsImpl, E>
    {
        type Env = E;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoThis (p1: U256, p2: MyParam) -> u64);
    }
}

pub mod service_with_events {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct MyParam {
        pub f1: U256,
        pub f2: Vec<u8>,
        pub f3: Option<(u64, U256)>,
    }
    pub trait ServiceWithEvents {
        type Env: sails_rs::client::GearEnv;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env>;
    }
    pub struct ServiceWithEventsImpl;
    impl<E: sails_rs::client::GearEnv> ServiceWithEvents
        for sails_rs::client::Service<ServiceWithEventsImpl, E>
    {
        type Env = E;
        fn do_this(
            &mut self,
            p1: U256,
            p2: MyParam,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoThis (p1: U256, p2: MyParam) -> u64);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum ServiceWithEventsEvents {
            Event1(u32),
            Event2 { field1: String, field2: u64 },
        }
        impl sails_rs::client::Event for ServiceWithEventsEvents {
            const EVENT_NAMES: &'static [Route] = &["Event1", "Event2"];
        }
        impl sails_rs::client::ServiceWithEvents for ServiceWithEventsImpl {
            type Event = ServiceWithEventsEvents;
        }
    }
}

pub mod basic {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct MyParam {
        pub f1: u32,
        pub f2: Vec<String>,
        pub f3: Option<(u8, u32)>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum MyParam2 {
        Variant1,
        Variant2(u32),
        Variant3(u32),
        Variant4(u8, u32),
        Variant5 { f1: String, f2: Vec<u8> },
    }
    pub trait Basic {
        type Env: sails_rs::client::GearEnv;
        fn do_this(
            &mut self,
            p1: u32,
            p2: MyParam,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env>;
        fn do_that(
            &mut self,
            p1: (u8, u32),
        ) -> sails_rs::client::PendingCall<io::DoThat, Self::Env>;
    }
    pub struct BasicImpl;
    impl<E: sails_rs::client::GearEnv> Basic for sails_rs::client::Service<BasicImpl, E> {
        type Env = E;
        fn do_this(
            &mut self,
            p1: u32,
            p2: MyParam,
        ) -> sails_rs::client::PendingCall<io::DoThis, Self::Env> {
            self.pending_call((p1, p2))
        }
        fn do_that(
            &mut self,
            p1: (u8, u32),
        ) -> sails_rs::client::PendingCall<io::DoThat, Self::Env> {
            self.pending_call((p1,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(DoThis (p1: u32, p2: MyParam) -> u16);
        sails_rs::io_struct_impl!(DoThat (p1: (u8, u32)) -> u8);
    }
}

pub mod another_service {
    use super::*;
    pub trait AnotherService {
        type Env: sails_rs::client::GearEnv;
        fn ping(&mut self) -> sails_rs::client::PendingCall<io::Ping, Self::Env>;
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> sails_rs::client::PendingCall<io::ProcessValues, Self::Env>;
    }
    pub struct AnotherServiceImpl;
    impl<E: sails_rs::client::GearEnv> AnotherService
        for sails_rs::client::Service<AnotherServiceImpl, E>
    {
        type Env = E;
        fn ping(&mut self) -> sails_rs::client::PendingCall<io::Ping, Self::Env> {
            self.pending_call(())
        }
        fn process_values(
            &mut self,
            data: Vec<U256>,
        ) -> sails_rs::client::PendingCall<io::ProcessValues, Self::Env> {
            self.pending_call((data,))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Ping () -> String);
        sails_rs::io_struct_impl!(ProcessValues (data: Vec<U256>) -> Result<(), super::ProgramError>);
    }
}

pub mod my_complex_service {
    use super::*;
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct ProgramGlobalInfo {
        pub id: ActorId,
        pub config_version: u32,
        pub map_of_data: Vec<(String, ProgramScopedData)>,
        pub optional_value: Option<u64>,
        pub result_status: Result<(u32, bool), ProgramError>,
        pub values_vec: Vec<u8>,
        pub non_zero_id: u16,
        pub h256_hash: H256,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct ProgramScopedData {
        pub name: String,
        pub value: U256,
        pub sub_id: u32,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ErrorType {
        InvalidInput,
        NotFound(String),
        AccessDenied { id: ActorId, reason: String },
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct GenericData<T, U> {
        pub value_t: T,
        pub value_u: U,
        pub description: String,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum GenericResult<V> {
        Success(V),
        Failure(ProgramError),
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct ServiceLocalConfig {
        pub enabled: bool,
        pub retry_count: u8,
        pub actor_list: Vec<ActorId>,
    }
    #[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ServiceStatus {
        Active(ServiceLocalConfig),
        Paused,
        Error(ProgramError),
    }
    pub trait MyComplexService {
        type Env: sails_rs::client::GearEnv;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: u32,
        ) -> sails_rs::client::PendingCall<io::Initialize, Self::Env>;
        fn get_data(
            &mut self,
            key: String,
        ) -> sails_rs::client::PendingCall<io::GetData, Self::Env>;
        fn get_info(&mut self) -> sails_rs::client::PendingCall<io::GetInfo, Self::Env>;
        fn get_actor_ids(
            &mut self,
            count: u32,
        ) -> sails_rs::client::PendingCall<io::GetActorIds, Self::Env>;
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> sails_rs::client::PendingCall<io::ProcessGenericData, Self::Env>;
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> sails_rs::client::PendingCall<io::UpdateStatus, Self::Env>;
    }
    pub struct MyComplexServiceImpl;
    impl<E: sails_rs::client::GearEnv> MyComplexService
        for sails_rs::client::Service<MyComplexServiceImpl, E>
    {
        type Env = E;
        fn initialize(
            &mut self,
            start_data: ProgramGlobalInfo,
            max_size: u32,
        ) -> sails_rs::client::PendingCall<io::Initialize, Self::Env> {
            self.pending_call((start_data, max_size))
        }
        fn get_data(
            &mut self,
            key: String,
        ) -> sails_rs::client::PendingCall<io::GetData, Self::Env> {
            self.pending_call((key,))
        }
        fn get_info(&mut self) -> sails_rs::client::PendingCall<io::GetInfo, Self::Env> {
            self.pending_call(())
        }
        fn get_actor_ids(
            &mut self,
            count: u32,
        ) -> sails_rs::client::PendingCall<io::GetActorIds, Self::Env> {
            self.pending_call((count,))
        }
        fn process_generic_data(
            &mut self,
            input_data: GenericData<u32, String>,
            list_of_generics: Vec<GenericData<ActorId, U256>>,
            optional_generic_result: Option<GenericResult<bool>>,
        ) -> sails_rs::client::PendingCall<io::ProcessGenericData, Self::Env> {
            self.pending_call((input_data, list_of_generics, optional_generic_result))
        }
        fn update_status(
            &mut self,
            id: u64,
            new_status: ServiceStatus,
            metadata: Option<String>,
        ) -> sails_rs::client::PendingCall<io::UpdateStatus, Self::Env> {
            self.pending_call((id, new_status, metadata))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Initialize (start_data: ProgramGlobalInfo, max_size: u32) -> Result<(), super::ProgramError>);
        sails_rs::io_struct_impl!(GetData (key: String) -> Result<ProgramScopedData, super::ProgramError>);
        sails_rs::io_struct_impl!(GetInfo () -> ProgramGlobalInfo);
        sails_rs::io_struct_impl!(GetActorIds (count: u32) -> Vec<ActorId>);
        sails_rs::io_struct_impl!(ProcessGenericData (input_data: GenericData<u32, String>, list_of_generics: Vec<GenericData<ActorId, U256>>, optional_generic_result: Option<GenericResult<bool>>) -> GenericData<bool, u8>);
        sails_rs::io_struct_impl!(UpdateStatus (id: u64, new_status: ServiceStatus, metadata: Option<String>) -> GenericResult<u32>);
    }
}

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub Canvas {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl canvas::Canvas for Canvas { type Env = sails_rs::client::GstdEnv; fn color_point (&mut self, point: Point<u32>, color: Color) -> sails_rs::client::PendingCall<canvas::io::ColorPoint, sails_rs::client::GstdEnv>;fn kill_point (&mut self, point: Point<u32>) -> sails_rs::client::PendingCall<canvas::io::KillPoint, sails_rs::client::GstdEnv>;fn points (&self, offset: u32, len: u32) -> sails_rs::client::PendingCall<canvas::io::Points, sails_rs::client::GstdEnv>;fn point_status (&self, point: Point<u32>) -> sails_rs::client::PendingCall<canvas::io::PointStatus, sails_rs::client::GstdEnv>; } }
    mock! { pub PingPong {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl ping_pong::PingPong for PingPong { type Env = sails_rs::client::GstdEnv; fn ping (&mut self, input: String) -> sails_rs::client::PendingCall<ping_pong::io::Ping, sails_rs::client::GstdEnv>; } }
    mock! { pub Counter {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl counter::Counter for Counter { type Env = sails_rs::client::GstdEnv; fn add (&mut self, value: u32) -> sails_rs::client::PendingCall<counter::io::Add, sails_rs::client::GstdEnv>;fn sub (&mut self, value: u32) -> sails_rs::client::PendingCall<counter::io::Sub, sails_rs::client::GstdEnv>;fn value (&self, ) -> sails_rs::client::PendingCall<counter::io::Value, sails_rs::client::GstdEnv>; } }
    mock! { pub Dog {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl dog::Dog for Dog { type Env = sails_rs::client::GstdEnv; fn make_sound (&mut self, ) -> sails_rs::client::PendingCall<dog::io::MakeSound, sails_rs::client::GstdEnv>;fn walk (&mut self, dx: i32, dy: i32) -> sails_rs::client::PendingCall<dog::io::Walk, sails_rs::client::GstdEnv>;fn avg_weight (&self, ) -> sails_rs::client::PendingCall<dog::io::AvgWeight, sails_rs::client::GstdEnv>;fn position (&self, ) -> sails_rs::client::PendingCall<dog::io::Position, sails_rs::client::GstdEnv>; } }
    mock! { pub References {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl references::References for References { type Env = sails_rs::client::GstdEnv; fn add (&mut self, v: u32) -> sails_rs::client::PendingCall<references::io::Add, sails_rs::client::GstdEnv>;fn add_byte (&mut self, byte: u8) -> sails_rs::client::PendingCall<references::io::AddByte, sails_rs::client::GstdEnv>;fn guess_num (&mut self, number: u8) -> sails_rs::client::PendingCall<references::io::GuessNum, sails_rs::client::GstdEnv>;fn incr (&mut self, ) -> sails_rs::client::PendingCall<references::io::Incr, sails_rs::client::GstdEnv>;fn set_num (&mut self, number: u8) -> sails_rs::client::PendingCall<references::io::SetNum, sails_rs::client::GstdEnv>;fn baked (&self, ) -> sails_rs::client::PendingCall<references::io::Baked, sails_rs::client::GstdEnv>;fn last_byte (&self, ) -> sails_rs::client::PendingCall<references::io::LastByte, sails_rs::client::GstdEnv>;fn message (&self, ) -> sails_rs::client::PendingCall<references::io::Message, sails_rs::client::GstdEnv>; } }
    mock! { pub ThisThat {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl this_that::ThisThat for ThisThat { type Env = sails_rs::client::GstdEnv; fn do_that (&mut self, param: DoThatParam) -> sails_rs::client::PendingCall<this_that::io::DoThat, sails_rs::client::GstdEnv>;fn do_this (&mut self, p1: u32, p2: String, p3: (Option<H160>, u8), p4: TupleStruct) -> sails_rs::client::PendingCall<this_that::io::DoThis, sails_rs::client::GstdEnv>;fn noop (&mut self, ) -> sails_rs::client::PendingCall<this_that::io::Noop, sails_rs::client::GstdEnv>;fn that (&self, ) -> sails_rs::client::PendingCall<this_that::io::That, sails_rs::client::GstdEnv>;fn this (&self, ) -> sails_rs::client::PendingCall<this_that::io::This, sails_rs::client::GstdEnv>; } }
    mock! { pub ValueFee {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl value_fee::ValueFee for ValueFee { type Env = sails_rs::client::GstdEnv; fn do_something_and_take_fee (&mut self, ) -> sails_rs::client::PendingCall<value_fee::io::DoSomethingAndTakeFee, sails_rs::client::GstdEnv>; } }
    mock! { pub Pausable {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl pausable::Pausable for Pausable { type Env = sails_rs::client::GstdEnv; fn pause (&mut self, ) -> sails_rs::client::PendingCall<pausable::io::Pause, sails_rs::client::GstdEnv>;fn unpause (&mut self, ) -> sails_rs::client::PendingCall<pausable::io::Unpause, sails_rs::client::GstdEnv>; } }
    mock! { pub Ownable {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl ownable::Ownable for Ownable { type Env = sails_rs::client::GstdEnv; fn get_owner (&mut self, ) -> sails_rs::client::PendingCall<ownable::io::GetOwner, sails_rs::client::GstdEnv>; } }
    mock! { pub Tippable {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl tippable::Tippable for Tippable { type Env = sails_rs::client::GstdEnv; fn tip (&mut self, amount: u128) -> sails_rs::client::PendingCall<tippable::io::Tip, sails_rs::client::GstdEnv>; } }
    mock! { pub NonZeroParams {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl non_zero_params::NonZeroParams for NonZeroParams { type Env = sails_rs::client::GstdEnv; fn do_this (&mut self, p1: U256, p2: MyParam) -> sails_rs::client::PendingCall<non_zero_params::io::DoThis, sails_rs::client::GstdEnv>; } }
    mock! { pub ServiceWithEvents {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl service_with_events::ServiceWithEvents for ServiceWithEvents { type Env = sails_rs::client::GstdEnv; fn do_this (&mut self, p1: U256, p2: MyParam) -> sails_rs::client::PendingCall<service_with_events::io::DoThis, sails_rs::client::GstdEnv>; } }
    mock! { pub Basic {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl basic::Basic for Basic { type Env = sails_rs::client::GstdEnv; fn do_this (&mut self, p1: u32, p2: MyParam) -> sails_rs::client::PendingCall<basic::io::DoThis, sails_rs::client::GstdEnv>;fn do_that (&mut self, p1: (u8, u32)) -> sails_rs::client::PendingCall<basic::io::DoThat, sails_rs::client::GstdEnv>; } }
    mock! { pub AnotherService {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl another_service::AnotherService for AnotherService { type Env = sails_rs::client::GstdEnv; fn ping (&mut self, ) -> sails_rs::client::PendingCall<another_service::io::Ping, sails_rs::client::GstdEnv>;fn process_values (&mut self, data: Vec<U256>) -> sails_rs::client::PendingCall<another_service::io::ProcessValues, sails_rs::client::GstdEnv>; } }
    mock! { pub MyComplexService {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl my_complex_service::MyComplexService for MyComplexService { type Env = sails_rs::client::GstdEnv; fn initialize (&mut self, start_data: ProgramGlobalInfo, max_size: u32) -> sails_rs::client::PendingCall<my_complex_service::io::Initialize, sails_rs::client::GstdEnv>;fn get_data (&mut self, key: String) -> sails_rs::client::PendingCall<my_complex_service::io::GetData, sails_rs::client::GstdEnv>;fn get_info (&mut self, ) -> sails_rs::client::PendingCall<my_complex_service::io::GetInfo, sails_rs::client::GstdEnv>;fn get_actor_ids (&mut self, count: u32) -> sails_rs::client::PendingCall<my_complex_service::io::GetActorIds, sails_rs::client::GstdEnv>;fn process_generic_data (&mut self, input_data: GenericData<u32, String>, list_of_generics: Vec<GenericData<ActorId, U256>>, optional_generic_result: Option<GenericResult<bool>>) -> sails_rs::client::PendingCall<my_complex_service::io::ProcessGenericData, sails_rs::client::GstdEnv>;fn update_status (&mut self, id: u64, new_status: ServiceStatus, metadata: Option<String>) -> sails_rs::client::PendingCall<my_complex_service::io::UpdateStatus, sails_rs::client::GstdEnv>; } }
}
