program RmrkCatalog {
    constructors {
        New();
    }
    services {
        RmrkCatalogService,
    }
    types {
        enum Error {
            PartIdCantBeZero,
            BadConfig,
            PartAlreadyExists,
            ZeroLengthPassed,
            PartDoesNotExist,
            WrongPartFormat,
            NotAllowedToCall,
        }

        enum Part {
            Fixed(FixedPart),
            Slot(SlotPart),
        }

        struct FixedPart {
            /// An optional zIndex of base part layer.
            /// specifies the stack order of an element.
            /// An element with greater stack order is always in front of an element with a lower stack order.
            z: Option<u32>,
            /// The metadata URI of the part.
            metadata_uri: string,
        }

        struct SlotPart {
            /// Array of whitelisted collections that can be equipped in the given slot. Used with slot parts only.
            equippable: Vec<ActorId>,
            /// An optional zIndex of base part layer.
            /// specifies the stack order of an element.
            z: Option<u32>,
            /// The metadata URI of the part.
            metadata_uri: string,
        }
    }
}

service RmrkCatalogService {
    functions {
        AddEquippables(part_id: u32, collection_ids: Vec<ActorId>) -> Result<(u32, Vec<ActorId>), Error>;
        AddParts(parts: BTreeMap<u32, Part>) -> Result<BTreeMap<u32, Part>, Error>;
        RemoveEquippable(part_id: u32, collection_id: ActorId) -> Result<(u32, ActorId), Error>;
        RemoveParts(part_ids: Vec<u32>) -> Result<Vec<u32>, Error>;
        ResetEquippables(part_id: u32) -> Result<(), Error>;
        SetEquippablesToAll(part_id: u32) -> Result<(), Error>;
        @query
        Equippable(part_id: u32, collection_id: ActorId) -> Result<bool, Error>;
        @query
        Part(part_id: u32) -> Option<Part>;
    }
}