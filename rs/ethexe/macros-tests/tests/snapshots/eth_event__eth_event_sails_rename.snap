---
source: macros-tests/tests/eth_event.rs
expression: result
---
#[derive(sails_rename::Encode, sails_rename::TypeInfo)]
#[codec(crate = sails_rename::scale_codec)]
#[scale_info(crate = sails_rename::scale_info)]
pub enum Events {
    MyEvent1 {
        /// #[indexed]
        sender: u128,
        /// #[indexed]
        amount: u128,
        note: String,
    },
    MyEvent2(u128, u128, String),
    MyEvent3,
}
impl sails_rename::EthEvent for Events {
    const SIGNATURES: &'static [sails_rename::gstd::EthEventExpo] = &[
        (
            "MyEvent1",
            <<(
                u128,
                u128,
                String,
            ) as sails_rename::alloy_sol_types::SolValue>::SolType as sails_rename::alloy_sol_types::SolType>::SOL_NAME,
            sails_rename::keccak_const::Keccak256::new()
                .update("MyEvent1".as_bytes())
                .update(
                    <<(
                        u128,
                        u128,
                        String,
                    ) as sails_rename::alloy_sol_types::SolValue>::SolType as sails_rename::alloy_sol_types::SolType>::SOL_NAME
                        .as_bytes(),
                )
                .finalize(),
        ),
        (
            "MyEvent2",
            <<(
                u128,
                u128,
                String,
            ) as sails_rename::alloy_sol_types::SolValue>::SolType as sails_rename::alloy_sol_types::SolType>::SOL_NAME,
            sails_rename::keccak_const::Keccak256::new()
                .update("MyEvent2".as_bytes())
                .update(
                    <<(
                        u128,
                        u128,
                        String,
                    ) as sails_rename::alloy_sol_types::SolValue>::SolType as sails_rename::alloy_sol_types::SolType>::SOL_NAME
                        .as_bytes(),
                )
                .finalize(),
        ),
        (
            "MyEvent3",
            <<() as sails_rename::alloy_sol_types::SolValue>::SolType as sails_rename::alloy_sol_types::SolType>::SOL_NAME,
            sails_rename::keccak_const::Keccak256::new()
                .update("MyEvent3".as_bytes())
                .update(
                    <<() as sails_rename::alloy_sol_types::SolValue>::SolType as sails_rename::alloy_sol_types::SolType>::SOL_NAME
                        .as_bytes(),
                )
                .finalize(),
        ),
    ];
    #[allow(unused_variables)]
    fn topics(&self) -> sails_rename::Vec<sails_rename::alloy_primitives::B256> {
        match self {
            Events::MyEvent1 { sender, amount, note } => {
                let mut topics = sails_rename::Vec::with_capacity(3usize);
                let (_, _, hash) = Self::SIGNATURES[0usize];
                topics.push(sails_rename::alloy_primitives::B256::new(hash));
                topics.push(Self::topic_hash(sender));
                topics.push(Self::topic_hash(amount));
                topics
            }
            Events::MyEvent2(f0, f1, f2) => {
                let mut topics = sails_rename::Vec::with_capacity(1usize);
                let (_, _, hash) = Self::SIGNATURES[1usize];
                topics.push(sails_rename::alloy_primitives::B256::new(hash));
                topics
            }
            Events::MyEvent3 => {
                let mut topics = sails_rename::Vec::with_capacity(1usize);
                let (_, _, hash) = Self::SIGNATURES[2usize];
                topics.push(sails_rename::alloy_primitives::B256::new(hash));
                topics
            }
        }
    }
    #[allow(unused_variables)]
    fn data(&self) -> sails_rename::Vec<u8> {
        match self {
            Events::MyEvent1 { sender, amount, note } => Self::encode_sequence(&(note,)),
            Events::MyEvent2(f0, f1, f2) => Self::encode_sequence(&(f0, f1, f2)),
            Events::MyEvent3 => Self::encode_sequence(&()),
        }
    }
}
