---
source: macros-tests/tests/evm_event.rs
expression: result
---
impl EthEvent for Events {
    const SIGNATURES: &'static [&'static str] = &[
        concatcp!(
            "MyEvent1", << (u128, u128, String,) as sails_rs::alloy_sol_types::SolValue >
            ::SolType as sails_rs::alloy_sol_types::SolType > ::SOL_NAME,
        ),
        concatcp!(
            "MyEvent2", << (u128, u128, String,) as sails_rs::alloy_sol_types::SolValue >
            ::SolType as sails_rs::alloy_sol_types::SolType > ::SOL_NAME,
        ),
        concatcp!(
            "MyEvent3", << () as sails_rs::alloy_sol_types::SolValue > ::SolType as
            sails_rs::alloy_sol_types::SolType > ::SOL_NAME,
        ),
    ];
    #[allow(unused_variables)]
    fn topics(&self) -> Vec<sails_rs::alloy_primitives::B256> {
        match self {
            Events::MyEvent1 { sender, amount, note } => {
                let mut topics = Vec::with_capacity(3usize);
                topics
                    .push(
                        sails_rs::alloy_primitives::keccak256(Self::SIGNATURES[0usize]),
                    );
                topics.push(Self::topic_hash(sender));
                topics.push(Self::topic_hash(amount));
                topics
            }
            Events::MyEvent2(f0, f1, f2) => {
                let mut topics = Vec::with_capacity(2usize);
                topics
                    .push(
                        sails_rs::alloy_primitives::keccak256(Self::SIGNATURES[1usize]),
                    );
                topics.push(Self::topic_hash(f0));
                topics
            }
            Events::MyEvent3 => {
                let mut topics = Vec::with_capacity(1usize);
                topics
                    .push(
                        sails_rs::alloy_primitives::keccak256(Self::SIGNATURES[2usize]),
                    );
                topics
            }
        }
    }
    #[allow(unused_variables)]
    fn data(&self) -> Vec<u8> {
        match self {
            Events::MyEvent1 { sender, amount, note } => Self::encode_sequence(&(note,)),
            Events::MyEvent2(f0, f1, f2) => Self::encode_sequence(&(f1, f2)),
            Events::MyEvent3 => Self::encode_sequence(&()),
        }
    }
}
