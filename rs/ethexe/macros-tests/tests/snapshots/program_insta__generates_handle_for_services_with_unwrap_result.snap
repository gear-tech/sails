---
source: macros-tests/tests/program_insta.rs
expression: result
---
impl MyProgram {
    fn __service1(&self) -> Result<MyService, String> {
        Ok(MyService)
    }
    fn __service2(&self) -> MyService {
        MyService
    }
    pub fn create() -> Self {
        Self
    }
    pub fn service1(
        &self,
    ) -> <MyService as sails_rs::gstd::services::Service>::Exposure {
        let service = self.__service1().unwrap();
        let exposure = <MyService as sails_rs::gstd::services::Service>::expose(
            service,
            sails_rs::gstd::Syscall::message_id(),
            __ROUTE_SVC1.as_ref(),
        );
        exposure
    }
    pub fn service2(
        &self,
    ) -> <MyService as sails_rs::gstd::services::Service>::Exposure {
        let service = self.__service2();
        let exposure = <MyService as sails_rs::gstd::services::Service>::expose(
            service,
            sails_rs::gstd::Syscall::message_id(),
            __ROUTE_SERVICE2.as_ref(),
        );
        exposure
    }
}
const __ROUTE_SVC1: [u8; 5usize] = [16u8, 83u8, 118u8, 99u8, 49u8];
const __ROUTE_SERVICE2: [u8; 9usize] = [
    32u8, 83u8, 101u8, 114u8, 118u8, 105u8, 99u8, 101u8, 50u8,
];
impl sails_rs::meta::ProgramMeta for MyProgram {
    type ConstructorsMeta = meta_in_program::ConstructorsMeta;
    const SERVICES: &'static [(&'static str, sails_rs::meta::AnyServiceMetaFn)] = &[
        ("Svc1", sails_rs::meta::AnyServiceMeta::new::<MyService>),
        ("Service2", sails_rs::meta::AnyServiceMeta::new::<MyService>),
    ];
}
mod meta_in_program {
    use super::*;
    #[derive(sails_rs::Decode, sails_rs::TypeInfo)]
    #[codec(crate = sails_rs::scale_codec)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub struct __CreateParams {}
    impl sails_rs::gstd::InvocationIo for __CreateParams {
        const ROUTE: &'static [u8] = &[24u8, 67u8, 114u8, 101u8, 97u8, 116u8, 101u8];
        type Params = Self;
    }
    #[derive(sails_rs::TypeInfo)]
    #[scale_info(crate = sails_rs::scale_info)]
    pub enum ConstructorsMeta {
        Create(__CreateParams),
    }
}
impl sails_rs::solidity::ProgramSignature for MyProgram {
    const CTORS: &'static [sails_rs::solidity::MethodExpo] = &[
        (
            &[24u8, 67u8, 114u8, 101u8, 97u8, 116u8, 101u8] as &[u8],
            "create",
            <<(
                u128,
                bool,
            ) as sails_rs::alloy_sol_types::SolValue>::SolType as sails_rs::alloy_sol_types::SolType>::SOL_NAME,
            <<(
                sails_rs::alloy_primitives::B256,
            ) as sails_rs::alloy_sol_types::SolValue>::SolType as sails_rs::alloy_sol_types::SolType>::SOL_NAME,
        ),
    ];
    const SERVICES: &'static [sails_rs::solidity::ServiceExpo] = &[
        (
            "service2",
            &[32u8, 83u8, 101u8, 114u8, 118u8, 105u8, 99u8, 101u8, 50u8] as &[u8],
            <MyService as sails_rs::solidity::ServiceSignature>::METHODS,
        ),
        (
            "svc1",
            &[16u8, 83u8, 118u8, 99u8, 49u8] as &[u8],
            <MyService as sails_rs::solidity::ServiceSignature>::METHODS,
        ),
    ];
    const METHODS_LEN: usize = <MyService as sails_rs::solidity::ServiceSignature>::METHODS
        .len() + <MyService as sails_rs::solidity::ServiceSignature>::METHODS.len();
}
const __CTOR_SIGS: [[u8; 4]; <MyProgram as sails_rs::solidity::ProgramSignature>::CTORS
    .len()] = sails_rs::solidity::ConstProgramMeta::<MyProgram>::ctor_sigs();
const __CTOR_CALLBACK_SIGS: [[u8; 4]; <MyProgram as sails_rs::solidity::ProgramSignature>::CTORS
    .len()] = sails_rs::solidity::ConstProgramMeta::<MyProgram>::ctor_callback_sigs();
const __METHOD_SIGS: [[u8; 4]; <MyProgram as sails_rs::solidity::ProgramSignature>::METHODS_LEN] = sails_rs::solidity::ConstProgramMeta::<
    MyProgram,
>::method_sigs();
const __METHOD_ROUTES: [(
    &'static [u8],
    &'static [u8],
); <MyProgram as sails_rs::solidity::ProgramSignature>::METHODS_LEN] = sails_rs::solidity::ConstProgramMeta::<
    MyProgram,
>::method_routes();
const __CALLBACK_SIGS: [[u8; 4]; <MyProgram as sails_rs::solidity::ProgramSignature>::METHODS_LEN] = sails_rs::solidity::ConstProgramMeta::<
    MyProgram,
>::callback_sigs();
#[cfg(target_arch = "wasm32")]
pub mod wasm {
    use super::*;
    use sails_rs::{gstd, hex, prelude::*};
    static mut PROGRAM: Option<MyProgram> = None;
    #[gstd::async_init]
    async fn init() {
        use gstd::InvocationIo;
        let mut input: &[u8] = &gstd::msg::load_bytes().expect("Failed to read input");
        if let Ok(sig) = TryInto::<[u8; 4]>::try_into(&input[..4]) {
            if let Some(idx) = __CTOR_SIGS.iter().position(|s| s == &sig) {
                let (ctor_route, ..) = <MyProgram as sails_rs::solidity::ProgramSignature>::CTORS[idx];
                if let Some((program, encode_reply)) = match_ctor_solidity(
                        ctor_route,
                        &input[4..],
                    )
                    .await
                {
                    unsafe { PROGRAM = Some(program) };
                    let output = if encode_reply {
                        [
                            __CTOR_CALLBACK_SIGS[idx].as_slice(),
                            gstd::msg::id().into_bytes().as_slice(),
                        ]
                            .concat()
                    } else {
                        Vec::with_capacity(0)
                    };
                    gstd::msg::reply_bytes(output, 0).expect("Failed to send output");
                    return;
                }
            }
        }
        let (program, invocation_route) = if let Ok(request) = meta_in_program::__CreateParams::decode_params(
            input,
        ) {
            let program = MyProgram::create();
            (program, meta_in_program::__CreateParams::ROUTE)
        } else {
            gstd::unknown_input_panic("Unexpected ctor", input)
        };
        unsafe {
            PROGRAM = Some(program);
        }
        gstd::msg::reply_bytes(invocation_route, 0).expect("Failed to send output");
    }
    async fn match_ctor_solidity(
        ctor: &[u8],
        input: &[u8],
    ) -> Option<(MyProgram, bool)> {
        if ctor == &[24u8, 67u8, 114u8, 101u8, 97u8, 116u8, 101u8] {
            let (_, _encode_reply): (u128, bool) = sails_rs::alloy_sol_types::SolValue::abi_decode_params(
                    input,
                    false,
                )
                .expect("Failed to decode request");
            let program = MyProgram::create();
            return Some((program, _encode_reply));
        }
        None
    }
    #[gstd::async_main]
    async fn main() {
        let mut input: &[u8] = &gstd::msg::load_bytes().expect("Failed to read input");
        let program_ref = unsafe { PROGRAM.as_mut() }.expect("Program not initialized");
        if let Ok(sig) = TryInto::<[u8; 4]>::try_into(&input[..4]) {
            if let Some(idx) = __METHOD_SIGS.iter().position(|s| s == &sig) {
                let (route, method) = __METHOD_ROUTES[idx];
                if route == &__ROUTE_SVC1 {
                    let mut service = program_ref.service1();
                    let (output, value, encode_reply) = service
                        .try_handle_solidity(method, &input[4..])
                        .await
                        .unwrap_or_else(|| {
                            gstd::unknown_input_panic("Unknown request", input)
                        });
                    let output = if encode_reply {
                        let selector = __CALLBACK_SIGS[idx];
                        [selector.as_slice(), output.as_slice()].concat()
                    } else {
                        output
                    };
                    gstd::msg::reply_bytes(output, value)
                        .expect("Failed to send output");
                    return;
                }
                if route == &__ROUTE_SERVICE2 {
                    let mut service = program_ref.service2();
                    let (output, value, encode_reply) = service
                        .try_handle_solidity(method, &input[4..])
                        .await
                        .unwrap_or_else(|| {
                            gstd::unknown_input_panic("Unknown request", input)
                        });
                    let output = if encode_reply {
                        let selector = __CALLBACK_SIGS[idx];
                        [selector.as_slice(), output.as_slice()].concat()
                    } else {
                        output
                    };
                    gstd::msg::reply_bytes(output, value)
                        .expect("Failed to send output");
                    return;
                }
            }
        }
        if input.starts_with(&__ROUTE_SVC1) {
            let mut service = program_ref.service1();
            service
                .try_handle(
                    &input[__ROUTE_SVC1.len()..],
                    |encoded_result, value| {
                        gstd::msg::reply_bytes(encoded_result, value)
                            .expect("Failed to send output");
                    },
                )
                .await
                .unwrap_or_else(|| {
                    gstd::unknown_input_panic("Unknown request", input)
                });
        } else if input.starts_with(&__ROUTE_SERVICE2) {
            let mut service = program_ref.service2();
            service
                .try_handle(
                    &input[__ROUTE_SERVICE2.len()..],
                    |encoded_result, value| {
                        gstd::msg::reply_bytes(encoded_result, value)
                            .expect("Failed to send output");
                    },
                )
                .await
                .unwrap_or_else(|| {
                    gstd::unknown_input_panic("Unknown request", input)
                });
        } else {
            gstd::unknown_input_panic("Unexpected service", input)
        };
    }
}
