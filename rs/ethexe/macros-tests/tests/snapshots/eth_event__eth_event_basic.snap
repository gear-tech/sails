---
source: macros-tests/tests/eth_event.rs
expression: result
---
impl sails_rs::EthEvent for MyEvent {
    const SIGNATURES: &'static [sails_rs::gstd::EthEventExpo] = &[
        (
            "MyEvent1",
            <<() as sails_rs::alloy_sol_types::SolValue>::SolType as sails_rs::alloy_sol_types::SolType>::SOL_NAME,
            sails_rs::keccak_const::Keccak256::new()
                .update("MyEvent1".as_bytes())
                .update(
                    <<() as sails_rs::alloy_sol_types::SolValue>::SolType as sails_rs::alloy_sol_types::SolType>::SOL_NAME
                        .as_bytes(),
                )
                .finalize(),
        ),
    ];
    #[allow(unused_variables)]
    fn topics(&self) -> sails_rs::Vec<sails_rs::alloy_primitives::B256> {
        match self {
            MyEvent::MyEvent1 => {
                let mut topics = sails_rs::Vec::with_capacity(1usize);
                let (_, _, hash) = Self::SIGNATURES[0usize];
                topics.push(sails_rs::alloy_primitives::B256::new(hash));
                topics
            }
        }
    }
    #[allow(unused_variables)]
    fn data_encoded_size(&self) -> usize {
        match self {
            MyEvent::MyEvent1 => Self::abi_encoded_size(&()),
        }
    }
    #[allow(unused_variables)]
    fn data_encode_to<T: sails_rs::Output>(&self, __output: &mut T) {
        use sails_rs::alloy_sol_types::private::SolTypeValue;
        match self {
            MyEvent::MyEvent1 => Self::encode_sequence(&(), __output),
        }
    }
}
