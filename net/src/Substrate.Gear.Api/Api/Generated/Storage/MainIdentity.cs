#nullable disable
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.Gear.Api.Generated.Storage
{
    
    
    /// <summary>
    /// >> IdentityStorage
    /// </summary>
    public sealed class IdentityStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> IdentityStorage Constructor
        /// </summary>
        public IdentityStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "IdentityOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.pallet_identity.types.Registration, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "SuperOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumData>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "SubsOf"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT23>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "Registrars"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT24)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "UsernameAuthorities"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.pallet_identity.types.AuthorityProperties)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "AccountOfUsername"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4), typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Identity", "PendingUsernames"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>)));
        }
        
        /// <summary>
        /// >> IdentityOfParams
        ///  Information that is pertinent to identify the entity behind an account. First item is the
        ///  registration, second is the account's primary username.
        /// 
        ///  TWOX-NOTE: OK ï¿½ï¿½ï¿½ `AccountId` is a secure hash.
        /// </summary>
        public static string IdentityOfParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "IdentityOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> IdentityOfDefault
        /// Default value as hex string
        /// </summary>
        public static string IdentityOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> IdentityOf
        ///  Information that is pertinent to identify the entity behind an account. First item is the
        ///  registration, second is the account's primary username.
        /// 
        ///  TWOX-NOTE: OK ï¿½ï¿½ï¿½ `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.pallet_identity.types.Registration, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4>>> IdentityOf(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.IdentityOfParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.pallet_identity.types.Registration, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4>>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SuperOfParams
        ///  The super-identity of an alternative "sub" identity together with its name, within that
        ///  context. If the account is not some other account's sub-identity, then just `None`.
        /// </summary>
        public static string SuperOfParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "SuperOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SuperOfDefault
        /// Default value as hex string
        /// </summary>
        public static string SuperOfDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SuperOf
        ///  The super-identity of an alternative "sub" identity together with its name, within that
        ///  context. If the account is not some other account's sub-identity, then just `None`.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumData>> SuperOf(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.SuperOfParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumData>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SubsOfParams
        ///  Alternative "sub" identities of this account.
        /// 
        ///  The first item is the deposit, the second is a vector of the accounts.
        /// 
        ///  TWOX-NOTE: OK ï¿½ï¿½ï¿½ `AccountId` is a secure hash.
        /// </summary>
        public static string SubsOfParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "SubsOf", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SubsOfDefault
        /// Default value as hex string
        /// </summary>
        public static string SubsOfDefault()
        {
            return "0x0000000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> SubsOf
        ///  Alternative "sub" identities of this account.
        /// 
        ///  The first item is the deposit, the second is a vector of the accounts.
        /// 
        ///  TWOX-NOTE: OK ï¿½ï¿½ï¿½ `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT23>> SubsOf(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.SubsOfParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT23>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> RegistrarsParams
        ///  The set of registrars. Not expected to get very big as can only be added through a
        ///  special origin (likely a council motion).
        /// 
        ///  The index into this can be cast to `RegistrarIndex` to get a valid value.
        /// </summary>
        public static string RegistrarsParams()
        {
            return RequestGenerator.GetStorage("Identity", "Registrars", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> RegistrarsDefault
        /// Default value as hex string
        /// </summary>
        public static string RegistrarsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Registrars
        ///  The set of registrars. Not expected to get very big as can only be added through a
        ///  special origin (likely a council motion).
        /// 
        ///  The index into this can be cast to `RegistrarIndex` to get a valid value.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT24> Registrars(string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.RegistrarsParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT24>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UsernameAuthoritiesParams
        ///  A map of the accounts who are authorized to grant usernames.
        /// </summary>
        public static string UsernameAuthoritiesParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Identity", "UsernameAuthorities", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UsernameAuthoritiesDefault
        /// Default value as hex string
        /// </summary>
        public static string UsernameAuthoritiesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UsernameAuthorities
        ///  A map of the accounts who are authorized to grant usernames.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_identity.types.AuthorityProperties> UsernameAuthorities(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.UsernameAuthoritiesParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_identity.types.AuthorityProperties>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AccountOfUsernameParams
        ///  Reverse lookup from `username` to the `AccountId` that has registered it. The value should
        ///  be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
        /// 
        ///  Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
        ///  primary username.
        /// </summary>
        public static string AccountOfUsernameParams(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 key)
        {
            return RequestGenerator.GetStorage("Identity", "AccountOfUsername", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AccountOfUsernameDefault
        /// Default value as hex string
        /// </summary>
        public static string AccountOfUsernameDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AccountOfUsername
        ///  Reverse lookup from `username` to the `AccountId` that has registered it. The value should
        ///  be a key in the `IdentityOf` map, but it may not if the user has cleared their identity.
        /// 
        ///  Multiple usernames may map to the same `AccountId`, but `IdentityOf` will only map to one
        ///  primary username.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> AccountOfUsername(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.AccountOfUsernameParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PendingUsernamesParams
        ///  Usernames that an authority has granted, but that the account controller has not confirmed
        ///  that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
        ///  because they are a pure proxy, multisig, etc. In order to confirm it, they should call
        ///  [`Call::accept_username`].
        /// 
        ///  First tuple item is the account and second is the acceptance deadline.
        /// </summary>
        public static string PendingUsernamesParams(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 key)
        {
            return RequestGenerator.GetStorage("Identity", "PendingUsernames", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PendingUsernamesDefault
        /// Default value as hex string
        /// </summary>
        public static string PendingUsernamesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> PendingUsernames
        ///  Usernames that an authority has granted, but that the account controller has not confirmed
        ///  that they want it. Used primarily in cases where the `AccountId` cannot provide a signature
        ///  because they are a pure proxy, multisig, etc. In order to confirm it, they should call
        ///  [`Call::accept_username`].
        /// 
        ///  First tuple item is the account and second is the acceptance deadline.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>> PendingUsernames(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 key, string blockhash, CancellationToken token)
        {
            string parameters = IdentityStorage.PendingUsernamesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> IdentityCalls
    /// </summary>
    public sealed class IdentityCalls
    {
        
        /// <summary>
        /// >> add_registrar
        /// Identity pallet declaration.
        /// </summary>
        public static Method AddRegistrar(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress account)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(account.Encode());
            return new Method(24, "Identity", 0, "add_registrar", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_identity
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetIdentity(Substrate.Gear.Api.Generated.Model.pallet_identity.legacy.IdentityInfo info)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(info.Encode());
            return new Method(24, "Identity", 1, "set_identity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_subs
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetSubs(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumData>> subs)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(subs.Encode());
            return new Method(24, "Identity", 2, "set_subs", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> clear_identity
        /// Identity pallet declaration.
        /// </summary>
        public static Method ClearIdentity()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(24, "Identity", 3, "clear_identity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> request_judgement
        /// Identity pallet declaration.
        /// </summary>
        public static Method RequestJudgement(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> reg_index, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> max_fee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(reg_index.Encode());
            byteArray.AddRange(max_fee.Encode());
            return new Method(24, "Identity", 4, "request_judgement", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_request
        /// Identity pallet declaration.
        /// </summary>
        public static Method CancelRequest(Substrate.NetApi.Model.Types.Primitive.U32 reg_index)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(reg_index.Encode());
            return new Method(24, "Identity", 5, "cancel_request", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_fee
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetFee(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> index, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> fee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(index.Encode());
            byteArray.AddRange(fee.Encode());
            return new Method(24, "Identity", 6, "set_fee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_account_id
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetAccountId(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> index, Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(index.Encode());
            byteArray.AddRange(@new.Encode());
            return new Method(24, "Identity", 7, "set_account_id", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_fields
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetFields(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> index, Substrate.NetApi.Model.Types.Primitive.U64 fields)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(index.Encode());
            byteArray.AddRange(fields.Encode());
            return new Method(24, "Identity", 8, "set_fields", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> provide_judgement
        /// Identity pallet declaration.
        /// </summary>
        public static Method ProvideJudgement(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> reg_index, Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress target, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumJudgement judgement, Substrate.Gear.Api.Generated.Model.primitive_types.H256 identity)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(reg_index.Encode());
            byteArray.AddRange(target.Encode());
            byteArray.AddRange(judgement.Encode());
            byteArray.AddRange(identity.Encode());
            return new Method(24, "Identity", 9, "provide_judgement", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kill_identity
        /// Identity pallet declaration.
        /// </summary>
        public static Method KillIdentity(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress target)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(target.Encode());
            return new Method(24, "Identity", 10, "kill_identity", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method AddSub(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress sub, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumData data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(sub.Encode());
            byteArray.AddRange(data.Encode());
            return new Method(24, "Identity", 11, "add_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> rename_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method RenameSub(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress sub, Substrate.Gear.Api.Generated.Model.pallet_identity.types.EnumData data)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(sub.Encode());
            byteArray.AddRange(data.Encode());
            return new Method(24, "Identity", 12, "rename_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveSub(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress sub)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(sub.Encode());
            return new Method(24, "Identity", 13, "remove_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> quit_sub
        /// Identity pallet declaration.
        /// </summary>
        public static Method QuitSub()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(24, "Identity", 14, "quit_sub", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> add_username_authority
        /// Identity pallet declaration.
        /// </summary>
        public static Method AddUsernameAuthority(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress authority, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> suffix, Substrate.NetApi.Model.Types.Primitive.U32 allocation)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(authority.Encode());
            byteArray.AddRange(suffix.Encode());
            byteArray.AddRange(allocation.Encode());
            return new Method(24, "Identity", 15, "add_username_authority", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_username_authority
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveUsernameAuthority(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress authority)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(authority.Encode());
            return new Method(24, "Identity", 16, "remove_username_authority", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_username_for
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetUsernameFor(Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress who, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> username, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Gear.Api.Generated.Model.sp_runtime.EnumMultiSignature> signature)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(who.Encode());
            byteArray.AddRange(username.Encode());
            byteArray.AddRange(signature.Encode());
            return new Method(24, "Identity", 17, "set_username_for", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> accept_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method AcceptUsername(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(24, "Identity", 18, "accept_username", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_expired_approval
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveExpiredApproval(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(24, "Identity", 19, "remove_expired_approval", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_primary_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method SetPrimaryUsername(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(24, "Identity", 20, "set_primary_username", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_dangling_username
        /// Identity pallet declaration.
        /// </summary>
        public static Method RemoveDanglingUsername(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4 username)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(username.Encode());
            return new Method(24, "Identity", 21, "remove_dangling_username", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> IdentityConstants
    /// </summary>
    public sealed class IdentityConstants
    {
        
        /// <summary>
        /// >> BasicDeposit
        ///  The amount held on deposit for a registered identity.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 BasicDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00407A10F35A00000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> ByteDeposit
        ///  The amount held on deposit per encoded byte for a registered identity.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 ByteDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x0070C9B28B0000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> SubAccountDeposit
        ///  The amount held on deposit for a registered subaccount. This should account for the fact
        ///  that one storage item's value will increase by the size of an account ID, and there will
        ///  be another trie item whose value is the size of an account ID plus 32 bytes.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 SubAccountDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x0040E59C301200000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxSubAccounts
        ///  The maximum number of sub-accounts allowed per identified account.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxSubAccounts()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x64000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxRegistrars
        ///  Maximum number of registrars allowed in the system. Needed to bound the complexity
        ///  of, e.g., updating judgements.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxRegistrars()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x14000000");
            return result;
        }
        
        /// <summary>
        /// >> PendingUsernameExpiration
        ///  The number of blocks within which a username grant must be accepted.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 PendingUsernameExpiration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x80130300");
            return result;
        }
        
        /// <summary>
        /// >> MaxSuffixLength
        ///  The maximum length of a suffix.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxSuffixLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x07000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxUsernameLength
        ///  The maximum length of a username, including its suffix and any system-added delimiters.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxUsernameLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x20000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> IdentityErrors
    /// </summary>
    public enum IdentityErrors
    {
        
        /// <summary>
        /// >> TooManySubAccounts
        /// Too many subs-accounts.
        /// </summary>
        TooManySubAccounts,
        
        /// <summary>
        /// >> NotFound
        /// Account isn't found.
        /// </summary>
        NotFound,
        
        /// <summary>
        /// >> NotNamed
        /// Account isn't named.
        /// </summary>
        NotNamed,
        
        /// <summary>
        /// >> EmptyIndex
        /// Empty index.
        /// </summary>
        EmptyIndex,
        
        /// <summary>
        /// >> FeeChanged
        /// Fee is changed.
        /// </summary>
        FeeChanged,
        
        /// <summary>
        /// >> NoIdentity
        /// No identity found.
        /// </summary>
        NoIdentity,
        
        /// <summary>
        /// >> StickyJudgement
        /// Sticky judgement.
        /// </summary>
        StickyJudgement,
        
        /// <summary>
        /// >> JudgementGiven
        /// Judgement given.
        /// </summary>
        JudgementGiven,
        
        /// <summary>
        /// >> InvalidJudgement
        /// Invalid judgement.
        /// </summary>
        InvalidJudgement,
        
        /// <summary>
        /// >> InvalidIndex
        /// The index is invalid.
        /// </summary>
        InvalidIndex,
        
        /// <summary>
        /// >> InvalidTarget
        /// The target is invalid.
        /// </summary>
        InvalidTarget,
        
        /// <summary>
        /// >> TooManyRegistrars
        /// Maximum amount of registrars reached. Cannot add any more.
        /// </summary>
        TooManyRegistrars,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// Account ID is already named.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> NotSub
        /// Sender is not a sub-account.
        /// </summary>
        NotSub,
        
        /// <summary>
        /// >> NotOwned
        /// Sub-account isn't owned by sender.
        /// </summary>
        NotOwned,
        
        /// <summary>
        /// >> JudgementForDifferentIdentity
        /// The provided judgement was for a different identity.
        /// </summary>
        JudgementForDifferentIdentity,
        
        /// <summary>
        /// >> JudgementPaymentFailed
        /// Error that occurs when there is an issue paying for judgement.
        /// </summary>
        JudgementPaymentFailed,
        
        /// <summary>
        /// >> InvalidSuffix
        /// The provided suffix is too long.
        /// </summary>
        InvalidSuffix,
        
        /// <summary>
        /// >> NotUsernameAuthority
        /// The sender does not have permission to issue a username.
        /// </summary>
        NotUsernameAuthority,
        
        /// <summary>
        /// >> NoAllocation
        /// The authority cannot allocate any more usernames.
        /// </summary>
        NoAllocation,
        
        /// <summary>
        /// >> InvalidSignature
        /// The signature on a username was not valid.
        /// </summary>
        InvalidSignature,
        
        /// <summary>
        /// >> RequiresSignature
        /// Setting this username requires a signature, but none was provided.
        /// </summary>
        RequiresSignature,
        
        /// <summary>
        /// >> InvalidUsername
        /// The username does not meet the requirements.
        /// </summary>
        InvalidUsername,
        
        /// <summary>
        /// >> UsernameTaken
        /// The username is already taken.
        /// </summary>
        UsernameTaken,
        
        /// <summary>
        /// >> NoUsername
        /// The requested username does not exist.
        /// </summary>
        NoUsername,
        
        /// <summary>
        /// >> NotExpired
        /// The username cannot be forcefully removed because it can still be accepted.
        /// </summary>
        NotExpired,
    }
}
