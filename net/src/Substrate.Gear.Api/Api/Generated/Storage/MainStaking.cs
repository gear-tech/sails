#nullable disable
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.Gear.Api.Generated.Storage
{
    
    
    /// <summary>
    /// >> StakingStorage
    /// </summary>
    public sealed class StakingStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> StakingStorage Constructor
        /// </summary>
        public StakingStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinimumValidatorCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Invulnerables"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Bonded"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinNominatorBond"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinValidatorBond"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinimumActiveStake"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MinCommission"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Ledger"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.StakingLedger)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Payee"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.EnumRewardDestination)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Validators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForValidators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxValidatorsCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "Nominators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.Nominations)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForNominators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "VirtualStakers"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CounterForVirtualStakers"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxNominatorsCount"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ActiveEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.ActiveEraInfo)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStartSessionIndex"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakers"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Gear.Api.Generated.Model.sp_staking.Exposure)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersOverview"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Gear.Api.Generated.Model.sp_staking.PagedExposureMetadata)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersClipped"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Gear.Api.Generated.Model.sp_staking.Exposure)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasStakersPaged"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(Substrate.Gear.Api.Generated.Model.sp_staking.ExposurePage)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ClaimedRewards"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorPrefs"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasValidatorReward"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasRewardPoints"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.EraRewardPoints)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ErasTotalStake"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ForceEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.EnumForcing)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "MaxStakedRewards"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashRewardFraction"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CanceledSlashPayout"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "UnappliedSlashes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U32), typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.pallet_staking.UnappliedSlash>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "BondedEras"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ValidatorSlashInEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "NominatorSlashInEra"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SlashingSpans"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.slashing.SlashingSpans)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "SpanSlash"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>), typeof(Substrate.Gear.Api.Generated.Model.pallet_staking.slashing.SpanRecord)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "CurrentPlannedSession"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "DisabledValidators"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Staking", "ChillThreshold"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent)));
        }
        
        /// <summary>
        /// >> ValidatorCountParams
        ///  The ideal number of active validators.
        /// </summary>
        public static string ValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ValidatorCountDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorCountDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of active validators.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> ValidatorCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinimumValidatorCountParams
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public static string MinimumValidatorCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinimumValidatorCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumValidatorCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MinimumValidatorCountDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MinimumValidatorCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinimumValidatorCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> InvulnerablesParams
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public static string InvulnerablesParams()
        {
            return RequestGenerator.GetStorage("Staking", "Invulnerables", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> InvulnerablesDefault
        /// Default value as hex string
        /// </summary>
        public static string InvulnerablesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>> Invulnerables(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.InvulnerablesParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BondedParams
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string BondedParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Bonded", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> BondedDefault
        /// Default value as hex string
        /// </summary>
        public static string BondedDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> Bonded(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.BondedParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinNominatorBondParams
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public static string MinNominatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinNominatorBond", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinNominatorBondDefault
        /// Default value as hex string
        /// </summary>
        public static string MinNominatorBondDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinNominatorBond(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinNominatorBondParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinValidatorBondParams
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public static string MinValidatorBondParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinValidatorBond", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinValidatorBondDefault
        /// Default value as hex string
        /// </summary>
        public static string MinValidatorBondDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinValidatorBond(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinValidatorBondParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinimumActiveStakeParams
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        public static string MinimumActiveStakeParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinimumActiveStake", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinimumActiveStakeDefault
        /// Default value as hex string
        /// </summary>
        public static string MinimumActiveStakeDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> MinimumActiveStake
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> MinimumActiveStake(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinimumActiveStakeParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MinCommissionParams
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public static string MinCommissionParams()
        {
            return RequestGenerator.GetStorage("Staking", "MinCommission", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MinCommissionDefault
        /// Default value as hex string
        /// </summary>
        public static string MinCommissionDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill> MinCommission(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MinCommissionParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LedgerParams
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// 
        ///  Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        ///  by [`StakingLedger`] to ensure data and lock consistency.
        /// </summary>
        public static string LedgerParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Ledger", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> LedgerDefault
        /// Default value as hex string
        /// </summary>
        public static string LedgerDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// 
        ///  Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        ///  by [`StakingLedger`] to ensure data and lock consistency.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.StakingLedger> Ledger(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.LedgerParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.StakingLedger>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PayeeParams
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string PayeeParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Payee", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PayeeDefault
        /// Default value as hex string
        /// </summary>
        public static string PayeeDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.EnumRewardDestination> Payee(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.PayeeParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.EnumRewardDestination>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ValidatorsParams
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string ValidatorsParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Validators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorsDefault()
        {
            return "0x0000";
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs> Validators(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForValidatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForValidators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForValidatorsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForValidators(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CounterForValidatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaxValidatorsCountParams
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxValidatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxValidatorsCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxValidatorsCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxValidatorsCountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaxValidatorsCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MaxValidatorsCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NominatorsParams
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public static string NominatorsParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "Nominators", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> NominatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string NominatorsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.Nominations> Nominators(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.Nominations>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForNominatorsParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForNominatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForNominators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForNominatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForNominatorsDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForNominators(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CounterForNominatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> VirtualStakersParams
        ///  Stakers whose funds are managed by other pallets.
        /// 
        ///  This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        ///  are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        ///  directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        ///  via low level apis. We keep track of them to do minimal integrity checks.
        /// </summary>
        public static string VirtualStakersParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "VirtualStakers", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> VirtualStakersDefault
        /// Default value as hex string
        /// </summary>
        public static string VirtualStakersDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> VirtualStakers
        ///  Stakers whose funds are managed by other pallets.
        /// 
        ///  This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        ///  are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        ///  directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        ///  via low level apis. We keep track of them to do minimal integrity checks.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple> VirtualStakers(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.VirtualStakersParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CounterForVirtualStakersParams
        /// Counter for the related counted storage map
        /// </summary>
        public static string CounterForVirtualStakersParams()
        {
            return RequestGenerator.GetStorage("Staking", "CounterForVirtualStakers", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CounterForVirtualStakersDefault
        /// Default value as hex string
        /// </summary>
        public static string CounterForVirtualStakersDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CounterForVirtualStakers
        /// Counter for the related counted storage map
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CounterForVirtualStakers(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CounterForVirtualStakersParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaxNominatorsCountParams
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public static string MaxNominatorsCountParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxNominatorsCount", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxNominatorsCountDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxNominatorsCountDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> MaxNominatorsCount(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MaxNominatorsCountParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CurrentEraParams
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public static string CurrentEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentEraDefault
        /// Default value as hex string
        /// </summary>
        public static string CurrentEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CurrentEra(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CurrentEraParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ActiveEraParams
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public static string ActiveEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ActiveEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ActiveEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ActiveEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.ActiveEraInfo> ActiveEra(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ActiveEraParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.ActiveEraInfo>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStartSessionIndexParams
        ///  The session index at which the era start for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public static string ErasStartSessionIndexParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStartSessionIndex", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasStartSessionIndexDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStartSessionIndexDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> ErasStartSessionIndex(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStartSessionIndexParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStakersParams
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        public static string ErasStakersParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakers", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersDefault()
        {
            return "0x000000";
        }
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_staking.Exposure> ErasStakers(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_staking.Exposure>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStakersOverviewParams
        ///  Summary of validator exposure at a given era.
        /// 
        ///  This contains the total stake in support of the validator and their own stake. In addition,
        ///  it can also be used to get the number of nominators backing this validator and the number of
        ///  exposure pages they are divided into. The page count is useful to determine the number of
        ///  pages of rewards that needs to be claimed.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///  Should only be accessed through `EraInfo`.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty overview is returned.
        /// </summary>
        public static string ErasStakersOverviewParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersOverview", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersOverviewDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersOverviewDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasStakersOverview
        ///  Summary of validator exposure at a given era.
        /// 
        ///  This contains the total stake in support of the validator and their own stake. In addition,
        ///  it can also be used to get the number of nominators backing this validator and the number of
        ///  exposure pages they are divided into. The page count is useful to determine the number of
        ///  pages of rewards that needs to be claimed.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///  Should only be accessed through `EraInfo`.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty overview is returned.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_staking.PagedExposureMetadata> ErasStakersOverview(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersOverviewParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_staking.PagedExposureMetadata>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStakersClippedParams
        ///  Clipped Exposure of validator at era.
        /// 
        ///  Note: This is deprecated, should be used as read-only and will be removed in the future.
        ///  New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxExposurePageSize` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        public static string ErasStakersClippedParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersClipped", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersClippedDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersClippedDefault()
        {
            return "0x000000";
        }
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  Note: This is deprecated, should be used as read-only and will be removed in the future.
        ///  New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxExposurePageSize` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_staking.Exposure> ErasStakersClipped(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersClippedParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_staking.Exposure>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasStakersPagedParams
        ///  Paginated exposure of a validator at given era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion, then stash account and finally
        ///  the page. Should only be accessed through `EraInfo`.
        /// 
        ///  This is cleared after [`Config::HistoryDepth`] eras.
        /// </summary>
        public static string ErasStakersPagedParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasStakersPaged", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasStakersPagedDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasStakersPagedDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasStakersPaged
        ///  Paginated exposure of a validator at given era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion, then stash account and finally
        ///  the page. Should only be accessed through `EraInfo`.
        /// 
        ///  This is cleared after [`Config::HistoryDepth`] eras.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_staking.ExposurePage> ErasStakersPaged(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasStakersPagedParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_staking.ExposurePage>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ClaimedRewardsParams
        ///  History of claimed paged rewards by era and validator.
        /// 
        ///  This is keyed by era and validator stash which maps to the set of page indexes which have
        ///  been claimed.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public static string ClaimedRewardsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ClaimedRewards", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ClaimedRewardsDefault
        /// Default value as hex string
        /// </summary>
        public static string ClaimedRewardsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ClaimedRewards
        ///  History of claimed paged rewards by era and validator.
        /// 
        ///  This is keyed by era and validator stash which maps to the set of page indexes which have
        ///  been claimed.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>> ClaimedRewards(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ClaimedRewardsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasValidatorPrefsParams
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public static string ErasValidatorPrefsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorPrefs", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefsDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasValidatorPrefsDefault()
        {
            return "0x0000";
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs> ErasValidatorPrefs(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorPrefsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasValidatorRewardParams
        ///  The total validator era payout for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public static string ErasValidatorRewardParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasValidatorReward", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasValidatorRewardDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasValidatorRewardDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> ErasValidatorReward(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasValidatorRewardParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasRewardPointsParams
        ///  Rewards for the last [`Config::HistoryDepth`] eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public static string ErasRewardPointsParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasRewardPoints", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasRewardPointsDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasRewardPointsDefault()
        {
            return "0x0000000000";
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last [`Config::HistoryDepth`] eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.EraRewardPoints> ErasRewardPoints(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasRewardPointsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.EraRewardPoints>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ErasTotalStakeParams
        ///  The total amount staked for the last [`Config::HistoryDepth`] eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public static string ErasTotalStakeParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "ErasTotalStake", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ErasTotalStakeDefault
        /// Default value as hex string
        /// </summary>
        public static string ErasTotalStakeDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last [`Config::HistoryDepth`] eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> ErasTotalStake(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ErasTotalStakeParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ForceEraParams
        ///  Mode of era forcing.
        /// </summary>
        public static string ForceEraParams()
        {
            return RequestGenerator.GetStorage("Staking", "ForceEra", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ForceEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ForceEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.EnumForcing> ForceEra(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ForceEraParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.EnumForcing>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MaxStakedRewardsParams
        ///  Maximum staked rewards, i.e. the percentage of the era inflation that
        ///  is used for stake rewards.
        ///  See [Era payout](./index.html#era-payout).
        /// </summary>
        public static string MaxStakedRewardsParams()
        {
            return RequestGenerator.GetStorage("Staking", "MaxStakedRewards", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MaxStakedRewardsDefault
        /// Default value as hex string
        /// </summary>
        public static string MaxStakedRewardsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MaxStakedRewards
        ///  Maximum staked rewards, i.e. the percentage of the era inflation that
        ///  is used for stake rewards.
        ///  See [Era payout](./index.html#era-payout).
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent> MaxStakedRewards(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.MaxStakedRewardsParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SlashRewardFractionParams
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public static string SlashRewardFractionParams()
        {
            return RequestGenerator.GetStorage("Staking", "SlashRewardFraction", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> SlashRewardFractionDefault
        /// Default value as hex string
        /// </summary>
        public static string SlashRewardFractionDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill> SlashRewardFraction(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.SlashRewardFractionParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CanceledSlashPayoutParams
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public static string CanceledSlashPayoutParams()
        {
            return RequestGenerator.GetStorage("Staking", "CanceledSlashPayout", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CanceledSlashPayoutDefault
        /// Default value as hex string
        /// </summary>
        public static string CanceledSlashPayoutDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> CanceledSlashPayout(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CanceledSlashPayoutParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UnappliedSlashesParams
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public static string UnappliedSlashesParams(Substrate.NetApi.Model.Types.Primitive.U32 key)
        {
            return RequestGenerator.GetStorage("Staking", "UnappliedSlashes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> UnappliedSlashesDefault
        /// Default value as hex string
        /// </summary>
        public static string UnappliedSlashesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.pallet_staking.UnappliedSlash>> UnappliedSlashes(Substrate.NetApi.Model.Types.Primitive.U32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.UnappliedSlashesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.pallet_staking.UnappliedSlash>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BondedErasParams
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public static string BondedErasParams()
        {
            return RequestGenerator.GetStorage("Staking", "BondedEras", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> BondedErasDefault
        /// Default value as hex string
        /// </summary>
        public static string BondedErasDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>> BondedEras(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.BondedErasParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ValidatorSlashInEraParams
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public static string ValidatorSlashInEraParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "ValidatorSlashInEra", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEraDefault
        /// Default value as hex string
        /// </summary>
        public static string ValidatorSlashInEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEra(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ValidatorSlashInEraParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NominatorSlashInEraParams
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public static string NominatorSlashInEraParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("Staking", "NominatorSlashInEra", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> NominatorSlashInEraDefault
        /// Default value as hex string
        /// </summary>
        public static string NominatorSlashInEraDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> NominatorSlashInEra(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.NominatorSlashInEraParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SlashingSpansParams
        ///  Slashing spans for stash accounts.
        /// </summary>
        public static string SlashingSpansParams(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key)
        {
            return RequestGenerator.GetStorage("Staking", "SlashingSpans", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SlashingSpansDefault
        /// Default value as hex string
        /// </summary>
        public static string SlashingSpansDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.slashing.SlashingSpans> SlashingSpans(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.SlashingSpansParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.slashing.SlashingSpans>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> SpanSlashParams
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public static string SpanSlashParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key)
        {
            return RequestGenerator.GetStorage("Staking", "SpanSlash", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> SpanSlashDefault
        /// Default value as hex string
        /// </summary>
        public static string SpanSlashDefault()
        {
            return "0x0000000000000000000000000000000000000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.pallet_staking.slashing.SpanRecord> SpanSlash(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32> key, string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.SpanSlashParams(key);
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.pallet_staking.slashing.SpanRecord>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CurrentPlannedSessionParams
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public static string CurrentPlannedSessionParams()
        {
            return RequestGenerator.GetStorage("Staking", "CurrentPlannedSession", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> CurrentPlannedSessionDefault
        /// Default value as hex string
        /// </summary>
        public static string CurrentPlannedSessionDefault()
        {
            return "0x00000000";
        }
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U32> CurrentPlannedSession(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.CurrentPlannedSessionParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> DisabledValidatorsParams
        ///  Indices of validators that have offended in the active era. The offenders are disabled for a
        ///  whole era. For this reason they are kept here - only staking pallet knows about eras. The
        ///  implementor of [`DisablingStrategy`] defines if a validator should be disabled which
        ///  implicitly means that the implementor also controls the max number of disabled validators.
        /// 
        ///  The vec is always kept sorted so that we can find whether a given validator has previously
        ///  offended using binary search.
        /// </summary>
        public static string DisabledValidatorsParams()
        {
            return RequestGenerator.GetStorage("Staking", "DisabledValidators", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> DisabledValidatorsDefault
        /// Default value as hex string
        /// </summary>
        public static string DisabledValidatorsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> DisabledValidators
        ///  Indices of validators that have offended in the active era. The offenders are disabled for a
        ///  whole era. For this reason they are kept here - only staking pallet knows about eras. The
        ///  implementor of [`DisablingStrategy`] defines if a validator should be disabled which
        ///  implicitly means that the implementor also controls the max number of disabled validators.
        /// 
        ///  The vec is always kept sorted so that we can find whether a given validator has previously
        ///  offended using binary search.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>> DisabledValidators(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.DisabledValidatorsParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ChillThresholdParams
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public static string ChillThresholdParams()
        {
            return RequestGenerator.GetStorage("Staking", "ChillThreshold", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ChillThresholdDefault
        /// Default value as hex string
        /// </summary>
        public static string ChillThresholdDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public async Task<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent> ChillThreshold(string blockhash, CancellationToken token)
        {
            string parameters = StakingStorage.ChillThresholdParams();
            var result = await _client.GetStorageAsync<Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> StakingCalls
    /// </summary>
    public sealed class StakingCalls
    {
        
        /// <summary>
        /// >> bond
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Bond(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value, Substrate.Gear.Api.Generated.Model.pallet_staking.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            byteArray.AddRange(payee.Encode());
            return new Method(13, "Staking", 0, "bond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> bond_extra
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method BondExtra(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> max_additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(max_additional.Encode());
            return new Method(13, "Staking", 1, "bond_extra", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unbond
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Unbond(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(13, "Staking", 2, "unbond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method WithdrawUnbonded(Substrate.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(13, "Staking", 3, "withdraw_unbonded", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> validate
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Validate(Substrate.Gear.Api.Generated.Model.pallet_staking.ValidatorPrefs prefs)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(prefs.Encode());
            return new Method(13, "Staking", 4, "validate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> nominate
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Nominate(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> targets)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(targets.Encode());
            return new Method(13, "Staking", 5, "nominate", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Chill()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(13, "Staking", 6, "chill", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_payee
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetPayee(Substrate.Gear.Api.Generated.Model.pallet_staking.EnumRewardDestination payee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(payee.Encode());
            return new Method(13, "Staking", 7, "set_payee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_controller
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetController()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(13, "Staking", 8, "set_controller", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_validator_count
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetValidatorCount(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(@new.Encode());
            return new Method(13, "Staking", 9, "set_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> increase_validator_count
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method IncreaseValidatorCount(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> additional)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(additional.Encode());
            return new Method(13, "Staking", 10, "increase_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> scale_validator_count
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ScaleValidatorCount(Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Percent factor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(factor.Encode());
            return new Method(13, "Staking", 11, "scale_validator_count", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_no_eras
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceNoEras()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(13, "Staking", 12, "force_no_eras", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceNewEra()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(13, "Staking", 13, "force_new_era", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_invulnerables
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetInvulnerables(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> invulnerables)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(invulnerables.Encode());
            return new Method(13, "Staking", 14, "set_invulnerables", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_unstake
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceUnstake(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 stash, Substrate.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(13, "Staking", 15, "force_unstake", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_new_era_always
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceNewEraAlways()
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            return new Method(13, "Staking", 16, "force_new_era_always", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> cancel_deferred_slash
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method CancelDeferredSlash(Substrate.NetApi.Model.Types.Primitive.U32 era, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32> slash_indices)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(era.Encode());
            byteArray.AddRange(slash_indices.Encode());
            return new Method(13, "Staking", 17, "cancel_deferred_slash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> payout_stakers
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method PayoutStakers(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 validator_stash, Substrate.NetApi.Model.Types.Primitive.U32 era)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            byteArray.AddRange(era.Encode());
            return new Method(13, "Staking", 18, "payout_stakers", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> rebond
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Rebond(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(13, "Staking", 19, "rebond", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> reap_stash
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ReapStash(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 stash, Substrate.NetApi.Model.Types.Primitive.U32 num_slashing_spans)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(num_slashing_spans.Encode());
            return new Method(13, "Staking", 20, "reap_stash", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> kick
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method Kick(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Gear.Api.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> who)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(who.Encode());
            return new Method(13, "Staking", 21, "kick", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_staking_configs
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetStakingConfigs(Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp min_nominator_bond, Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp min_validator_bond, Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp max_nominator_count, Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp max_validator_count, Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp chill_threshold, Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp min_commission, Substrate.Gear.Api.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp max_staked_rewards)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(min_nominator_bond.Encode());
            byteArray.AddRange(min_validator_bond.Encode());
            byteArray.AddRange(max_nominator_count.Encode());
            byteArray.AddRange(max_validator_count.Encode());
            byteArray.AddRange(chill_threshold.Encode());
            byteArray.AddRange(min_commission.Encode());
            byteArray.AddRange(max_staked_rewards.Encode());
            return new Method(13, "Staking", 22, "set_staking_configs", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> chill_other
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ChillOther(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 stash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            return new Method(13, "Staking", 23, "chill_other", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_apply_min_commission
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ForceApplyMinCommission(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 validator_stash)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            return new Method(13, "Staking", 24, "force_apply_min_commission", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_min_commission
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetMinCommission(Substrate.Gear.Api.Generated.Model.sp_arithmetic.per_things.Perbill @new)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(@new.Encode());
            return new Method(13, "Staking", 25, "set_min_commission", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> payout_stakers_by_page
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method PayoutStakersByPage(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 validator_stash, Substrate.NetApi.Model.Types.Primitive.U32 era, Substrate.NetApi.Model.Types.Primitive.U32 page)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(validator_stash.Encode());
            byteArray.AddRange(era.Encode());
            byteArray.AddRange(page.Encode());
            return new Method(13, "Staking", 26, "payout_stakers_by_page", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> update_payee
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method UpdatePayee(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 controller)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controller.Encode());
            return new Method(13, "Staking", 27, "update_payee", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> deprecate_controller_batch
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method DeprecateControllerBatch(Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1 controllers)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(controllers.Encode());
            return new Method(13, "Staking", 28, "deprecate_controller_batch", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> restore_ledger
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method RestoreLedger(Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32 stash, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Gear.Api.Generated.Model.sp_core.crypto.AccountId32> maybe_controller, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> maybe_total, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Gear.Api.Generated.Model.bounded_collections.bounded_vec.BoundedVecT2> maybe_unlocking)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(stash.Encode());
            byteArray.AddRange(maybe_controller.Encode());
            byteArray.AddRange(maybe_total.Encode());
            byteArray.AddRange(maybe_unlocking.Encode());
            return new Method(13, "Staking", 29, "restore_ledger", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> StakingConstants
    /// </summary>
    public sealed class StakingConstants
    {
        
        /// <summary>
        /// >> HistoryDepth
        ///  Number of eras to keep in history.
        /// 
        ///  Following information is kept for eras in `[current_era -
        ///  HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,
        ///  `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,
        ///  `ErasTotalStake`, `ErasStartSessionIndex`, `ClaimedRewards`, `ErasStakersPaged`,
        ///  `ErasStakersOverview`.
        /// 
        ///  Must be more than the number of eras delayed by session.
        ///  I.e. active era must always be in history. I.e. `active_era >
        ///  current_era - history_depth` must be guaranteed.
        /// 
        ///  If migrating an existing pallet from storage value to config value,
        ///  this should be set to same value or greater as in storage.
        /// 
        ///  Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`
        ///  item `StakingLedger.legacy_claimed_rewards`. Setting this value lower than
        ///  the existing value can lead to inconsistencies in the
        ///  `StakingLedger` and will need to be handled properly in a migration.
        ///  The test `reducing_history_depth_abrupt` shows this effect.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 HistoryDepth()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x54000000");
            return result;
        }
        
        /// <summary>
        /// >> SessionsPerEra
        ///  Number of sessions per era.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 SessionsPerEra()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x06000000");
            return result;
        }
        
        /// <summary>
        /// >> BondingDuration
        ///  Number of eras that staked funds must remain bonded for.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 BondingDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x0E000000");
            return result;
        }
        
        /// <summary>
        /// >> SlashDeferDuration
        ///  Number of eras that slashes are deferred by, after computation.
        /// 
        ///  This should be less than the bonding duration. Set to 0 if slashes
        ///  should be applied immediately, without opportunity for intervention.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 SlashDeferDuration()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x0D000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxExposurePageSize
        ///  The maximum size of each `T::ExposurePage`.
        /// 
        ///  An `ExposurePage` is weakly bounded to a maximum of `MaxExposurePageSize`
        ///  nominators.
        /// 
        ///  For older non-paged exposure, a reward payout was restricted to the top
        ///  `MaxExposurePageSize` nominators. This is to limit the i/o cost for the
        ///  nominator payout.
        /// 
        ///  Note: `MaxExposurePageSize` is used to bound `ClaimedRewards` and is unsafe to reduce
        ///  without handling it in a migration.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxExposurePageSize()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00010000");
            return result;
        }
        
        /// <summary>
        /// >> MaxUnlockingChunks
        ///  The maximum number of `unlocking` chunks a [`StakingLedger`] can
        ///  have. Effectively determines how many unique eras a staker may be
        ///  unbonding in.
        /// 
        ///  Note: `MaxUnlockingChunks` is used as the upper bound for the
        ///  `BoundedVec` item `StakingLedger.unlocking`. Setting this value
        ///  lower than the existing value can lead to inconsistencies in the
        ///  `StakingLedger` and will need to be handled properly in a runtime
        ///  migration. The test `reducing_max_unlocking_chunks_abrupt` shows
        ///  this effect.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxUnlockingChunks()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x20000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> StakingErrors
    /// </summary>
    public enum StakingErrors
    {
        
        /// <summary>
        /// >> NotController
        /// Not a controller account.
        /// </summary>
        NotController,
        
        /// <summary>
        /// >> NotStash
        /// Not a stash account.
        /// </summary>
        NotStash,
        
        /// <summary>
        /// >> AlreadyBonded
        /// Stash is already bonded.
        /// </summary>
        AlreadyBonded,
        
        /// <summary>
        /// >> AlreadyPaired
        /// Controller is already paired.
        /// </summary>
        AlreadyPaired,
        
        /// <summary>
        /// >> EmptyTargets
        /// Targets cannot be empty.
        /// </summary>
        EmptyTargets,
        
        /// <summary>
        /// >> DuplicateIndex
        /// Duplicate index.
        /// </summary>
        DuplicateIndex,
        
        /// <summary>
        /// >> InvalidSlashIndex
        /// Slash record index out of bounds.
        /// </summary>
        InvalidSlashIndex,
        
        /// <summary>
        /// >> InsufficientBond
        /// Cannot have a validator or nominator role, with value less than the minimum defined by
        /// governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
        /// intention, `chill` first to remove one's role as validator/nominator.
        /// </summary>
        InsufficientBond,
        
        /// <summary>
        /// >> NoMoreChunks
        /// Can not schedule more unlock chunks.
        /// </summary>
        NoMoreChunks,
        
        /// <summary>
        /// >> NoUnlockChunk
        /// Can not rebond without unlocking chunks.
        /// </summary>
        NoUnlockChunk,
        
        /// <summary>
        /// >> FundedTarget
        /// Attempting to target a stash that still has funds.
        /// </summary>
        FundedTarget,
        
        /// <summary>
        /// >> InvalidEraToReward
        /// Invalid era to reward.
        /// </summary>
        InvalidEraToReward,
        
        /// <summary>
        /// >> InvalidNumberOfNominations
        /// Invalid number of nominations.
        /// </summary>
        InvalidNumberOfNominations,
        
        /// <summary>
        /// >> NotSortedAndUnique
        /// Items are not sorted and unique.
        /// </summary>
        NotSortedAndUnique,
        
        /// <summary>
        /// >> AlreadyClaimed
        /// Rewards for this era have already been claimed for this validator.
        /// </summary>
        AlreadyClaimed,
        
        /// <summary>
        /// >> InvalidPage
        /// No nominators exist on this page.
        /// </summary>
        InvalidPage,
        
        /// <summary>
        /// >> IncorrectHistoryDepth
        /// Incorrect previous history depth input provided.
        /// </summary>
        IncorrectHistoryDepth,
        
        /// <summary>
        /// >> IncorrectSlashingSpans
        /// Incorrect number of slashing spans provided.
        /// </summary>
        IncorrectSlashingSpans,
        
        /// <summary>
        /// >> BadState
        /// Internal state has become somehow corrupted and the operation cannot continue.
        /// </summary>
        BadState,
        
        /// <summary>
        /// >> TooManyTargets
        /// Too many nomination targets supplied.
        /// </summary>
        TooManyTargets,
        
        /// <summary>
        /// >> BadTarget
        /// A nomination target was supplied that was blocked or otherwise not a validator.
        /// </summary>
        BadTarget,
        
        /// <summary>
        /// >> CannotChillOther
        /// The user has enough bond and thus cannot be chilled forcefully by an external person.
        /// </summary>
        CannotChillOther,
        
        /// <summary>
        /// >> TooManyNominators
        /// There are too many nominators in the system. Governance needs to adjust the staking
        /// settings to keep things safe for the runtime.
        /// </summary>
        TooManyNominators,
        
        /// <summary>
        /// >> TooManyValidators
        /// There are too many validator candidates in the system. Governance needs to adjust the
        /// staking settings to keep things safe for the runtime.
        /// </summary>
        TooManyValidators,
        
        /// <summary>
        /// >> CommissionTooLow
        /// Commission is too low. Must be at least `MinCommission`.
        /// </summary>
        CommissionTooLow,
        
        /// <summary>
        /// >> BoundNotMet
        /// Some bound is not met.
        /// </summary>
        BoundNotMet,
        
        /// <summary>
        /// >> ControllerDeprecated
        /// Used when attempting to use deprecated controller account logic.
        /// </summary>
        ControllerDeprecated,
        
        /// <summary>
        /// >> CannotRestoreLedger
        /// Cannot reset a ledger.
        /// </summary>
        CannotRestoreLedger,
        
        /// <summary>
        /// >> RewardDestinationRestricted
        /// Provided reward destination is not allowed.
        /// </summary>
        RewardDestinationRestricted,
        
        /// <summary>
        /// >> NotEnoughFunds
        /// Not enough funds available to withdraw.
        /// </summary>
        NotEnoughFunds,
        
        /// <summary>
        /// >> VirtualStakerNotAllowed
        /// Operation not allowed for virtual stakers.
        /// </summary>
        VirtualStakerNotAllowed,
    }
}
